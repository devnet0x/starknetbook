msgid ""
msgstr ""
"Project-Id-Version: The Starknet Book\n"
"POT-Creation-Date: 2023-10-14T23:48:22+09:00\n"
"PO-Revision-Date: 2023-10-15 01:58+0900\n"
"Last-Translator: y-bi <cryptonerdcn@gmail.com>\n"
"Language-Team: Language zh-cn\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 3.4\n"

#: src/SUMMARY.md:1 src/title-page.md:1
msgid "The Starknet Book"
msgstr "Starknet 之书"

#: src/SUMMARY.md:4
msgid "Introduction"
msgstr "介绍"

#: src/SUMMARY.md:8 src/ch01-00-getting-started.md:1
#: src/ch02-07-starknet-js.md:29
msgid "Getting Started"
msgstr "入门"

#: src/SUMMARY.md:10
msgid "Tooling"
msgstr "工具"

#: src/SUMMARY.md:13
msgid "Basic Installation"
msgstr "基本安装"

#: src/SUMMARY.md:14
msgid "Compile, Deploy, Interact"
msgstr "编译、部署、互动"

#: src/SUMMARY.md:15 src/ch02-03-scarb.md:1
msgid "Scarb: The Package Manager"
msgstr "Scarb：软件包管理器"

#: src/SUMMARY.md:16 src/ch02-04-starkli.md:1
msgid "Starkli: A CLI interface 🚧"
msgstr "Starkli：CLI 界面 🚧"

#: src/SUMMARY.md:17 src/ch02-05-katana.md:1
msgid "Katana: A Local Node"
msgstr "Katana: 本地节点"

#: src/SUMMARY.md:18 src/ch02-06-starknet-devnet.md:1
msgid "Starknet Devnet 🚧"
msgstr "Starknet Devnet 🚧"

#: src/SUMMARY.md:19 src/ch02-07-starknet-js.md:1
msgid "Starknet-js: Javascript SDK"
msgstr "Starknet-js: Javascript SDK"

#: src/SUMMARY.md:20 src/SUMMARY.md:47 src/ch02-07-01-examples.md:1
#: src/ch04-04-examples.md:1
msgid "Examples"
msgstr "示例"

#: src/SUMMARY.md:21
msgid "Beginner - Counter UI"
msgstr "初学者 - 计数器 UI"

#: src/SUMMARY.md:22
msgid "Beginner - ERC-20 UI"
msgstr "初学者 - ERC-20 UI"

#: src/SUMMARY.md:23
msgid "Intermediate - Million Dollar Homepage"
msgstr "中级 - 百万美元级别的主页"

#: src/SUMMARY.md:24 src/ch02-08-starknet-react.md:1
msgid "Starknet-React: React Integration"
msgstr "Starknet-React: React 集成"

#: src/SUMMARY.md:25 src/ch02-09-starknet-py.md:1
msgid "Starknet-py: Python SDK 🚧"
msgstr "Starknet-py: Python SDK 🚧"

#: src/SUMMARY.md:26 src/ch02-10-starknet-rs.md:1
msgid "Starknet-rs: Rust SDK 🚧"
msgstr "Starknet-rs: Rust SDK 🚧"

#: src/SUMMARY.md:27 src/ch02-11-foundry-forge.md:1
msgid "Foundry Forge: Testing 🚧"
msgstr "Foundry Forge: 测试工具 🚧"

#: src/SUMMARY.md:28 src/ch02-12-foundry-cast.md:1
msgid "Foundry Cast: Interacting with Starknet 🚧"
msgstr "Foundry Cast: 与 Starknet 交互🚧"

#: src/SUMMARY.md:30 src/ch03-00-architecture.md:1
msgid "Architecture"
msgstr "架构"

#: src/SUMMARY.md:33 src/ch03-01-transactions.md:1
msgid "Transactions"
msgstr "交易"

#: src/SUMMARY.md:34 src/ch03-00-architecture.md:53 src/ch03-02-sequencers.md:1
msgid "Sequencers"
msgstr "排序器"

#: src/SUMMARY.md:35
msgid "Provers 🚧"
msgstr "证明器 🚧"

#: src/SUMMARY.md:36
msgid "Nodes 🚧"
msgstr "节点 🚧"

#: src/SUMMARY.md:37
msgid "Layer 3 and App Chains 🚧 "
msgstr "Layer 3 和应用链 🚧  "

#: src/SUMMARY.md:38 src/ch03-06-solidity-verifier.md:1
msgid "Solidity Verifier 🚧"
msgstr "Solidity 验证器 🚧"

#: src/SUMMARY.md:39 src/ch03-07-decentralization.md:1
msgid "Decentralization 🚧"
msgstr "去中心化 🚧"

#: src/SUMMARY.md:41 src/ch04-00-account-abstraction.md:1
msgid "Account Abstraction"
msgstr "账户抽象"

#: src/SUMMARY.md:44
msgid "Accounts"
msgstr "账户"

#: src/SUMMARY.md:45
msgid "Hello, Account! 🚧"
msgstr "你好，账户！🚧"

#: src/SUMMARY.md:46
msgid "Standard AccounT 🚧"
msgstr "标准账户 🚧"

#: src/SUMMARY.md:48
msgid "Multicaller 🚧"
msgstr "Multicaller 🚧"

#: src/SUMMARY.md:49
msgid "Multisig 🚧"
msgstr "多签 🚧"

#: src/SUMMARY.md:50 src/ch04-04-03-auto-payments.md:1
msgid "Auto-Payments 🚧"
msgstr "自动付款 🚧"

#: src/SUMMARY.md:51 src/ch04-04-04-alternative-signature-schemes.md:1
msgid "Alternative Signature Schemes 🚧"
msgstr "替代签名方案 🚧"

#: src/SUMMARY.md:55
msgid "STARKs 🚧"
msgstr "STARKs 🚧"

#: src/SUMMARY.md:56
msgid "Basics 🚧"
msgstr "基础知识 🚧"

#: src/SUMMARY.md:57
msgid "Math Primer 🚧"
msgstr "数学入门 🚧"

#: src/SUMMARY.md:58
msgid "Number Theory 🚧"
msgstr "数论 🚧"

#: src/SUMMARY.md:59
msgid "Geometry 🚧"
msgstr "几何 🚧"

#: src/SUMMARY.md:60
msgid "Cryptographic Primitives 🚧"
msgstr "加密原语 🚧"

#: src/SUMMARY.md:61
msgid "Arithimization 🚧"
msgstr "拟真 🚧"

#: src/SUMMARY.md:62
msgid "Low Degree Testing 🚧"
msgstr "低度测试 🚧"

#: src/SUMMARY.md:63
msgid "FRI Protocol 🚧"
msgstr "FRI 协议 🚧"

#: src/SUMMARY.md:64
msgid "Efficient STARKs"
msgstr "高效 STARKs"

#: src/SUMMARY.md:65
msgid "STARKs Protocol (Python) 🚧"
msgstr "STARKs 协议（Python） 🚧"

#: src/SUMMARY.md:66 src/SUMMARY.md:71
msgid "Trace/Low Degree Extension 🚧"
msgstr "追迹/低度 扩展 🚧"

#: src/SUMMARY.md:67 src/SUMMARY.md:72
msgid "Constraints 🚧"
msgstr "约束 🚧"

#: src/SUMMARY.md:68 src/SUMMARY.md:73
msgid "FRI Commitments 🚧"
msgstr "FRI 承诺 🚧"

#: src/SUMMARY.md:69 src/SUMMARY.md:74
msgid "Query Phase 🚧"
msgstr "查询阶段 🚧"

#: src/SUMMARY.md:70
msgid "STARKs Protocol (Rust) 🚧"
msgstr "STARKs 协议（Rust） 🚧"

#: src/title-page.md:3
msgid ""
"The Starknet Book is a work in progress, shaped by ongoing community input. "
"Some sections may be incomplete or still under review and are marked under a "
"🚧 emoji. We welcome your suggestions, feedback, and content contributions to "
"make this book a reliable guide for everyone."
msgstr ""
"Starknet Book 是一个由社区的持续贡献的尚在撰写中的作品。某些部分可能不完整或仍"
"在被审校中，这些部分会被用🚧表情符号进行标记。我们欢迎您的建议、反馈和内容贡"
"献，来使得本书成为所有开发者的可靠指南。"

#: src/title-page.md:8
msgid ""
"The Starknet Book is a step-by-step guide aimed at teaching you the "
"essentials of Starknet development. It’s a community effort, with each "
"chapter guiding you through the Starknet ecosystem."
msgstr ""
"Starknet Book 是一本循序渐进的指南，旨在向你传授Starknet 开发的基本知识。这本"
"书由社区的合力撰写，每一章都会引导你了解Starknet 的生态系统。中文版由"
"[StarknetAstro](https://twitter.com/StarkNetAstroCN)翻译。"

#: src/title-page.md:12
msgid ""
"Understanding Cairo, the key programming language for Starknet smart "
"contracts, is crucial. That’s why this book works hand-in-hand with the Cairo "
"Book, another community resource. You can access the Cairo Book [**here**]"
"(https://book.cairo-lang.org/)."
msgstr ""
"了解在Starknet 智能合约中处于关键位置的编程语言Cairo，是至关重要的。因此，本书"
"与另一个由社区编写的《Cairo之书》（Cairo Book）携手合作。你可以从[**这里**]"
"(https://book.cairo-lang.org/)访问Cairo Book。"

#: src/title-page.md:17
msgid ""
"In short, the Cairo Book helps you master Cairo, while The Starknet Book "
"focuses on Starknet’s specific features. For a well-rounded understanding, we "
"recommend exploring both. This book will introduce you to tools, "
"architecture, account setups, STARKs, and Starknet-specific apps."
msgstr ""
"简而言之，Cairo Book 帮助您掌握Cairo语言，而Starknet Book则侧重于Starknet的具"
"体功能。为了全面了解，我们建议您同时阅读这两本书。本书将向你介绍工具、架构、账"
"户设置、STARK 和Starknet专用应用程序。"

#: src/title-page.md:23
msgid "Table of Contents"
msgstr "内容目录"

#: src/title-page.md:25
msgid "**Chapter Titles**"
msgstr "**章节标题**"

#: src/title-page.md:27
msgid "Chapter"
msgstr "章节"

#: src/title-page.md:27
msgid "Description"
msgstr "描述"

#: src/title-page.md:29
msgid "1: Starknet Introduction"
msgstr "1: Starknet简介与入门"

#: src/title-page.md:29
msgid ""
"Delve into the fundamental concepts of Starknet and acquaint yourself with "
"the deployment of smart contracts."
msgstr "深入了解Starknet的基本概念，熟悉智能合约的部署。"

#: src/title-page.md:30
msgid "2: Starknet Tooling"
msgstr "2: Starknet中的工具"

#: src/title-page.md:30
msgid ""
"Familiarize yourself with vital tools, such as Protostar and Hardhat, and "
"explore how languages like Javascript, Python, and Rust can be leveraged for "
"Starknet interactions."
msgstr ""
"熟悉 Protostar 和 Hardhat 等重要工具，探索如何利用 Javascript、Python 和 Rust "
"等语言与Starknet进行互动。"

#: src/title-page.md:31
msgid "3: Starknet Architecture"
msgstr "3: Starknet架构"

#: src/title-page.md:31
msgid ""
"Uncover Starknet’s core structure, gaining insights into the transaction "
"lifecycle and the interplay between the Sequencer, Prover, and Nodes."
msgstr ""
"探索Starknet的核心结构，深入了解交易的生命周期以及排序器、验证器和节点之间的如"
"何相互作用。"

#: src/title-page.md:32
msgid "4: Account Abstraction"
msgstr "4: 账户抽象"

#: src/title-page.md:32
msgid ""
"Delve deep into Starknet’s unique approach to user accounts, and master the "
"art of crafting custom accounts."
msgstr "深入了解Starknet独特的用户账户方法，掌握创建自定义账户的艺术。"

#: src/title-page.md:33
msgid "5: STARKs"
msgstr "5: STARKs"

#: src/title-page.md:33
msgid ""
"Dive into the intricacies of STARKs and their pivotal role in shaping "
"Starknet’s landscape."
msgstr "深入了解 STARKs 的复杂性及其在塑造Starknet环境中的关键作用。"

#: src/title-page.md:35
msgid "Where to Start?"
msgstr "从哪里开始？"

#: src/title-page.md:37
msgid ""
"Depending on your goals and interests, you can choose different paths through "
"the Starknet Book. Here are some recommendations based on various objectives:"
msgstr ""
"根据您的目标和兴趣，您可以在Starknet Book中选择不同的学习路径。下面是一些基于"
"不同目标的建议："

#: src/title-page.md:41
msgid ""
"If you’re a **complete beginner** and want to start learning about Cairo and "
"Starknet from scratch, follow the book in its entirety, starting with "
"**Introduction to Starknet**."
msgstr ""
"如果你是一个 **完全的初学者** ，想从头开始学习Cairo和Starknet，请从**介绍"
"Starknet**开始，完整地阅读本书。"

#: src/title-page.md:45
msgid ""
"If you’re an **experienced developer** looking to quickly dive into writing "
"scalable and decentralized smart contracts, focus on the Cairo Book, "
"particularly **chapter 12: Starknet Smart Contracts** ([link](https://book."
"cairo-lang.org/ch99-00-starknet-smart-contracts.html))."
msgstr ""
"如果你是一名 **经验丰富的开发者**，希望快速深入编写可扩展的去中心化智能合约，"
"请重点阅读《Cairo Book》，尤其是 **第12章：Starknet智能合约**（[链接](https://"
"book.cairo-lang.org/ch99-00-starknet-smart-contracts.html)）。"

#: src/title-page.md:50
msgid ""
"If you’re a **frontend developer** wanting to integrate Starknet with a React "
"frontend using Javascript, prioritize the **starknet-js** and **starknet-"
"react** subchapters in **Starknet Tooling**"
msgstr ""
"如果您是一名**前端开发者**，希望使用 Javascript 将 Starknet 与 React 前端集"
"成，请优先考虑**Starknet上的工具**中的**starknet-js**和**starknet-react**子章"
"节。"

#: src/title-page.md:55
msgid ""
"If you’re a **DevOps engineer** or **node operator** interested in running a "
"Starknet node and indexer, head straight to **Starknet Architecture**."
msgstr ""
"如果您是**运维工程师**或**节点操作员**，对运行Starknet节点和索引器感兴趣，请直"
"接访问**Starknet架构**。"

#: src/title-page.md:59
msgid ""
"If you’re a **security researcher** or **smart contract auditor** wanting to "
"learn about the Account Abstraction feature and its implications, go for "
"**Account Abstraction**."
msgstr ""
"如果您是**安全研究员**或**智能合约审计员**，想了解账户抽象功能及其影响，请选择"
"**账户抽象**。"

#: src/title-page.md:63
msgid ""
"If you’re a **blockchain enthusiast** curious about the underlying "
"architecture and mechanics of Starknet and Cairo, explore **Starknet "
"Architecture**."
msgstr ""
"如果您是**区块链爱好者**，对Starknet和Cairo的底层架构和机制充满好奇，请探索"
"**Starknet架构**。"

#: src/title-page.md:67
msgid ""
"If you’re a **cryptography expert** or **researcher** eager to understand the "
"fundamentals of STARKs and their connection to the Starknet ecosystem, delve "
"into **STARKs**."
msgstr ""
"如果您是**密码学专家**或**研究人员**，渴望了解 STARKs 的基本原理及其与Starknet"
"生态系统的联系，请深入研究**STARKs**。"

#: src/title-page.md:71
msgid ""
"Feel free to mix and match these paths based on your unique interests and "
"requirements."
msgstr "您可以根据自己的独特兴趣和要求自由搭配这些学习路径。"

#: src/title-page.md:74
msgid "Your Contributions Matter"
msgstr "您的贡献很重要"

#: src/title-page.md:76
msgid ""
"Welcome aboard! By contributing to the Starknet Book, you’re doing more than "
"sharing expertise—you’re shaping the future of decentralized tech. Let’s "
"build a guide that helps developers unlock Starknet’s potential."
msgstr ""
"欢迎加入！通过为Starknet之书做出贡献，您所做的不仅仅是分享专业知识，您还在塑造"
"去中心化技术的未来。让我们共同打造一本帮助开发者释放Starknet潜力的指南。"

#: src/title-page.md:80
msgid ""
"For detailed contribution guidelines, visit the [Contributors Guide](https://"
"github.com/starknet-edu/starknetbook/blob/main/CONTRIBUTING.adoc). Every "
"contribution counts. Your skills and passion will help make this book an "
"invaluable tool."
msgstr ""
"有关详细的投稿指南，请访问 [Contributors Guide](https://github.com/starknet-"
"edu/starknetbook/blob/main/CONTRIBUTING.adoc)。每一份贡献都很重要。您的技能和"
"热情将帮助本书成为一本宝贵的工具书。"

#: src/title-page.md:85
msgid "How You Can Help"
msgstr "如何提供帮助"

#: src/title-page.md:87
msgid "Found an empty section? Fill it in!"
msgstr "发现空白章节？你可以自己来写满它！"

#: src/title-page.md:89
msgid "Think we need a new section? Suggest one."
msgstr "认为我们需要一个新章节？请提出建议。"

#: src/title-page.md:91
msgid "See room for improvement? Go ahead and tweak it."
msgstr "看到改进的余地了吗？你可以进一步调整它。"

#: src/title-page.md:93
msgid "Want to add code in a new programming language? Go for it."
msgstr "想用新的编程语言添加代码？那就试试吧。"

#: src/title-page.md:95
msgid "Found a bug? Fix it."
msgstr "发现错误？你可以修复它。"

#: src/title-page.md:97
msgid "Exercises unclear? Add explanations."
msgstr "练习不清楚？你可以添加说明。"

#: src/title-page.md:99
msgid "Show off your favorite Cairo features through new exercises."
msgstr "通过新的练习展示你最喜欢的Cairo功能。"

#: src/title-page.md:101
msgid "Additional Key Educational Resources"
msgstr "其他重要教育资源"

#: src/title-page.md:103
msgid ""
"We’ve compiled a list of valuable educational resources that will help deepen "
"your understanding and enhance your skills in coding with Cairo and staying "
"abreast with Starknet developments:"
msgstr ""
"我们编撰了一份有价值的教育资源清单，这些资源将有助于加深您对Cairo语言的理解，"
"提高您的技能，并紧跟Starknet发展的步伐："

#: src/title-page.md:107
msgid ""
"**Cairo Book**: A comprehensive guide to Cairo, the programming language for "
"Starknet smart contracts. You can access it [here](https://book.cairo-lang."
"org/)."
msgstr ""
"**Cairo 之书**：Starknet智能合约编程语言Cairo的综合指南。您可以通过 [此处]"
"(https://book.cairo-lang.org/zh-cn/title-page.html) 访问。"

#: src/title-page.md:111
msgid ""
"**Starklings**: A resource specifically designed to guide you through "
"learning Cairo programming, ensuring that you reach a proficient level. You "
"can access it [here](https://github.com/shramee/starklings-cairo1)."
msgstr ""
"**Starklings**：一份专为指导您学习Cairo编程而设计的教程，并确保您达到熟练水"
"平。您可以通过 [此处](https://github.com/shramee/starklings-cairo1) 访问。"

#: src/title-page.md:116
msgid ""
"**Starknet Community Forum**: An online platform where you can engage in "
"discussions about the latest developments in Starknet. Join the conversation "
"[here](https://community.starknet.io/)."
msgstr ""
"**Starknet社区论坛**：一个在线平台，在这里您可以参与有关Starknet最新发展的讨"
"论。您可以通过 [此处](https://community.starknet.io/) 加入讨论。"

#: src/title-page.md:120
msgid ""
"**Starknet Documentation**: You can browse through the documentation [here]"
"(https://docs.starknet.io/)."
msgstr "**Starknet文档**：您可以在[此处](https://docs.starknet.io/) 浏览文档 。"

#: src/title-page.md:123
msgid ""
"**Cairo Documentation**: Explore it [here](https://www.cairo-lang.org/docs)."
msgstr "**Cairo文档**：在 [此处](https://www.cairo-lang.org/docs) 浏览。"

#: src/title-page.md:126
msgid ""
"**Starknet Developer Telegram (English)**: A community for English-speaking "
"Starknet developers. This is a great platform for networking, sharing ideas, "
"and troubleshooting together. Join us on Telegram [here](https://t.me/"
"starknetna)."
msgstr ""
"**Starknet开发者电报（英语）**：英语Starknet开发人员社区。这是一个交流、分享想"
"法和共同排除故障的绝佳平台。在 [此处](https://t.me/starknetna) 加入我们的 "
"Telegram。"

#: src/ch00-00-introduction.md:1
msgid "The Starknet Network"
msgstr "Starknet网络"

#: src/ch00-00-introduction.md:3
msgid "Preamble"
msgstr "前言"

#: src/ch00-00-introduction.md:5
msgid ""
"Historically, societal roles like currency, property rights, and social "
"status titles have been governed by _protocols_ and _registries_. Their value "
"stems from a widely accepted understanding of their integrity. These "
"functions have predominantly been overseen by centralized entities prone to "
"challenges such as corruption, agency conflicts, and exclusion ([Eli Ben-"
"Sasson, Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/"
"ryMelVulp))."
msgstr ""
"从历史上看，货币、财产权和社会地位称号等社会角色都是由 _协议_ 和 _登记机构_ 管"
"理的。它们的价值源于人们对其完整性的广泛认可。这些功能主要由中央集权的实体来负"
"责监督，容易出现腐败、机构冲突和排斥等问题（[Eli Ben-Sasson、Bareli、Brandt、"
"Volokh，2023](https://hackmd.io/@Elibensasson/ryMelVulp)）。"

#: src/ch00-00-introduction.md:7
msgid ""
"Satoshi's creation, Bitcoin, introduced a novel approach for these functions, "
"termed an _integrity web_. This is an infrastructure for societal roles that:"
msgstr ""
"中本聪创造的比特币，为这些功能引入了一种新颖的方式，称为 _完整性网络_ 。这是一"
"个针对社会角色的基础设施，具有以下特点："

#: src/ch00-00-introduction.md:9
msgid "Is openly described by a public protocol."
msgstr "通过公共协议公开描述。"

#: src/ch00-00-introduction.md:10
msgid "Operates over a wide, inclusive, peer-to-peer network."
msgstr "通过广泛、包容的点对点网络运行。"

#: src/ch00-00-introduction.md:11
msgid ""
"Distributes value fairly and extensively to maintain societal consensus on "
"its integrity."
msgstr "公平、广泛地分配价值，以保持社会对其完整性的共识。"

#: src/ch00-00-introduction.md:13
msgid ""
"While Bitcoin addressed monetary functions, Ethereum expanded this to include "
"any function that can be defined by computer programming. Both faced the "
"challenge of balancing scalability with decentralization. These integrity "
"webs have often favored inclusivity over capacity, ensuring even those with "
"limited resources can authenticate the system's integrity. Yet, this means "
"they struggle to meet global demand."
msgstr ""
"比特币解决的是货币功能，而以太坊则将其扩展到包括任何可以通过计算机编程定义的功"
"能。两者都面临着平衡可扩展性与去中心化的挑战。这些完整性网络通常倾向于包容性而"
"非容量，以确保即使资源有限的人也能验证系统的完整性。然而，这意味着它们很难满足"
"全球级的需求。"

#: src/ch00-00-introduction.md:15
msgid "Defining \"Blockchain\""
msgstr "定义 \"区块链\""

#: src/ch00-00-introduction.md:17
msgid ""
"In the ever-evolving realm of technology, defining a term as multifaceted as "
"\"Blockchain\" can be challenging. Based on current understandings and "
"applications, a Blockchain can be characterized by the following three "
"properties ([Eli Ben-Sasson, 2023](https://twitter.com/EliBenSasson/"
"status/1709272086504485265)):"
msgstr ""
"在不断发展的技术领域，定义一个像 \"区块链 \"这样多层面的术语可能具有挑战性。根"
"据目前的理解和应用，区块链可具有以下三个特性（[Eli Ben-Sasson，2023](https://"
"twitter.com/EliBenSasson/status/1709272086504485265)）："

#: src/ch00-00-introduction.md:19
msgid ""
"**Public Protocol:** The foundation of a Blockchain rests upon a protocol "
"that is openly available. This transparency ensures that any interested party "
"can understand its workings, fostering trust and enabling wider adoption."
msgstr ""
"**公共协议：** 区块链的基础是公开可用的协议。这种透明度可确保任何感兴趣的人都"
"能了解其工作原理，从而促进信任，使其得到更广泛的采用。"

#: src/ch00-00-introduction.md:20
msgid ""
"**Open P2P Network:** Instead of relying on a centralized entity, a "
"Blockchain operates over a peer-to-peer (P2P) network. This decentralized "
"approach ensures that operations are distributed across various participants "
"or nodes, making the system more resilient to failures and censorship."
msgstr ""
"**开放的点对点网络：** 区块链通过点对点（P2P）网络运行，而不是依赖一个中央实"
"体。这种去中心化的方法可确保操作分布在不同的参与者或节点上，使系统更好的抵御故"
"障和审查。"

#: src/ch00-00-introduction.md:21
msgid ""
"**Value Distribution:** Central to the Blockchain's operation is the way it "
"rewards its operators. The system autonomously distributes value in a manner "
"that is wide-ranging and equitable. This incentivization not only motivates "
"participants to maintain the system's integrity but also ensures a broader "
"societal consensus."
msgstr ""
"**价值分配：** 区块链运行的核心是其奖励操作者的方式。该系统以广泛和公平的方式"
"自主分配价值。这种激励方式不仅能激励参与者维护系统的完整性，还能确保达成更广泛"
"的社会共识。"

#: src/ch00-00-introduction.md:23
msgid ""
"While these properties capture the essence of many Blockchains, the term's "
"definition might need refinement as the technology matures and finds new "
"applications. Engaging in continuous dialogue and revisiting definitions will "
"be crucial in this dynamic landscape."
msgstr ""
"虽然这些特性抓住了许多区块链的本质，但随着技术的成熟和新应用的出现，该术语的定"
"义可能依然需要完善。在这一动态环境中，持续的对话和重新审视定义至关重要。"

#: src/ch00-00-introduction.md:25
msgid "Starknet Definition"
msgstr "Starknet的定义"

#: src/ch00-00-introduction.md:27
msgid ""
"Starknet is a Layer-2 network that makes Ethereum transactions faster, "
"cheaper, and more secure using zk-STARKs technology. Think of it as a boosted "
"layer on top of Ethereum, optimized for speed and cost."
msgstr ""
"Starknet 是一个二层网络，利用 zk-STARKs 技术使以太坊交易更快、更便宜、更安全。"
"你可以将其视为以太坊之上的一个增强层，在速度和成本方面进行了优化。"

#: src/ch00-00-introduction.md:29
msgid ""
"Starknet bridges the gap between scalability and broad consensus. It "
"integrates a mathematical framework to navigate the balance between capacity "
"and inclusivity. Its integrity hinges on the robustness of succinct, "
"transparent proofs of computational integrity. This method lets powerful "
"operators enhance Starknet's capacity, ensuring everyone can authenticate "
"Starknet's integrity using universally accessible tools ([Eli Ben-Sasson, "
"Bareli, Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp))."
msgstr ""
"Starknet 弥补了可扩展性与广泛共识之间的差距。它整合了一个数学框架，在容量和包"
"容性之间取得平衡。它的完整性取决于简洁、透明的计算完整性证明的稳健性。这种方法"
"极大的提高Starknet的容量，确保每个用户都能使用普遍可用的工具验证Starknet的完整"
"性（[Eli Ben-Sasson、Bareli、Brandt、Volokh，2023](https://hackmd.io/"
"@Elibensasson/ryMelVulp)）。"

#: src/ch00-00-introduction.md:31
msgid "Starknet’s Mission"
msgstr "Starknet的使命"

#: src/ch00-00-introduction.md:33
msgid ""
"_Starknet’s mission is to allow individuals to freely implement and use any "
"social function they desire._"
msgstr "_Starknet的使命是允许个人自由实现和使用他们所希望的任何社会机能。_"

#: src/ch00-00-introduction.md:35
msgid "Starknet’s Values"
msgstr "Starknet的价值观"

#: src/ch00-00-introduction.md:37
msgid ""
"Starknet's ethos is anchored in core principles ([Eli Ben-Sasson, Bareli, "
"Brandt, Volokh, 2023](https://hackmd.io/@Elibensasson/ryMelVulp)):"
msgstr ""
"Starknet的精神是以核心原则为基础的（[Eli Ben-Sasson、Bareli、Brandt、Volokh，"
"2023](https://hackmd.io/@Elibensasson/ryMelVulp)）："

#: src/ch00-00-introduction.md:39
msgid ""
"**Lasting Broadness.** Starknet continuously resists power consolidation. Key "
"points include:"
msgstr ""
"**Lasting Broadness.**（译者注：可译作坚持广泛性，这里在建议下保留原文） "
"Starknet坚持抵制权力集中。要点包括："

#: src/ch00-00-introduction.md:41
msgid ""
"Broad power distribution underpins Starknet's legitimacy and must persist "
"across operations and decision-making. While centralized operation may be "
"necessary at times, it should be short-lived."
msgstr ""
"广泛的权力分配是Starknet合法性的基础，并必须在整个运作和决策过程中坚持。虽然集"
"中运作有时可能是必要的，但应该是短暂的。"

#: src/ch00-00-introduction.md:42
msgid ""
"Starknet's protocol and governance should always be open and transparent."
msgstr "Starknet的协议和治理应始终公开透明。"

#: src/ch00-00-introduction.md:43
msgid ""
"Governance should bolster inclusivity, with a flexible structure that can "
"evolve to ensure enduring inclusivity."
msgstr "治理应加强包容性，其结构应灵活多变，以确保持久的包容性。"

#: src/ch00-00-introduction.md:45
msgid ""
"**Neutrality.** Starknet remains impartial to the societal functions it "
"supports."
msgstr "**中立性。** Starknet对其支持的社会机能保持中立。"

#: src/ch00-00-introduction.md:47
msgid ""
"The objectives and ethos of functions on Starknet lie with their creators."
msgstr "Starknet上被创建的机能的目标和精神内涵完全取决于机能的创建者。"

#: src/ch00-00-introduction.md:48
msgid ""
"**Censorship resistance:** Starknet remains agnostic to the nature and "
"meaning of user transactions."
msgstr "**抗审查：** Starknet对用户交易的性质和意义保持着不予以探知的态度。"

#: src/ch00-00-introduction.md:50
msgid ""
"**Individual Empowerment.** At its core, Starknet thrives on a well-informed "
"and autonomous user base. This is achieved by fostering a culture rooted in "
"its core mission and values, with a strong emphasis on education."
msgstr ""
"**个体赋权.** Starknet的核心是建立一个信息灵通、自主的用户群。这是通过培养植根"
"于其核心使命和价值观的文化来实现的，同时Starknet也非常重视教育。"

#: src/ch00-00-introduction.md:52
msgid "Key Features"
msgstr "关键特性"

#: src/ch00-00-introduction.md:54
msgid "These are some key features of Starknet:"
msgstr "这些是Starknet的一些关键特性："

#: src/ch00-00-introduction.md:56
msgid ""
"Low Costs: Transactions on Starknet cost less than on Ethereum. Future "
"updates like Volition and EIP 4844 will make it even cheaper."
msgstr ""
"低成本：Starknet的交易成本低于以太坊。未来的更新（如 Volition 和 EIP 4844）将"
"使其更加便宜。"

#: src/ch00-00-introduction.md:59
msgid ""
"Developer-Friendly: Starknet lets developers easily build decentralized apps "
"using its native language, Cairo."
msgstr ""
"开发人员友好：Starknet 可以让开发人员使用其原生语言Cairo语轻松的构建去中心化应"
"用程序。"

#: src/ch00-00-introduction.md:62
msgid ""
"Speed and Efficiency: Upcoming releases aim to make transactions even faster "
"and cheaper."
msgstr "速度与效率：即将发布的新版本旨在使交易更快、更便宜。"

#: src/ch00-00-introduction.md:65
msgid ""
"CVM: Thanks to Cairo, Starknet runs on it´s own VM, called Cairo VM (CVM), "
"that allow us to innovate beyond the Ethereum Virtual Machine (EVM) and "
"create a new paradigm for decentralized applications."
msgstr ""
"CVM：得益于Cairo虚拟机（CVM），Starknet可以在自己的虚拟机上运行，这使得我们可"
"以在以太坊虚拟机（EVM）之外进行创新，并为去中心化应用程序创建一个新的范例。"

#: src/ch00-00-introduction.md:69
msgid "Here some of them:"
msgstr "这里有一些例子："

#: src/ch00-00-introduction.md:71
msgid ""
"Account Abstraction: Implemented at the protocol level, this facilitates "
"diverse signing schemes while ensuring user security and self-custody of "
"assets."
msgstr ""
"账户抽象：在协议层面实施，这有利于采用多种签名方案，同时确保用户安全和资产的自"
"我保管。"

#: src/ch00-00-introduction.md:75
msgid ""
"Volition: Will be implemented on testnet during Q4 2023 will allow developers "
"to regulate data availability on Ethereum (L1) or on Starknet (L2). Reducing "
"L1 onchain data can radically reduce costs."
msgstr ""
"Volition：将于 2023 年第四季度在 testnet 上实施，将允许开发者调整以太坊（L1）"
"或Starknet（L2）上的数据可用性。减少 L1 上链数据可以从根本上降低成本。"

#: src/ch00-00-introduction.md:79
msgid ""
"Paymaster: StarkNet will allow users to choose how to pay for transaction "
"fee, follows the guidelines laid out in EIP 4337 and allows the transaction "
"to specify a specific contract, a **Paymaster**, to pay for their "
"transaction. Supports gasless transactions, enhancing user accessibility."
msgstr ""
"付款人：StarkNet 将允许用户选择支付交易费的方式，遵循 EIP 4337 中规定的准则，"
"并允许交易指定一个特定的合约，即 **付款人**，来支付交易费。该方式支持无gas交"
"易，提高了用户使用便利性。"

#: src/ch00-00-introduction.md:85
msgid "Cairo: The Language of Starknet"
msgstr "Cairo： Starknet的语言"

#: src/ch00-00-introduction.md:87
msgid ""
"Cairo is tailor-made for creating STARK-based smart contracts. As Starknet’s "
"native language, it’s central to building scalable and secure decentralized "
"apps. To start learning now, check out the [Cairo Book](https://cairo-book."
"github.io/) and [Starklings](https://github.com/shramee/starklings-cairo1)."
msgstr ""
"Cairo是为创建基于 STARK 的智能合约而量身定制的。作为Starknet的母语，它是构建可"
"扩展和安全的去中心化应用程序的核心。现在就开始学习吧，请查看 [Cairo Book]"
"(https://cairo-book.github.io/) 和  [Starklings](https://github.com/shramee/"
"starklings-cairo1)。"

#: src/ch00-00-introduction.md:93
msgid ""
"Inspired by Rust, Cairo lets you write contracts safely and conveniently."
msgstr "Cairo受到 Rust 的启发， 并可以让你安全方便地编写合约。"

#: src/ch00-00-introduction.md:96
msgid "Why Choose Cairo?"
msgstr "为什么选择Cairo？"

#: src/ch00-00-introduction.md:98
msgid ""
"Cairo is designed for _Provable Computation,_ a new paradigm that lets "
"programs prove their correctness without re-running them. Here’s why it "
"stands out:"
msgstr ""
"Cairo 是专为 _可证明计算_ 而设计的， _可证明计算_ 是一种让程序无需重新运行就能"
"证明其正确性的新模式。这就是它脱颖而出的原因："

#: src/ch00-00-introduction.md:102
msgid "Purpose-Built: Designed specifically for smart contracts."
msgstr "专门设计：专为智能合约设计。"

#: src/ch00-00-introduction.md:104
msgid "No EVM Limits: Goes beyond what the Ethereum Virtual Machine can do."
msgstr "无 EVM 限制：超越以太坊虚拟机的功能。"

#: src/ch00-00-introduction.md:106
msgid "Flexibility: Uses traits for more flexibility than inheritance."
msgstr "灵活性：与继承相比，使用trait（特质）更具灵活性。"

#: src/ch00-00-introduction.md:108
msgid "Governance"
msgstr "治理"

#: src/ch00-00-introduction.md:110
msgid ""
"The Starknet Foundation oversees Starknet’s governance. Its duties include:"
msgstr "Starknet基金会负责监督Starknet的治理。其职责包括："

#: src/ch00-00-introduction.md:113
msgid "Managing Starknet’s development and operations"
msgstr "管理Starknet的开发和运营"

#: src/ch00-00-introduction.md:115
msgid "Overseeing the Starknet DAO, which enables community involvement"
msgstr "监督Starknet DAO，实现社区参与"

#: src/ch00-00-introduction.md:117
msgid "Setting rules to maintain network integrity"
msgstr "设定规则以保持网络完整性"

#: src/ch00-00-introduction.md:119
msgid ""
"Our focus is on technical input and debate for improving the protocol. While "
"we value all perspectives, it’s often the technical insights that steer us "
"forward."
msgstr ""
"我们的工作重心是技术投入和改进协议的讨论。虽然我们重视所有的观点，但技术方面的"
"见解往往是我们前进的方向。"

#: src/ch00-00-introduction.md:123
msgid ""
"Members can influence Starknet by voting on changes. Here’s the process: A "
"new version is tested on the Goerli Testnet. Members then have six days to "
"review it. A Snapshot proposal is made, and the community votes. A majority "
"of _YES_ votes means an upgrade to the Mainnet."
msgstr ""
"会员可以通过投票来影响Starknet的变化。具体过程如下：新版本在 Goerli 测试网上进"
"行测试。然后，成员有六天的时间对其进行审查。Starknet会提出一个快照建议，然后社"
"区会进行投票。多数投 _赞成_ 则表示着该升级将会应用到主网。"

#: src/ch00-00-introduction.md:128
msgid "In short, governance is key to Starknet’s evolution."
msgstr "总之，治理是Starknet发展的关键。"

#: src/ch00-00-introduction.md:130
msgid "To propose an improvement, create a SNIP."
msgstr "要提出改进建议，请创建一个 SNIP。"

#: src/ch00-00-introduction.md:132
msgid "SNIP: StarkNet Improvement Proposals"
msgstr "SNIP：StarkNet改进提案"

#: src/ch00-00-introduction.md:134
msgid ""
"SNIP is short for StarkNet Improvement Proposal. It’s essentially a blueprint "
"that details proposed enhancements or changes to the StarkNet ecosystem. A "
"well-crafted SNIP includes both the technical specifications of the change "
"and the reasons behind it. If you’re proposing a SNIP, it’s your job to rally "
"community support and document any objections (more details [here](https://"
"community.starknet.io/t/draft-simp-1-simp-purpose-and-guidelines/1197#what-is-"
"a-snip-2)). Once a SNIP is approved, it becomes a part of the Starknet "
"protocol. All the SNIPs can be found in [this repository](https://github.com/"
"starknet-io/SNIPs)."
msgstr ""
"SNIP 是 StarkNet 改进提案的简称。它本质上是一个蓝图，详细描述了对 StarkNet 生"
"态系统提出的改进或变更建议。一份撰写良好的 SNIP 既应包括变更的技术规范，也应包"
"括变更背后的原因。如果您要提出 SNIP，您的工作就是争取社区的支持并记录任何反对"
"意见（更多详情见 [此处](https://community.starknet.io/t/draft-simp-1-simp-"
"purpose-and-guidelines/1197#what-is-a-snip-2)）。一旦 SNIP 获得批准，它将成为"
"Starknet协议的一部分。所有的 SNIP 都可以在 [这个仓库](https://github.com/"
"starknet-io/SNIPs) 中找到。"

#: src/ch00-00-introduction.md:145
msgid "SNIPs serve three crucial roles:"
msgstr "SNIP 有三个重要作用："

#: src/ch00-00-introduction.md:147
msgid "They are the main avenue for proposing new features or changes."
msgstr "它们是提出新功能或变更提案的主要途径。"

#: src/ch00-00-introduction.md:149
msgid "They act as a platform for technical discussions within the community."
msgstr "它们起到了社区内技术讨论的平台的作用。"

#: src/ch00-00-introduction.md:152
msgid ""
"They document the decision-making process, offering a historical view of how "
"StarkNet has evolved."
msgstr "它们记录了决策过程，为 StarkNet 的发展提供了历史视角。"

#: src/ch00-00-introduction.md:155
msgid ""
"Because SNIPs are stored as text files in a [version-controlled repository]"
"(https://github.com/starknet-io/SNIPs), you can easily track changes and "
"understand the history of proposals."
msgstr ""
"由于 SNIP 以文本文件的形式存储在[版本控制仓库](https://github.com/starknet-io/"
"SNIPs)中，因此您可以轻松地跟踪更改并了解提案的历史。"

#: src/ch00-00-introduction.md:159
msgid ""
"For those who are building on Starknet, SNIPs aren’t just suggestions—they’re "
"a roadmap. It’s beneficial for implementers to keep a list of the SNIPs "
"they’ve executed. This transparency helps users gauge the state of a "
"particular implementation or software library."
msgstr ""
"对于在 Starknet 上进行开发的人员来说，SNIP 不仅仅是提案，更是路线图。对于实际"
"的提案实现者来说，保存一份他们已经实现了的 SNIP 的清单是非常有益的。这种透明性"
"有助于用户衡量特定的实现或软件库的状况。"

#: src/ch00-00-introduction.md:164
msgid "Learning Resources"
msgstr "学习资源"

#: src/ch00-00-introduction.md:166
msgid "For deeper insights into Starknet and Cairo:"
msgstr "更深入地了解Starknet和Cairo："

#: src/ch00-00-introduction.md:168
msgid "[The Starknet Book](https://book.starknet.io): For mastering Starknet"
msgstr "[Starknet之书](https://book.starknet.io)：用以掌握Starknet"

#: src/ch00-00-introduction.md:171
msgid "[The Cairo Book](https://cairo-book.github.io/): For mastering Cairo"
msgstr "[Cairo之书](https://cairo-book.github.io/)：用以掌握Cairo"

#: src/ch00-00-introduction.md:173
msgid ""
"[Starklings](https://github.com/shramee/starklings-cairo1): Practical "
"tutorials and examples"
msgstr ""
"[Starklings](https://github.com/shramee/starklings-cairo1)：实用教程和示例"

#: src/ch00-00-introduction.md:176 src/ch02-08-starknet-react.md:361
#: src/ch03-00-architecture.md:251 src/ch03-02-sequencers.md:216
#: src/ch03-03-provers.md:243 src/ch04-00-account-abstraction.md:242
msgid "Conclusion"
msgstr "结论"

#: src/ch00-00-introduction.md:178
msgid ""
"In decentralized technology, Starknet offers a solution to challenges that "
"previous systems encountered. It's based on established _protocols_ and "
"_registries_, following the initial concepts introduced by figures such as "
"Satoshi. Through a specific mathematical method, Starknet seeks a balance "
"between scalability and consensus. As this technology progresses, Starknet "
"adheres to principles of inclusivity, neutrality, and user empowerment. It's "
"poised for continuous adaptation and improvement in the field."
msgstr ""
"在去中心化技术中，Starknet为解决以往系统遇到的难题提供了解决方案。它基于既定"
"的 _协议_ 和 _登记机构_ ，沿袭了中本聪等人提出的最初概念。通过特定的数学方法，"
"Starknet寻求可扩展性和共识之间的平衡。随着技术的进步，Starknet坚持包容性、中立"
"性和用户授权的原则。它将在该领域不断适应和改进。"

#: src/ch01-00-getting-started.md:3
msgid ""
"Starknet is a scalable Layer-2 solution on Ethereum. This guide will walk you "
"through the process of deploying and interacting with your first Starknet "
"smart contract using the Cairo programming language, a language tailored for "
"creating validity proofs and that Starknet uses. For seasoned developers "
"looking to understand the core concepts and get hands-on experience, this "
"guide offers step-by-step instructions and essential details."
msgstr ""
"Starknet 是以太坊上可扩展的第 2 层解决方案。本指南将指导你使用 Cairo 编程语言"
"部署你的第一个 Starknet 智能合约并与之交互，Cairo 是专为创建有效性证明而定制的"
"语言，Starknet 也使用这种语言。对于希望了解核心概念并获得实践经验的经验丰富的"
"开发人员来说，本指南提供了分步指导和基本细节。"

#: src/ch01-00-getting-started.md:5
msgid ""
"We will use the Starknet Remix Plugin to compile, deploy and interact with "
"our smart contract. It is a great tool to get started with Starknet "
"development."
msgstr ""
"我们将使用 Starknet Remix Plugin 来编译、部署和交互我们的智能合约。它是入门 "
"Starknet 开发的绝佳工具。"

#: src/ch01-00-getting-started.md:7
msgid "Visit [The Remix Project](https://remix.ethereum.org/)."
msgstr "请访问 [The Remix Project](https://remix.ethereum.org/)。"

#: src/ch01-00-getting-started.md:8
msgid "Navigate to the ‘Plugins’ section in the bottom left corner."
msgstr "点击左下角的`Plugins`区域。"

#: src/ch01-00-getting-started.md:9
msgid "Enable the “Starknet” plugin."
msgstr "启用 “Starknet” 插件。"

#: src/ch01-00-getting-started.md:13
msgid "Activate the Starknet Plugin"
msgstr "激活Starknet插件"

#: src/ch01-00-getting-started.md:15
msgid ""
"After enabling, the Starknet logo appears on the left sidebar. Click it to "
"interact with opened Cairo files."
msgstr ""
"启用后，Starknet 徽标会出现在左侧边栏。点击它即可与打开的Cairo文件进行交互。"

#: src/ch01-00-getting-started.md:17
msgid "Introduction to Starknet Smart Contracts"
msgstr "Starknet智能合约简介"

#: src/ch01-00-getting-started.md:19
msgid ""
"The script below is a simple `Ownable` contract pattern written in Cairo for "
"Starknet. It features:"
msgstr ""
"下面的脚本是用Cairo语言为Starknet编写的一个简单的 `Ownable` 合约模式。它的特点"
"是："

#: src/ch01-00-getting-started.md:21
msgid "An ownership system."
msgstr "一个所有权系统。"

#: src/ch01-00-getting-started.md:22
msgid "A method to transfer ownership."
msgstr "转让所有权的方法。"

#: src/ch01-00-getting-started.md:23
msgid "A method to check the current owner."
msgstr "检查当前所有者的方法。"

#: src/ch01-00-getting-started.md:24
msgid "An event notification for ownership changes."
msgstr "所有权变更事件通知。"

#: src/ch01-00-getting-started.md:91
msgid "Components Breakdown"
msgstr "组件细分"

#: src/ch01-00-getting-started.md:93
msgid ""
"The following is a brief description of the components in the contract. We "
"will get into more details when we get deeper into Cairo so feel free to skip "
"this section for now if you are not familiar with smart contract development."
msgstr ""
"下面将简要介绍合约中的组件。我们将在深入了解Cairo后介绍更多细节，所以如果你不"
"熟悉智能合约开发，可以暂时跳过这一部分。"

#: src/ch01-00-getting-started.md:95
msgid "**Dependencies and Interface**:"
msgstr "**依赖关系和接口**："

#: src/ch01-00-getting-started.md:96
msgid "**`starknet::ContractAddress`**: Represents a Starknet contract address."
msgstr "**`starknet::ContractAddress`**：代表Starknet合约地址。"

#: src/ch01-00-getting-started.md:97
msgid ""
"**`OwnableTrait`**: Specifies functions for transferring and getting "
"ownership."
msgstr "**`OwnableTrait`**：指定转移和获取所有权的函数。"

#: src/ch01-00-getting-started.md:98
msgid "**Events**:"
msgstr "**事件**:"

#: src/ch01-00-getting-started.md:99
msgid ""
"**`OwnershipTransferred1`**: Indicates ownership change with previous and new "
"owner details."
msgstr ""
"**`OwnershipTransferred1`**：表示所有权变更，包括前所有者和新所有者的详细信"
"息。"

#: src/ch01-00-getting-started.md:100
msgid "**Storage**:"
msgstr "**存储**:"

#: src/ch01-00-getting-started.md:101
msgid ""
"**`Storage`**: Holds the contract's state with the current owner's address."
msgstr "**`Storage`**:保存带有当前所有者地址的合约状态。"

#: src/ch01-00-getting-started.md:102
msgid "**Constructor**:"
msgstr "**构造函数**："

#: src/ch01-00-getting-started.md:103
msgid "Initializes the contract with a starting owner."
msgstr "用最初的所有者来初始化合约。"

#: src/ch01-00-getting-started.md:104
msgid "**External Functions**:"
msgstr "**外部函数**："

#: src/ch01-00-getting-started.md:105
msgid ""
"Functions for transferring ownership and retrieving the current owner's "
"details."
msgstr "转移所有权和检索当前所有者详细信息的功能。"

#: src/ch01-00-getting-started.md:106
msgid "**Private Methods**:"
msgstr "**私有方法**："

#: src/ch01-00-getting-started.md:107
msgid "**`only_owner`**: Validates if the caller is the current owner."
msgstr "**`only_owner`**：验证调用者是否为当前所有者。"

#: src/ch01-00-getting-started.md:109
msgid "Compilation Process"
msgstr "编译过程"

#: src/ch01-00-getting-started.md:111
msgid "To compile using Remix:"
msgstr "我们将使用 Remix 进行编译："

#: src/ch01-00-getting-started.md:113
msgid "**File Creation**"
msgstr "**文件创建**"

#: src/ch01-00-getting-started.md:115
msgid "Navigate to the \"File Explorer\" tab in Remix."
msgstr "导航至 Remix 中的\"File Explorer\" 选项卡。"

#: src/ch01-00-getting-started.md:116
msgid "Create a new file named `Ownable.cairo` and input the previous code."
msgstr "创建名为 `Ownable.cairo` 的新文件，并输入之前的代码。"

#: src/ch01-00-getting-started.md:118
msgid "**Compilation**"
msgstr "**编译**"

#: src/ch01-00-getting-started.md:120
msgid "Choose the `Ownable.cairo` file."
msgstr "选择 `Ownable.cairo`文件。"

#: src/ch01-00-getting-started.md:121
msgid "In the \"Starknet\" tab, select \"Compile Ownable.cairo\"."
msgstr "在 \"Starknet\" 选项卡中，选择 \"Compile Ownable.cairo\"。"

#: src/ch01-00-getting-started.md:122
msgid ""
"Post-compilation, an \"artifacts\" folder emerges containing the compiled "
"contract in two distinct formats: Sierra (JSON file) and CASM. For Starknet "
"deployment, Remix will use the Sierra file. Do not worry about this process "
"for now; we will cover it in detail in a later chapter. For now, Remix will "
"handle the compilation and deployment for us."
msgstr ""
"编译后，会出现一个 \"artifacts\" 文件夹，其中包含两种不同格式的被编译合约："
"Sierra（JSON 文件）和 CASM。对于Starknet部署，Remix 将使用 Sierra 文件。现在不"
"用担心这个过程，我们将在后面的章节中详细介绍。现在，Remix 将为我们处理编译和部"
"署工作。"

#: src/ch01-00-getting-started.md:126
msgid "Artifacts folder after compilation"
msgstr "编译后的工件文件夹"

#: src/ch01-00-getting-started.md:128
msgid "Deployment on the Development Network"
msgstr "在开发网络上部署"

#: src/ch01-00-getting-started.md:130
msgid ""
"To set your smart contract in motion, an initial owner must be defined. The "
"Constructor function needs this information."
msgstr "要启动智能合约，必须定义初始所有者。构造函数需要这些信息。"

#: src/ch01-00-getting-started.md:132
msgid ""
"Here's a step-by-step guide to deploying your smart contract on the "
"development network:"
msgstr "以下是在开发网络上部署智能合约的分步指南："

#: src/ch01-00-getting-started.md:134
msgid "**Select the Appropriate Network**"
msgstr "**选择合适的网络**"

#: src/ch01-00-getting-started.md:136
msgid "Go to the Environment selection tab."
msgstr "转到环境选择(Environment selection )选项卡。"

#: src/ch01-00-getting-started.md:137
msgid ""
"Choose \"Remote Devnet\" for deploying your inaugural contract on a "
"development network."
msgstr "选择 \"Remote Devnet\"，在开发网络上部署您的合约。"

#: src/ch01-00-getting-started.md:139
msgid "**Choose a Devnet Account**"
msgstr "**选择 Devnet 帐户**"

#: src/ch01-00-getting-started.md:141
msgid ""
"Under \"Devnet account selection\", a list of accounts specific to the chosen "
"devnet is presented."
msgstr ""
"在 \"Devnet account selection\"下，将显示可供挑选的 Devnet 的专用帐户列表。"

#: src/ch01-00-getting-started.md:142
msgid "Pick any account and copy its address."
msgstr "任选一个账户，复制其地址。"

#: src/ch01-00-getting-started.md:144
msgid "**Initiating Deployment**"
msgstr "**启动部署**"

#: src/ch01-00-getting-started.md:146 src/ch01-00-getting-started.md:176
msgid "Navigate to the \"Starknet\" tab."
msgstr "导航至 \"Starknet \"选项卡。"

#: src/ch01-00-getting-started.md:147
msgid "Input the copied address into the `init_owner` variable."
msgstr "将复制的地址输入到 `init_owner` 变量中。"

#: src/ch01-00-getting-started.md:148
msgid "Click on \"Deploy ownable.cairo\"."
msgstr "点击 \"Deploy ownable.cairo\"。"

#: src/ch01-00-getting-started.md:150
msgid ""
"Post-deployment, Remix's terminal will send various logs. These logs provide "
"crucial details, including:"
msgstr ""
"部署后，Remix 的终端将发送各种日志。这些日志提供了重要的详细信息，包括："

#: src/ch01-00-getting-started.md:152
msgid ""
"`transaction_hash`: The unique hash of the transaction. This hash can be used "
"to track the transaction's status."
msgstr "`transaction_hash`：交易的唯一哈希值。该哈希值可用于跟踪事务的状态。"

#: src/ch01-00-getting-started.md:153
msgid ""
"`contract_address`: The address of the deployed contract. Use this address to "
"interact with your contract."
msgstr "`contract_address`：已部署合约的地址。使用此地址与您的合约进行交互。"

#: src/ch01-00-getting-started.md:154
msgid "`calldata`: Contains the `init_owner` address fed to the constructor."
msgstr "`calldata`：包含提供给构造函数的 `init_owner` 地址。"

#: src/ch01-00-getting-started.md:156
msgid ""
"```bash\n"
"{\n"
"  \"transaction_hash\": "
"\"0x275e6d2caf9bc98b47ba09fa9034668c6697160a74de89c4655e2a70be84247\",\n"
"  \"contract_address\": "
"\"0x5eb239955ad4c4333b8ab83406a3cf5970554b60a0d8e78a531df18c59a0db9\",\n"
"    ...\n"
"  \"calldata\": [\n"
"    \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
"  ],\n"
"    ...\n"
"}\n"
"```"
msgstr ""
"```bash\n"
"{\n"
"  \"transaction_hash\": "
"\"0x275e6d2caf9bc98b47ba09fa9034668c6697160a74de89c4655e2a70be84247\",\n"
"  \"contract_address\": "
"\"0x5eb239955ad4c4333b8ab83406a3cf5970554b60a0d8e78a531df18c59a0db9\",\n"
"    ...\n"
"  \"calldata\": [\n"
"    \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
"  ],\n"
"    ...\n"
"}\n"
"```"

#: src/ch01-00-getting-started.md:168
msgid ""
"By following the above process, you successfully deploy your smart contract "
"on the development network."
msgstr "按照上述流程操作，您就成功地在开发网络上部署了智能合约。"

#: src/ch01-00-getting-started.md:170
msgid "Interaction with the Contract"
msgstr "与合约的交互"

#: src/ch01-00-getting-started.md:172
msgid ""
"With the contract now active on the development network, interaction becomes "
"possible. Here's a guide to effectively interact with your contract on "
"Starknet:"
msgstr ""
"现在，合约已在开发网络上激活，与之交互成为可能。以下是在Starknet与合约有效交互"
"的指南："

#: src/ch01-00-getting-started.md:174
msgid "**Initiating Interaction**"
msgstr "**启动互动**"

#: src/ch01-00-getting-started.md:177
msgid "Select the \"Interact\" option."
msgstr "选择\"Interact\"选项。"

#: src/ch01-00-getting-started.md:179
msgid "**Calling the `get_owner` Function**"
msgstr "**调用 `get_owner` 函数**"

#: src/ch01-00-getting-started.md:181
msgid ""
"Choose the `get_owner` function. Since this function doesn't require "
"arguments, the calldata field remains blank. (This is a read function, hence "
"calling it is termed as a \"call\".)"
msgstr ""
"选择 `get_owner` 函数。由于该函数不需要参数，因此 calldata 字段保持空白。(这是"
"一个只读函数，因此调用它会被称为 \"call\"）。"

#: src/ch01-00-getting-started.md:182
msgid ""
"Press the \"get_owner\" button. Your terminal will display the result, "
"revealing the owner's address provided during the contract's deployment as "
"calldata for the constructor:"
msgstr ""
"按下 \"get_owner\"（获取所有者）按钮。您的终端将显示结果，揭示出合约部署时作为"
"构造函数 calldata 提供的所有者地址："

#: src/ch01-00-getting-started.md:184
msgid ""
"```bash\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"
msgstr ""
"```bash\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x4d9c8282b5633eeb1aab56393690d76f71e32f1b7be1bea03eb03e059245a28\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"

#: src/ch01-00-getting-started.md:196
msgid ""
"This call currently doesn't spend gas because the function does not change "
"the state of the contract."
msgstr "由于该函数不会改变合约的状态，因此该调用目前不会消耗gas。"

#: src/ch01-00-getting-started.md:198
msgid "**Invoking the `transfer_ownership` Function**"
msgstr "**调用 `transfer_ownership` 功能**"

#: src/ch01-00-getting-started.md:200
msgid ""
"Now, for the **`transfer_ownership`** function, which requires the new "
"owner's address as input."
msgstr "现在，**`transfer_ownership`** 函数需要输入新所有者的地址。"

#: src/ch01-00-getting-started.md:201
msgid ""
"Enter this address into the calldata field. (For this, use any address from "
"the \"Devnet account selection\" listed in the Environment tab.)"
msgstr ""
"在 calldata 字段中输入该地址。(这里你可以在使用 Environment 选项卡中列出的 "
"\"Devnet account selection\" 中的任意地址）。"

#: src/ch01-00-getting-started.md:202
msgid ""
"Click the \"transfer_ownership\" button. The terminal then showcases the "
"transaction hash indicating the contract's state alteration. Since we are "
"altering the contract's state this typo of interaction is called an "
"\"invoke\" and needs to be signed by the account that is calling the function."
msgstr ""
"点击 \"transfer_ownership\"（转让所有权）按钮。然后终端就会显示交易哈希值，表"
"明合约的状态发生了改变。由于我们正在改变合约的状态，因此这种不同的交互方法称"
"为 \"invoke\"（唤起），需要由调用函数的账户签名。"

#: src/ch01-00-getting-started.md:204
msgid ""
"For these transactions, the terminal logs will exhibit a \"status\" variable, "
"indicating the transaction's fate. If the status reads \"ACCEPTED_ON_L2\", "
"the Sequencer has accepted the transaction, pending block inclusion. However, "
"a \"REJECTED\" status signifies the Sequencer's disapproval, and the "
"transaction won't feature in the upcoming block. More often than not, this "
"transaction gains acceptance, leading to a contract state modification. On "
"calling the **`get_owner`** function again we get this:"
msgstr ""
"对于这些交易，终端日志将显示一个\"status\"  变量，表明该交易的命运。如果状态显"
"示为 \"ACCEPTED_ON_L2\"，则表示排序器已接受该交易，等待区块加入。但是，如果状"
"态为 \"REJECTED\"，则表示排序器不同意，该交易将不会出现在即将到来的区块中。通"
"常情况下，该交易会被接受，从而导致合约状态修改。再次调用**`get_owner`**函数"
"时，我们会得到以下结果："

#: src/ch01-00-getting-started.md:206
msgid ""
"```bash\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x20884fd341e11a00b9d31600c332f126f5c3f9ffd2aa93cb43dee9f90176d4f\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"
msgstr ""
"```bash\n"
"{\n"
"  \"response\": {\n"
"    \"result\": [\n"
"      \"0x20884fd341e11a00b9d31600c332f126f5c3f9ffd2aa93cb43dee9f90176d4f\"\n"
"    ]\n"
"  },\n"
"  \"contract\": \"ownable.cairo\",\n"
"  \"function\": \"get_owner\"\n"
"}\n"
"```"

#: src/ch01-00-getting-started.md:218
msgid ""
"You've now adeptly compiled, deployed, and interacted with your inaugural "
"Starknet smart contract. Well done!"
msgstr ""
"您现在已经能熟练地编译、部署并与您的首份Starknet智能合约进行了交互。干得不错！"

#: src/ch01-00-getting-started.md:220
msgid "Deploying on Starknet Testnet"
msgstr "在Starknet测试网上部署"

#: src/ch01-00-getting-started.md:222
msgid ""
"After testing your smart contract on a development network, it's time to "
"deploy it to the Starknet Testnet. Starknet Testnet is a public platform "
"available for everyone, ideal for testing smart contracts and collaborating "
"with fellow developers."
msgstr ""
"在开发网络上测试完智能合约后，就可以将其部署到Starknet测试网络上了。Starknet "
"测试网络是一个面向所有人的公共平台，是测试智能合约和与其他开发者合作的理想平"
"台。"

#: src/ch01-00-getting-started.md:224
msgid "First you need to create a Starknet account."
msgstr "首先，您需要创建一个Starknet账户。"

#: src/ch01-00-getting-started.md:226 src/ch02-02-compile-deploy-interact.md:62
msgid "Smart Wallet Setup"
msgstr "智能钱包设置"

#: src/ch01-00-getting-started.md:228
msgid ""
"Before deploying your smart contract to Starknet, you must handle the "
"transaction cost. While deploying to the Starknet Goerli Testnet is free, a "
"smart wallet account is essential. You can set up a smart wallet using either:"
msgstr ""
"在将智能合约部署到Starknet之前，您必须处理好交易成本相关的问题。虽然部署到"
"Starknet Goerli Testnet 是免费的，但智能钱包账户却是必不可少的。你可以使用以下"
"两种方法之一建立智能钱包："

#: src/ch01-00-getting-started.md:230
msgid "[Braavos](https://braavos.app/)"
msgstr "[Braavos](https://braavos.app/)"

#: src/ch01-00-getting-started.md:231
msgid "[Argent](https://www.argent.xyz/argent-x/)"
msgstr "[Argent](https://www.argent.xyz/argent-x/)"

#: src/ch01-00-getting-started.md:233
msgid ""
"Both are reliable Starknet wallets offering enhanced security and "
"accessibility features thanks to the possibilities that the Cairo VM brings, "
"such as Account Abstraction (keep reading the Book for more on this)."
msgstr ""
"两者都是可靠的Starknet钱包，由于Cairo虚拟机带来了更多可能性，如账户抽象（请继"
"续阅读本书了解更多相关信息），因此Starknet上的钱包比起EOA钱包具有更强的安全性"
"和可访问性。"

#: src/ch01-00-getting-started.md:235
msgid "Install the recommended chrome/brave extension for your chosen wallet."
msgstr "为所选钱包安装推荐的 chrome/brave 扩展插件。"

#: src/ch01-00-getting-started.md:236
msgid "Follow your wallet provider's instructions to deploy your account."
msgstr "按照钱包提供商的指示部署您的账户。"

#: src/ch01-00-getting-started.md:237
msgid ""
"Use the [Starknet Faucet](https://faucet.goerli.starknet.io/) to fund your "
"account."
msgstr "使用 [Starknet Faucet](https://faucet.goerli.starknet.io/) 为账户充值。"

#: src/ch01-00-getting-started.md:238
msgid "Deploy the account to the network. This usually takes around 10 seconds."
msgstr "将账户部署到测试网上。这通常需要 10 秒钟左右。"

#: src/ch01-00-getting-started.md:240
msgid ""
"Once set up, you're ready to deploy your smart contracts to the Starknet "
"Testnet."
msgstr "当设置完成后，您就可以将智能合约部署到Starknet测试网络了。"

#: src/ch01-00-getting-started.md:242
msgid "Deployment and Interaction"
msgstr "部署和交互"

#: src/ch01-00-getting-started.md:244
msgid "Follow the previous deployment steps."
msgstr "按照之前的部署步骤进行。"

#: src/ch01-00-getting-started.md:245
msgid "In the 'Environment selection' tab, choose 'Wallet Selection'."
msgstr "在  'Environment selection' 选项卡中，选择 'Wallet Selection'。"

#: src/ch01-00-getting-started.md:246
msgid ""
"Select your Starknet account and continue with deploying and interacting with "
"your contract."
msgstr "选择您的 Starknet 账户，继续进行部署并与您的合约交互。"

#: src/ch01-00-getting-started.md:248
msgid ""
"You can monitor transaction hashes and addresses using any Starknet block "
"explorers like:"
msgstr "您可以使用任何 Starknet 区块浏览器监控交易哈希值和地址："

#: src/ch01-00-getting-started.md:250
msgid "[Starkscan](https://testnet.starkscan.co/)"
msgstr "[Starkscan](https://testnet.starkscan.co/)"

#: src/ch01-00-getting-started.md:251
msgid "[Voyager](https://goerli.voyager.online/)"
msgstr "[Voyager](https://goerli.voyager.online/)"

#: src/ch01-00-getting-started.md:253
msgid ""
"These tools provide a visual representation of transactions and contract "
"state alterations. Notably, when you alter the contract ownership using the "
"`transfer_ownership` function, the event emitted by the contract appears in "
"the block explorer. It's an effective method to track contract events."
msgstr ""
"这些工具提供了事务和合约状态更改的可视化表示。值得注意的是，当你使用 "
"`transfer_ownership` 函数更改合约所有权时，合约发出的事件就会出现在区块浏览器"
"中。这是跟踪合约事件的有效方法。"

#: src/ch01-00-getting-started.md:255
msgid "Your Next Steps"
msgstr "接下来的步骤"

#: src/ch01-00-getting-started.md:257
msgid "Decide your direction from the following choices:"
msgstr "你可以从以下选项中决定你的学习方向："

#: src/ch01-00-getting-started.md:259
msgid ""
"**Deepen Your Starknet Knowledge**: For an extensive grasp of Starknet's "
"inner workings and potential use cases, delve into Chapter 3 of the Starknet "
"Book. This chapter details Starknet’s architectural nuances. Then go ahead "
"from there."
msgstr ""
"**深化您的Starknet知识**：要广泛了解 Starknet 的内部运作原理和潜在用例，请深入"
"阅读Starknet Book第 3 章。本章详细介绍了Starknet架构的细微差别。然后继续学习。"

#: src/ch01-00-getting-started.md:261
msgid ""
"**Dive into Cairo**: If you're more attuned to coding and wish to craft "
"Starknet contracts, then Cairo is essential. It stands as Starknet's core "
"contract language. Begin with Chapters 1-6 of the [Cairo Book](https://book."
"cairo-lang.org/title-page.html), ranging from basics in _Getting Started_ to "
"more advanced aspects such as _Enums and Pattern Matching_. Conclude by "
"navigating to the [Starknet Smart Contracts chapter](https://book.cairo-lang."
"org/ch99-00-starknet-smart-contracts.html), ensuring you have a well-rounded "
"understanding."
msgstr ""
"**深入Cairo**：如果您更擅长编码，并希望撰写Starknet合约，那么Cairo是必不可少"
"的。它是Starknet的核心合约语言。从[Cairo Book](https://book.cairo-lang.org/zh-"
"cn/title-page.html)的第1-6章开始，范围包括从 _入门_ 章节的基础知识到 _枚举和模"
"式匹配_ 等更高级的内容。最后，请浏览[Starknet 智能合约章节](https://book."
"cairo-lang.org/ch99-00-starknet-smart-contracts.html)，来确保您有一个全面的了"
"解。"

#: src/ch02-00-starknet-tooling.md:1
msgid "Starknet Tooling"
msgstr "Starknet工具"

#: src/ch02-00-starknet-tooling.md:3 src/ch02-03-scarb.md:3
msgid ""
"To make the most of this chapter, a basic grasp of the Cairo programming "
"language is advised. We suggest reading chapters 1-6 of the [Cairo Book]"
"(https://book.cairo-lang.org/title-page.html), covering topics from _Getting "
"Started_ to _Enums and Pattern Matching._ Follow this by studying the "
"[Starknet Smart Contracts chapter](https://book.cairo-lang.org/ch99-00-"
"starknet-smart-contracts.html) in the same book. With this background, you’ll "
"be well-equipped to understand the examples presented here."
msgstr ""
"要充分理解本章内容，建议先掌握Cairo编程语言的基本知识。我们建议阅读[Cairo "
"Book](https://book.cairo-lang.org/zh-cn/title-page.html)的第1-6章，内容包括从 "
"_入门_ 章节的基础知识到 _枚举和模式匹配_。之后，再学习同一本书中的[Starknet 智"
"能合约](https://book.cairo-lang.org/ch99-00-starknet-smart-contracts.htmll)。"
"有了这些背景知识，你就能很好地理解这里介绍的示例了。"

#: src/ch02-00-starknet-tooling.md:12
msgid ""
"Today, Starknet provides all essential tools for building decentralized "
"applications (dApps), compatible with multiple languages like JavaScript, "
"Rust, and Python. You can use the Starknet SDK for development. Front-end "
"developers can use Starknet.js with React, while Rust and Python work well "
"for back-end tasks."
msgstr ""
"如今，Starknet提供了构建去中心化应用程序（dApps）的所有基本工具，兼容 "
"JavaScript、Rust 和 Python 等多种语言。您可以使用 Starknet SDK 进行开发。前端"
"开发人员可以使用带有 React 的 Starknet.js，而 Rust 和 Python 则可以很好地完成"
"后端任务。"

#: src/ch02-00-starknet-tooling.md:18
msgid ""
"We welcome contributors to enhance existing tools or develop new solutions."
msgstr "我们欢迎贡献者改进现有工具或开发新的解决方案。"

#: src/ch02-00-starknet-tooling.md:21
msgid "In this chapter, you’ll explore:"
msgstr "在本章中，您将了解："

#: src/ch02-00-starknet-tooling.md:23
msgid "Frameworks: Build using Protostar or Hardhat"
msgstr "框架：使用 Protostar 或 Hardhat 进行项目构建"

#: src/ch02-00-starknet-tooling.md:25
msgid ""
"SDKs: Discover multi-language support through Starknet.js, Starknet-rs, "
"Starknet_py, and Caigo"
msgstr ""
"SDKs：通过 Starknet.js、Starknet-rs、Starknet_py 和 Caigo 发现多语言支持"

#: src/ch02-00-starknet-tooling.md:28
msgid "Front-end Development: Use Starknet.js and React"
msgstr "前端开发：使用 Starknet.js 和 React"

#: src/ch02-00-starknet-tooling.md:30
msgid "Testing: Understand testing methods with Protostar and the Devnet"
msgstr "测试：使用 Protostar 和 Devnet 来了解如何测试"

#: src/ch02-00-starknet-tooling.md:32
msgid ""
"By chapter’s end, you’ll have a complete grasp of Starknet’s toolset, "
"enabling efficient dApp development."
msgstr "本章结束时，您将能完全掌握 Starknet 的工具集，实现高效的 dApp 开发。"

#: src/ch02-00-starknet-tooling.md:35
msgid ""
"Here’s a quick rundown of the tools that could be used for Starknet "
"development and that we’ll cover in this chapter:"
msgstr "以下是可用于Starknet开发的工具的简要介绍，我们将在本章介绍这些工具："

#: src/ch02-00-starknet-tooling.md:38
msgid "Scarb: A package manager that compiles your contracts."
msgstr "Scarb：编译合约的软件包管理器。"

#: src/ch02-00-starknet-tooling.md:40
msgid "Starkli: A CLI tool for interacting with the Starknet network."
msgstr "Starkli：与Starknet互动的 CLI 工具。"

#: src/ch02-00-starknet-tooling.md:42
msgid "Foundry: For contract testing."
msgstr "Foundry：用于合约测试。"

#: src/ch02-00-starknet-tooling.md:44
msgid "Katana: Creates a local test node."
msgstr "Katana：创建本地测试节点。"

#: src/ch02-00-starknet-tooling.md:46
msgid ""
"SDKs: starknet.js, Starknet.py, and starknet.rs interface with Starknet using "
"common programming languages."
msgstr ""
"SDKs: 包括starknet.js、Starknet.py 和 starknet.rs， 普通编程语言与 Starknet 接"
"口。"

#: src/ch02-00-starknet-tooling.md:49
msgid "Starknet-react: Builds front-end apps using React."
msgstr "Starknet-react：使用 React 构建前端应用程序。"

#: src/ch02-01-basic-installation.md:1 src/ch02-03-scarb.md:34
#: src/ch02-07-starknet-js.md:13
msgid "Installation"
msgstr "安装"

#: src/ch02-01-basic-installation.md:3
msgid ""
"This chapter walks you through setting up your Starknet development tools."
msgstr "本章将指导您安装与设置 Starknet 开发工具。"

#: src/ch02-01-basic-installation.md:6
msgid "Essential tools to install:"
msgstr "安装必备工具："

#: src/ch02-01-basic-installation.md:8
msgid ""
"[Starkli](https://github.com/xJonathanLEI/starkli) - A CLI tool for "
"interacting with Starknet. More tools are discussed in Chapter 2."
msgstr ""
"[Starkli](https://github.com/xJonathanLEI/starkli) - 与Starknet交互的 CLI 工"
"具。第 2 章将讨论更多工具。"

#: src/ch02-01-basic-installation.md:11
msgid ""
"[Scarb](https://github.com/software-mansion/scarb) - Cairo’s package manager "
"that compiles code to Sierra, a mid-level language between Cairo and CASM."
msgstr ""
"[Scarb](https://github.com/software-mansion/scarb) - Cairo 的软件包管理器，可"
"将代码编译为 Sierra--这是一种一种介于 Cairo 和 CASM 之间的中级语言。"

#: src/ch02-01-basic-installation.md:15
msgid ""
"For support or queries, visit our [GitHub Issues](https://github.com/starknet-"
"edu/starknetbook/issues) or contact espejelomar on Telegram."
msgstr ""
"有关支持或问题，请访问我们的 [GitHub Issues](https://github.com/starknet-edu/"
"starknetbook/issues) 或在 Telegram 上联系 espejelomar。"

#: src/ch02-01-basic-installation.md:19
msgid "Starkli Installation"
msgstr "Starkli 安装"

#: src/ch02-01-basic-installation.md:21
msgid ""
"Easily install Starkli using Starkliup, an installer invoked through the "
"command line."
msgstr "使用通过命令行调用安装程序 Starkliup，可轻松安装 Starkli。"

#: src/ch02-01-basic-installation.md:24
msgid ""
"```bash\n"
"curl https://get.starkli.sh | sh\n"
"starkliup\n"
"```"
msgstr ""
"```bash\n"
"curl https://get.starkli.sh | sh\n"
"starkliup\n"
"```"

#: src/ch02-01-basic-installation.md:29
msgid "Restart your terminal and confirm installation:"
msgstr "重新启动终端并确认安装成功："

#: src/ch02-01-basic-installation.md:35
msgid "To upgrade Starkli, simply repeat the steps."
msgstr "要升级 Starkli，只需重复上述步骤即可。"

#: src/ch02-01-basic-installation.md:37
msgid "Scarb Package Manager Installation"
msgstr "安装 Scarb 软件包管理器"

#: src/ch02-01-basic-installation.md:39
msgid ""
"We will get deeper into Scarb later in this chapter. For now, we will go over "
"the installation process."
msgstr "本章稍后我们将深入介绍 Scarb。现在，我们将介绍安装过程。"

#: src/ch02-01-basic-installation.md:41
msgid "For macOS and Linux:"
msgstr "对于 macOS 和 Linux上："

#: src/ch02-01-basic-installation.md:43
msgid ""
"```bash\n"
"    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
"install.sh | sh\n"
"```"
msgstr ""
"```bash\n"
"    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
"install.sh | sh\n"
"```"

#: src/ch02-01-basic-installation.md:47
msgid ""
"For Windows, follow manual setup in the [Scarb documentation](https://docs."
"swmansion.com/scarb/download.html#windows)."
msgstr ""
"对于 Windows，请按照 [Scarb 文档](https://docs.swmansion.com/scarb/download."
"html#windows)中的手册进行设置。"

#: src/ch02-01-basic-installation.md:50
msgid "Restart the terminal and run:"
msgstr "重启终端并运行："

#: src/ch02-01-basic-installation.md:56
msgid "To upgrade Scarb, rerun the installation command."
msgstr "要升级 Scarb，请重新运行安装命令。"

#: src/ch02-01-basic-installation.md:58
msgid "You are now set to code in Cairo and deploy to Starknet."
msgstr ""
"现在您已经将用Cairo编写代码并将其部署到Starknet所需的开发环境设置完成了。"

#: src/ch02-02-compile-deploy-interact.md:1
msgid "Hello, World!"
msgstr "世界，你好！"

#: src/ch02-02-compile-deploy-interact.md:3
msgid ""
"In this chapter, you’ll learn how to compile, deploy, and interact with a "
"Starknet smart contract written in Cairo."
msgstr ""
"在本章中，你将学习如何编译、部署用 Cairo 编写的 Starknet 智能合约，并与之交"
"互。"

#: src/ch02-02-compile-deploy-interact.md:6
msgid ""
"First, confirm that the following commands work on your system. If they "
"don’t, refer to Basic Installation in this chapter."
msgstr ""
"首先，请确认以下命令在您的系统上是否有效。如果不行，请参阅本章的基本安装。"

#: src/ch02-02-compile-deploy-interact.md:14
msgid "Find the compiler versions supported"
msgstr "查找支持的编译器版本"

#: src/ch02-02-compile-deploy-interact.md:16
msgid ""
"We have to make sure that our Starkli compiler version match Scarb compiler "
"version"
msgstr "我们必须确保我们的 Starkli 编译器版本与 Scarb 编译器版本一致"

#: src/ch02-02-compile-deploy-interact.md:19
msgid "To find the compiler versions supported by Starkli, execute:"
msgstr "要查找 Starkli 支持的编译器版本，请执行："

#: src/ch02-02-compile-deploy-interact.md:25
msgid ""
"You’ll see a list of possible compiler versions under the `--compiler-"
"version` flag."
msgstr "你会在 `--compiler-version` 标志下看到可使用的编译器版本列表。"

#: src/ch02-02-compile-deploy-interact.md:35
msgid ""
"Note that the Scarb compiler version might not align with Starkli’s supported "
"versions. To check Scarb’s version:"
msgstr ""
"请注意，Scarb 编译器版本可能与 Starkli 支持的版本不一致。请检查 Scarb 的版本："

#: src/ch02-02-compile-deploy-interact.md:42
msgid "You’ll see a list that contains scarb, cairo and sierra version."
msgstr "你会看到一个包含 scarb、cairo 和 sierra 版本的列表。"

#: src/ch02-02-compile-deploy-interact.md:50
msgid ""
"If there’s a mismatch, it is suggested that you install the version of Scarb "
"that uses the compiler version that Starkli supports. You can find previous "
"releases on [Scarb](https://github.com/software-mansion/scarb/releases)'s "
"GitHub repo."
msgstr ""
"如果出现不匹配的情况，建议安装使用 Starkli 支持的编译器版本的 Scarb。你可以在 "
"[Scarb](https://github.com/software-mansion/scarb/releases) 的 GitHub 仓库中找"
"到以前的版本。"

#: src/ch02-02-compile-deploy-interact.md:56
msgid "To install a specific version, such as `0.6.1`, run:"
msgstr "要安装特定版本，如 `0.6.1`，请运行："

#: src/ch02-02-compile-deploy-interact.md:58
msgid ""
"```bash\n"
"    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
"install.sh | sh -s -- -v 0.6.1\n"
"```"
msgstr ""
"```bash\n"
"    curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/"
"install.sh | sh -s -- -v 0.6.1\n"
"```"

#: src/ch02-02-compile-deploy-interact.md:64
msgid ""
"A smart wallet comprises a Signer and an Account Descriptor. The Signer is a "
"smart contract with a private key for signing transactions, while the Account "
"Descriptor is a JSON file detailing the wallet’s address and public key."
msgstr ""
"智能钱包由签名者和账户描述符组成。签名者是一个智能合约，带有用于签署交易的私"
"钥，而账户描述符是一个 JSON 文件，详细说明了钱包的地址和公钥。"

#: src/ch02-02-compile-deploy-interact.md:69
msgid "Use Braavos or Argent X browser extensions to create your smart wallet."
msgstr "使用 Braavos 或 Argent X 浏览器扩展创建智能钱包。"

#: src/ch02-02-compile-deploy-interact.md:72
msgid ""
"Follow the provided instructions for your chosen wallet (Argent or Braavos)."
msgstr "按照所选钱包(Argent 或 Braavos)提供的说明进行操作。"

#: src/ch02-02-compile-deploy-interact.md:75
msgid ""
"Fund your wallet with ETH. Use [Starknet Goerli Faucet](https://faucet.goerli."
"starknet.io/) as needed."
msgstr ""
"为钱包充值 ETH 。你可以使用 [Starknet Goerli Faucet](https://faucet.goerli."
"starknet.io/)。"

#: src/ch02-02-compile-deploy-interact.md:78
msgid "Now you’re ready to interact with Starknet smart contracts."
msgstr "现在，您已经准备好与Starknet智能合约互动了。"

#: src/ch02-02-compile-deploy-interact.md:80
msgid "Creating a Signer"
msgstr "创建签名者"

#: src/ch02-02-compile-deploy-interact.md:82
msgid ""
"The Signer is an essential smart contract capable of signing transactions in "
"Starknet. You’ll need the private key from your smart wallet to create one, "
"from which the public key can be derived."
msgstr ""
"签名者是一种重要的智能合约，能够在Starknet中签署交易。你需要从你的智能钱包中获"
"取私钥来创建签名者，并从中获取公钥。"

#: src/ch02-02-compile-deploy-interact.md:86
msgid ""
"Starkli enables secure storage of your private key through a keystore file. "
"This encrypted file can be accessed using a password and is generally stored "
"in the default Starkli directory."
msgstr ""
"Starkli 可以通过密钥存储文件安全存储你的私人密钥。该加密文件可以通过密码访问，"
"通常存储在默认的 Starkli 目录中。"

#: src/ch02-02-compile-deploy-interact.md:90
msgid "First, create the default directory:"
msgstr "首先，创建默认目录："

#: src/ch02-02-compile-deploy-interact.md:96
msgid ""
"Then generate the keystore file. The signer command contains subcommands for "
"creating a keystore file from a private key or completely create a new one. "
"In this tutorial, we’ll use the private key option which is the most common "
"use case. You need to provide the path to the keystore file you want to "
"create. You can give any name to the keystore file, you will likely have "
"several wallets. In this tutorial, we will use the name `my_keystore_ 1.json`."
msgstr ""
"然后生成密钥存储文件。签名者命令包含从私钥创建密钥存储文件或完全创建一个新文件"
"的子命令。在本教程中，我们将使用最常用的私钥选项。你需要提供要创建的密钥存储文"
"件的路径。你可以给密钥存储文件起任何名字，因为你可能会有多个钱包。在本教程中，"
"我们将使用 `my_keystore_ 1.json`。"

#: src/ch02-02-compile-deploy-interact.md:110
msgid ""
"In the private key prompt, paste the private key of your smart wallet. In the "
"password prompt, enter a password of your choice. You will need this password "
"to sign transactions using Starkli."
msgstr ""
"在私钥提示符下，粘贴智能钱包的私钥。在密码提示中，输入你选择的密码。使用 "
"Starkli 签署交易时需要这个密码。"

#: src/ch02-02-compile-deploy-interact.md:114
msgid ""
"Export the private key from your Braavos or Argent wallet. For Argent X, you "
"can find it in the \"Settings\" section → Select your Account → \"Export "
"Private Key\". For Braavos, you can find it in the \"Settings\" section → "
"\"Privacy and Security\" → \"Export Private Key\"."
msgstr ""
"从您的Braavos或 Argent 钱包中导出私钥。对于 Argent X，可以在 \"设置\"→\"选择账"
"户\"→\"导出私钥 \"中找到。对于Braavos，您可以在 \"设置\"→\"隐私和安全\"→\"导出"
"私人密钥 \"中找到它。"

#: src/ch02-02-compile-deploy-interact.md:119
msgid ""
"While knowing the private key of a smart wallet is necessary to sign "
"transactions, it’s not sufficient. We also need to inform Starkli about the "
"signing mechanism employed by our smart wallet created by Braavos or Argent "
"X. Does it use an elliptic curve? If yes, which one? This is the reason why "
"we need an account descriptor file."
msgstr ""
"虽然签署交易的必要条件是需要知晓智能钱包的私钥，但这还不够。我们还需要告知"
"Starkli，由 Braavos 或 Argent X 创建的智能钱包所采用的签名机制。如果是，是哪一"
"种？这就是我们需要账户描述文件的原因。"

#: src/ch02-02-compile-deploy-interact.md:125
msgid "\\[OPTIONAL\\] The Architecture of the Starknet Signer"
msgstr "\\[OPTIONAL\\] Starknet签名者的架构"

#: src/ch02-02-compile-deploy-interact.md:127
msgid ""
"The Starknet Signer plays an instrumental role in securing your transactions. "
"Let’s demystify what goes on under the hood."
msgstr ""
"Starknet签名者在确保交易安全方面发挥着重要作用。让我们来揭开它的神秘面纱。"

#: src/ch02-02-compile-deploy-interact.md:130
msgid "Key Components:"
msgstr "主要组成部分："

#: src/ch02-02-compile-deploy-interact.md:132
msgid ""
"**Private Key**: A 256-bit/32-byte/64-character (ignoring the _0x_ prefix) "
"hexadecimal key that is the cornerstone of your wallet’s security."
msgstr ""
"**私人密钥**：256 位/32 字节/64 个字符（忽略 _0x_ 前缀）的十六进制密钥，是钱包"
"安全的基石。"

#: src/ch02-02-compile-deploy-interact.md:136
msgid ""
"**Public Key**: Derived from the private key, it’s also a 256-bit/32-byte/64-"
"character hexadecimal key."
msgstr "**公钥**：源自私人密钥，也是 256 位/32 字节/64 个字符的十六进制密钥。"

#: src/ch02-02-compile-deploy-interact.md:139
msgid ""
"**Smart Wallet Address**: Unlike Ethereum, the address here is influenced by "
"the public key, class hash, and a salt. **[Learn more in Starknet "
"Documentation](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/contract-address/)**."
msgstr ""
"**智能钱包地址**：与以太坊不同，这里的地址受公钥、class hash和salt的影响。 "
"**[在Starknet文档中了解更多](https://docs.starknet.io/documentation/"
"architecture_and_concepts/Smart_Contracts/contract-address/)**。"

#: src/ch02-02-compile-deploy-interact.md:144
msgid "To view the details of the previously created keystore file:"
msgstr "查看先前创建的密钥存储文件的详细信息："

#: src/ch02-02-compile-deploy-interact.md:150
msgid "Anatomy of the `keystore.json` File:"
msgstr "`keystore.json` 文件的剖析："

#: src/ch02-02-compile-deploy-interact.md:152
msgid ""
"```json\n"
"{\n"
"  \"crypto\": {\n"
"    \"cipher\": \"aes-128-ctr\",\n"
"    \"cipherparams\": {\n"
"      \"iv\": \"dba5f9a67456b121f3f486aa18e24db7\"\n"
"    },\n"
"    \"ciphertext\": "
"\"b3cda3df39563e3dd61064149d6ed8c9ab5f07fbcd6347625e081fb695ddf36c\",\n"
"    \"kdf\": \"scrypt\",\n"
"    \"kdfparams\": {\n"
"      \"dklen\": 32,\n"
"      \"n\": 8192,\n"
"      \"p\": 1,\n"
"      \"r\": 8,\n"
"      \"salt\": "
"\"6dd5b06b1077ba25a7bf511510ea0c608424c6657dd3ab51b93029244537dffb\"\n"
"    },\n"
"    \"mac\": "
"\"55e1616d9ddd052864a1ae4207824baac58a6c88798bf28585167a5986585ce6\"\n"
"  },\n"
"  \"id\": \"afbb9007-8f61-4e62-bf14-e491c30fd09a\",\n"
"  \"version\": 3\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"crypto\": {\n"
"    \"cipher\": \"aes-128-ctr\",\n"
"    \"cipherparams\": {\n"
"      \"iv\": \"dba5f9a67456b121f3f486aa18e24db7\"\n"
"    },\n"
"    \"ciphertext\": "
"\"b3cda3df39563e3dd61064149d6ed8c9ab5f07fbcd6347625e081fb695ddf36c\",\n"
"    \"kdf\": \"scrypt\",\n"
"    \"kdfparams\": {\n"
"      \"dklen\": 32,\n"
"      \"n\": 8192,\n"
"      \"p\": 1,\n"
"      \"r\": 8,\n"
"      \"salt\": "
"\"6dd5b06b1077ba25a7bf511510ea0c608424c6657dd3ab51b93029244537dffb\"\n"
"    },\n"
"    \"mac\": "
"\"55e1616d9ddd052864a1ae4207824baac58a6c88798bf28585167a5986585ce6\"\n"
"  },\n"
"  \"id\": \"afbb9007-8f61-4e62-bf14-e491c30fd09a\",\n"
"  \"version\": 3\n"
"}\n"
"```"

#: src/ch02-02-compile-deploy-interact.md:175
msgid "**`version`**: The version of the smart wallet implementation."
msgstr "**`version`**: 智能钱包所实现的版本。"

#: src/ch02-02-compile-deploy-interact.md:177
msgid "**`id`**: A randomly generated identification string."
msgstr "**`id`**: 随机生成的标识字符串。"

#: src/ch02-02-compile-deploy-interact.md:179
msgid "**`crypto`**: Houses all encryption details."
msgstr "**`crypto`**: 包含所有加密细节。"

#: src/ch02-02-compile-deploy-interact.md:181
msgid "Inside **`crypto`**:"
msgstr "在 **`crypto`** 内部:"

#: src/ch02-02-compile-deploy-interact.md:183
msgid ""
"**`cipher`**: Specifies the encryption algorithm used, which in this case is "
"AES-128-CTR."
msgstr "**`cipher`**: 指定所使用的加密算法，本例中为 AES-128-CTR。"

#: src/ch02-02-compile-deploy-interact.md:186
msgid ""
"**AES (Advanced Encryption Standard)**: A globally accepted encryption "
"standard."
msgstr "**AES（高级加密标准）**: 全球公认的加密标准。"

#: src/ch02-02-compile-deploy-interact.md:189
msgid "**128**: Refers to the key size in bits, making it a 128-bit key."
msgstr "**128**: 指密钥大小（按bit计算），即 128 位密钥。"

#: src/ch02-02-compile-deploy-interact.md:192
msgid "**CTR (Counter Mode)**: A specific mode of operation for the AES cipher."
msgstr "**CTR (Counter Mode)**: AES 密码的一种特定运行模式。"

#: src/ch02-02-compile-deploy-interact.md:195
msgid ""
"**`cipherparams`**: Contains an Initialization Vector (IV), which ensures "
"that encrypting the same plaintext with the same key will produce different "
"ciphertexts."
msgstr ""
"**`cipherparams`**: 包含初始化向量 (IV)，可确保使用相同密钥加密相同明文时产生"
"不同的密文。"

#: src/ch02-02-compile-deploy-interact.md:199
msgid ""
"**`iv` (Initialization Vector)**: A 16-byte hex string that serves as a "
"random and unique starting point for each encryption operation."
msgstr ""
"**`iv`（初始化向量）**: 一个 16 字节十六进制字符串，作为每次加密操作的随机唯一"
"起点。"

#: src/ch02-02-compile-deploy-interact.md:203
msgid ""
"**`ciphertext`**: This is the private key after encryption, securely stored "
"so that only the correct password can reveal it."
msgstr ""
"**`ciphertext`**: 这是加密后的私人密钥，安全存储，只有正确的密码才能读取。"

#: src/ch02-02-compile-deploy-interact.md:206
msgid ""
"**`kdf` and `kdfparams`**: KDF stands for Key Derivation Function. This adds "
"a layer of security by requiring computational work, making brute-force "
"attacks harder."
msgstr ""
"**`kdf`和`kdfparams`**: KDF 代表密钥衍生函数。这需要计算工作，从而增加了一层安"
"全性，使暴力破解更加困难。"

#: src/ch02-02-compile-deploy-interact.md:210
msgid ""
"**`dklen`**: The length (in bytes) of the derived key. Typically 32 bytes."
msgstr "**`dklen`**：派生密钥的长度（字节）。通常为 32 字节。"

#: src/ch02-02-compile-deploy-interact.md:213
msgid ""
"**`n`**: A cost factor representing CPU/memory usage. A higher value means "
"more computational work is needed, thus increasing security."
msgstr ""
"**`n`**: 代表 CPU/内存使用量的消耗系数。数值越大，意味着需要更多的计算工作，从"
"而提高安全性。"

#: src/ch02-02-compile-deploy-interact.md:217
msgid "**`p`**: Parallelization factor, affecting the computational complexity."
msgstr "**`p`**: 并行化系数，影响计算复杂度。"

#: src/ch02-02-compile-deploy-interact.md:220
msgid ""
"**`r`**: Block size for the hash function, again affecting computational "
"requirements."
msgstr "**`r`**: 散列函数的块大小，同样会影响计算要求。"

#: src/ch02-02-compile-deploy-interact.md:223
msgid ""
"**`salt`**: A random value that is combined with the password to deter "
"dictionary attacks."
msgstr "**`salt`**: 与密码相结合的随机值，用于阻止字典攻击。"

#: src/ch02-02-compile-deploy-interact.md:226
msgid ""
"**`mac` (Message Authentication Code)**: This is a cryptographic code that "
"ensures the integrity of the message (the encrypted private key in this "
"case). It is generated using a hash of both the ciphertext and a portion of "
"the derived key."
msgstr ""
"**`mac`（信息验证码）**: 这是一种加密代码，可确保信息（此处为加密私人密钥）的"
"完整性。它使用密文和部分派生密钥的哈希值生成。"

#: src/ch02-02-compile-deploy-interact.md:231
msgid "Creating an Account Descriptor"
msgstr "创建账户描述符"

#: src/ch02-02-compile-deploy-interact.md:233
msgid ""
"An Account Descriptor informs Starkli about your smart wallet’s unique "
"features, such as its signing mechanism. You can generate this descriptor "
"using Starkli’s `fetch` subcommand under the `account` command. The `fetch` "
"subcommand takes your on-chain wallet address as input and generates the "
"account descriptor file. The account descriptor file is a JSON file that "
"contains the details of your smart wallet."
msgstr ""
"账户描述符（Account Descriptor）会告知 Starkli 你的智能钱包的独特功能，比如它"
"的签名机制。你可以使用 Starkli `account` 命令下的 `fetch` 子命令来生成这个描述"
"符。`fetch`子命令将你的链上钱包地址作为输入，并生成账户描述文件。账户描述文件"
"是一个 JSON 文件，包含了你的智能钱包的详细信息。"

#: src/ch02-02-compile-deploy-interact.md:244
msgid ""
"After running the command, you’ll see a message like the one below. We’re "
"using a Braavos wallet as an example, but the steps are the same for an "
"Argent wallet."
msgstr ""
"运行该命令后，你会看到如下信息。我们这里以Braavos钱包为例，但Argent钱包上步骤"
"是一样的。"

#: src/ch02-02-compile-deploy-interact.md:254
msgid "To see the details of your Account Descriptor, run:"
msgstr "要查看账户描述符的详细信息，请运行："

#: src/ch02-02-compile-deploy-interact.md:260
msgid "Here’s what a typical descriptor might look like:"
msgstr "下面是一个典型的描述符："

#: src/ch02-02-compile-deploy-interact.md:262
msgid ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"braavos\",\n"
"    \"version\": 1,\n"
"    \"implementation\": "
"\"0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062\",\n"
"    \"multisig\": {\n"
"      \"status\": \"off\"\n"
"    },\n"
"    \"signers\": [\n"
"      {\n"
"        \"type\": \"stark\",\n"
"        \"public_key\": "
"\"0x49759ed6197d0d385a96f9d8e7af350848b07777e901f5570b3dc2d9744a25e\"\n"
"      }\n"
"    ]\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"deployed\",\n"
"    \"class_hash\": "
"\"0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e\",\n"
"    \"address\": "
"\"0x6dcb489c1a93069f469746ef35312d6a3b9e56ccad7f21f0b69eb799d6d2821\"\n"
"  }\n"
"}\n"
"```"
msgstr ""
"```json\n"
"{\n"
"  \"version\": 1,\n"
"  \"variant\": {\n"
"    \"type\": \"braavos\",\n"
"    \"version\": 1,\n"
"    \"implementation\": "
"\"0x5dec330eebf36c8672b60db4a718d44762d3ae6d1333e553197acb47ee5a062\",\n"
"    \"multisig\": {\n"
"      \"status\": \"off\"\n"
"    },\n"
"    \"signers\": [\n"
"      {\n"
"        \"type\": \"stark\",\n"
"        \"public_key\": "
"\"0x49759ed6197d0d385a96f9d8e7af350848b07777e901f5570b3dc2d9744a25e\"\n"
"      }\n"
"    ]\n"
"  },\n"
"  \"deployment\": {\n"
"    \"status\": \"deployed\",\n"
"    \"class_hash\": "
"\"0x3131fa018d520a037686ce3efddeab8f28895662f019ca3ca18a626650f7d1e\",\n"
"    \"address\": "
"\"0x6dcb489c1a93069f469746ef35312d6a3b9e56ccad7f21f0b69eb799d6d2821\"\n"
"  }\n"
"}\n"
"```"

#: src/ch02-02-compile-deploy-interact.md:287
msgid "Note: The structure will differ if you use an Argent wallet."
msgstr "注意：如果使用 Argent 钱包，结构会有所不同。"

#: src/ch02-02-compile-deploy-interact.md:289
msgid "Setting up Environment Variables"
msgstr "设置环境变量"

#: src/ch02-02-compile-deploy-interact.md:291
msgid ""
"To simplify Starkli commands, you can set environment variables. Two key "
"variables are crucial: one for the Signer’s keystore file location and "
"another for the Account Descriptor file."
msgstr ""
"为了简化 Starkli 命令，可以设置环境变量。有两个关键变量至关重要：一个是签名者"
"的密钥存储文件位置，另一个是账户描述符文件。"

#: src/ch02-02-compile-deploy-interact.md:300
msgid ""
"Setting these variables makes running Starkli commands easier and more "
"efficient."
msgstr "设置这些变量可以让运行 Starkli 命令变得更简单、更高效。"

#: src/ch02-02-compile-deploy-interact.md:303
msgid "Declaring Smart Contracts in Starknet"
msgstr "在 Starknet 上声明智能合约"

#: src/ch02-02-compile-deploy-interact.md:305
msgid "Deploying a smart contract on Starknet involves two steps:"
msgstr "在 Starknet 上部署智能合约包括两个步骤："

#: src/ch02-02-compile-deploy-interact.md:307
msgid "Declare your contract’s code."
msgstr "声明您的合约代码。"

#: src/ch02-02-compile-deploy-interact.md:309
msgid "Deploy an instance of the declared code."
msgstr "部署已声明代码的实例。"

#: src/ch02-02-compile-deploy-interact.md:311
msgid ""
"To get started, navigate to the `contracts/` directory in the [first chapter]"
"(https://github.com/starknet-edu/starknetbook/tree/main/chapters/book/modules/"
"chapter_1/pages/contracts) of the Starknet Book repo. The `src/lib.cairo` "
"file contains a basic contract to practice with."
msgstr ""
"要开始学习，请导航到Starknet之书 github仓库的 [第一章](https://github.com/"
"starknet-edu/starknetbook/tree/main/chapters/book/modules/chapter_1/pages/"
"contracts) 中的 `contracts/` 目录。`src/lib.cairo` 文件包含一个基本合约，可供"
"练习。"

#: src/ch02-02-compile-deploy-interact.md:316
msgid ""
"First, compile the contract using the Scarb compiler. If you haven’t "
"installed Scarb, follow the installation guide in the [Setting up your "
"Environment](https://book.starknet.io/chapter_1/environment_setup.html) "
"section."
msgstr ""
"首先，使用 Scarb 编译器编译合约。如果尚未安装 Scarb，请按照 [设置环境]"
"(https://book.starknet.io/chapter_1/environment_setup.html) 部分的安装指南进行"
"安装。"

#: src/ch02-02-compile-deploy-interact.md:325
msgid ""
"This creates a compiled contract in `target/dev/` as \"contracts_Ownable."
"sierra.json\" (in Chapter 2 of the book we will learn more details about "
"Scarb)."
msgstr ""
"这将在 `target/dev/` 中创建一个编译好的合约，名为 \"contracts_Ownable.sierra."
"json\"（在本书第 2 章中，我们将了解有关 Scarb 的更多细节）。"

#: src/ch02-02-compile-deploy-interact.md:329
msgid ""
"With the smart contract compiled, we’re ready to declare it using Starkli. "
"Before declaring your contract, decide on an RPC provider."
msgstr ""
"编译好智能合约后，我们就可以使用 Starkli 声明它了。在声明合约之前，我们需要决"
"定使用哪个 RPC 提供商。"

#: src/ch02-02-compile-deploy-interact.md:332
msgid "Choosing an RPC Provider"
msgstr "选择 RPC 提供商"

#: src/ch02-02-compile-deploy-interact.md:334
msgid "There are three main options for RPC providers, sorted by ease of use:"
msgstr "你主要有三种RPC 提供商可供选择，按易用性排序："

#: src/ch02-02-compile-deploy-interact.md:336
msgid ""
"**Starknet Sequencer’s Gateway**: The quickest option and it’s the default "
"for Starkli for now. The sequencer gateway is deprecated and will be disabled "
"by StarkWare soon. You’re strongly recommended to use a third-party JSON-RPC "
"API provider like Infura, Alchemy, or Chainstack."
msgstr ""
"**Starknet 排序器网关*：最无需设置的选择，目前是 Starkli 的默认设置。但排序器"
"网关已经被标注为`deprecated`，StarkWare 将很快禁用它。强烈建议使用第三方 JSON-"
"RPC API 提供商，如 Infura、Alchemy 或 Chainstack。"

#: src/ch02-02-compile-deploy-interact.md:342
msgid ""
"**Infura or Alchemy**: A step up in complexity. You’ll need to set up an API "
"key and choose an endpoint. For Infura, it would look like `https://starknet-"
"goerli.infura.io/v3/<API_KEY>`. Learn more in the [Infura documentation]"
"(https://docs.infura.io/networks/starknet/how-to/choose-a-network)."
msgstr ""
"**Infura 或 Alchemy**：复杂程度更高。您需要设置一个 API 密钥并选择一个端点。对"
"于 Infura，它看起来像 `https://starknet-goerli.infura.io/v3/<API_KEY>`。更多信"
"息请参阅 [Infura 文档](https://docs.infura.io/networks/starknet/how-to/choose-"
"a-network)。"

#: src/ch02-02-compile-deploy-interact.md:348
msgid ""
"**Your Own Node**: For those who want full control. It’s the most complex but "
"offers the most freedom. Check out [Chapter 4 of the Starknet Book](https://"
"book.starknet.io/chapter_4/node.html) or [Kasar](https://www.kasar.io/) for "
"setup guides."
msgstr ""
"**您自己的节点**：适合想要完全控制的用户。它最复杂，但提供的自由度最高。请查"
"阅 [Starknet之书第四章](https://book.starknet.io/chapter_4/node.html) 或 "
"[Kasar](https://www.kasar.io/) 获取设置指南。"

#: src/ch02-02-compile-deploy-interact.md:353
msgid ""
"In this tutorial, we will use Alchemy. We can set the STARKNET_RPC "
"environment variable to make command invocations easier:"
msgstr ""
"在本教程中，我们将使用 Alchemy。我们可以设置 `STARKNET_RPC` 环境变量，使命令调"
"用更容易："

#: src/ch02-02-compile-deploy-interact.md:356
msgid ""
"```bash\n"
"    export STARKNET_RPC=\"https://starknet-goerli.g.alchemy.com/v2/"
"<API_KEY>\"\n"
"```"
msgstr ""
"```bash\n"
"    export STARKNET_RPC=\"https://starknet-goerli.g.alchemy.com/v2/"
"<API_KEY>\"\n"
"```"

#: src/ch02-02-compile-deploy-interact.md:360
msgid "Declaring Your Contract"
msgstr "声明您的合约"

#: src/ch02-02-compile-deploy-interact.md:362
msgid ""
"Run this command to declare your contract using the default Starknet "
"Sequencer’s Gateway:"
msgstr "运行此命令可使用默认的 Starknet 排序器网关声明您的合约："

#: src/ch02-02-compile-deploy-interact.md:369
msgid ""
"According to the `STARKNET_RPC` url, starkli can recognize the target "
"blockchain network, in this case \"goerli\", so it is not necessary "
"explicitly specify it."
msgstr ""
"根据 `STARKNET_RPC` url，starkli 可以识别目标区块链网络，本例中为 \"goerli\"，"
"因此无需显式指定。"

#: src/ch02-02-compile-deploy-interact.md:373
msgid ""
"Unless you’re working with custom networks where it’s infeasible for Starkli "
"to detect the right compiler version, you shouldn’t need to manually choose a "
"version with `--network` and `--compiler-version`."
msgstr ""
"除非你使用的是自定义网络，Starkli 无法检测到正确的编译器版本，否则你应该不需要"
"使用 `--network` 和 `--compiler-version` 来手动选择版本。"

#: src/ch02-02-compile-deploy-interact.md:377
msgid ""
"If you encounter an \"Error: Invalid contract class,\" it likely means your "
"Scarb’s compiler version is incompatible with Starkli. Follow the steps above "
"to align the versions. Starkli usually supports compiler versions accepted by "
"mainnet, even if Scarb’s latest version is not yet compatible."
msgstr ""
"如果遇到 `\"Error: Invalid contract class,\"`，这很可能意味着你的 Scarb 编译器"
"版本与 Starkli 不兼容。请按照上面的步骤调整版本。Starkli 通常支持主网接受的编"
"译器版本，即使 Scarb 的最新版本还不兼容。"

#: src/ch02-02-compile-deploy-interact.md:383
msgid ""
"After running the command, you’ll receive a contract class hash. This unique "
"hash serves as the identifier for your contract class within Starknet. For "
"example:"
msgstr ""
"运行该命令后，您将收到一个合约的class hash（类哈希）。这个唯一的哈希值是您的合"
"约类在Starknet中的标识符。例如:"

#: src/ch02-02-compile-deploy-interact.md:391
msgid ""
"You can think of this hash as the contract class’s _address._ Use a block "
"explorer like [StarkScan](https://testnet.starkscan.co/"
"class/0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8) to "
"verify this hash on the blockchain."
msgstr ""
"您可以将此散列值视为合约类的 _address_  使用如 [StarkScan](https://testnet."
"starkscan.co/"
"class/0x04c70a75f0246e572aa2e1e1ec4fffbe95fa196c60db8d5677a5c3a3b5b6a1a8) 之类"
"的区块浏览器在区块链上验证此hash。"

#: src/ch02-02-compile-deploy-interact.md:396
msgid ""
"If the contract class you’re attempting to declare already exists, it is ok "
"we can continue. You’ll receive a message like:"
msgstr "如果您试图声明的合约类已经存在，我们可以继续。您将收到如下信息："

#: src/ch02-02-compile-deploy-interact.md:404
msgid "Deploying Smart Contracts on Starknet"
msgstr "在Starknet部署智能合约"

#: src/ch02-02-compile-deploy-interact.md:406
msgid ""
"To deploy a smart contract, you’ll need to instantiate it on Starknet’s "
"testnet. This process involves executing a command that requires two main "
"components:"
msgstr ""
"要部署智能合约，您需要在 Starknet 的测试网上将其实例化。这个过程需要执行一个命"
"令，该命令需要两个主要组件："

#: src/ch02-02-compile-deploy-interact.md:410
msgid "The class hash of your smart contract."
msgstr "智能合约的类哈希值。"

#: src/ch02-02-compile-deploy-interact.md:412
msgid "Any constructor arguments that the contract expects."
msgstr "合约构造函数所要求的参数。"

#: src/ch02-02-compile-deploy-interact.md:414
msgid ""
"In our example, the constructor expects an _owner_ address. You can learn "
"more about constructors in \\[Chapter 12 of The Cairo Book\\](<https://book."
"cairo-lang.org/ch99-01-03-02-contract-functions.html?highlight=constructor#1-"
"constructors>)."
msgstr ""
"在我们的例子中，构造函数期望得到一个 _owner_ 地址。关于构造函数的更多信息，请"
"参阅 [Cairo之书 第12章](<https://book.cairo-lang.org/ch99-01-03-02-contract-"
"functions.html?highlight=constructor#1-constructors>)。"

#: src/ch02-02-compile-deploy-interact.md:418
msgid "The command would look like this:"
msgstr "命令如下："

#: src/ch02-02-compile-deploy-interact.md:426
msgid ""
"Here’s a specific example with an actual class hash and constructor inputs "
"(as the owner address use the address of your smart wallet so you can invoke "
"the transfer_ownership function later):"
msgstr ""
"下面是一个具体示例，其中包含一个实际类的哈希值和构造函数输入（作为所有者地址，"
"请使用智能钱包的地址，以便稍后调用 `transfer_ownership` 函数）："

#: src/ch02-02-compile-deploy-interact.md:436
msgid ""
"After executing the command and entering your password, you should see output "
"like the following:"
msgstr "执行命令并输入密码后，您应该会看到如下输出："

#: src/ch02-02-compile-deploy-interact.md:447
msgid ""
"The contract is now live on the Starknet testnet. You can verify its status "
"using a block explorer like [StarkScan](https://testnet.starkscan.co/"
"contract/0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012). "
"On the \"Read/Write Contract\" tab, you’ll see the contract’s external "
"functions."
msgstr ""
"合约现已存在于Starknet测试网上。你可以使用像 [StarkScan](https://testnet."
"starkscan.co/"
"contract/0x02a83c32d4b417d3c22f665acbc10e9a1062033b9ab5b2c3358952541bc6c012) "
"这样的区块浏览器来验证它的状态。在 \"Read/Write Contract\" 选项卡上，你可以看"
"到合约的外部功能。"

#: src/ch02-02-compile-deploy-interact.md:453
msgid "Interacting with the Starknet Contract"
msgstr "与Starknet合约交互"

#: src/ch02-02-compile-deploy-interact.md:455
msgid ""
"Starkli enables interaction with smart contracts via two primary methods: "
"`call` for read-only functions and `invoke` for write functions that modify "
"the state."
msgstr ""
"Starkli 通过两种主要方法实现与智能合约的交互：`call`用于只读函数，\"invoke "
"\"用于修改状态的写入函数。"

#: src/ch02-02-compile-deploy-interact.md:459
msgid "Calling a Read Function"
msgstr "调用只读函数"

#: src/ch02-02-compile-deploy-interact.md:461
msgid ""
"The `call` command enables you to query a smart contract function without "
"sending a transaction. For instance, to find out who the current owner of the "
"contract is, you can use the `get_owner` function, which requires no "
"arguments."
msgstr ""
"`call`命令使你可以在不发送交易的情况下查询智能合约函数。例如，要想知道谁是合约"
"的当前所有者，可以使用`get_owner`函数，该函数不需要参数。"

#: src/ch02-02-compile-deploy-interact.md:472
msgid ""
"Replace `<CONTRACT_ADDRESS>` with the address of your contract. The command "
"will return the owner’s address, which was initially set during the "
"contract’s deployment:"
msgstr ""
"请将 `<CONTRACT_ADDRESS>` 替换为您的合约地址。该命令将返回所有者的地址，该地址"
"最初是在部署合约时设置的："

#: src/ch02-02-compile-deploy-interact.md:476
msgid ""
"```bash\n"
"    [\n"
"        \"0x02cdab749380950e7a7c0deff5ea8edd716feb3a2952add4e5659655077b8510\"\n"
"    ]\n"
"```"
msgstr ""
"```bash\n"
"    [\n"
"        \"0x02cdab749380950e7a7c0deff5ea8edd716feb3a2952add4e5659655077b8510\"\n"
"    ]\n"
"```"

#: src/ch02-02-compile-deploy-interact.md:482
msgid "Invoking a Write Function"
msgstr "调用写入函数"

#: src/ch02-02-compile-deploy-interact.md:484
msgid ""
"You can modify the contract’s state using the `invoke` command. For example, "
"let’s transfer the contract’s ownership with the `transfer_ownership` "
"function."
msgstr ""
"您可以使用 `invoke` 命令修改合约的状态。例如，让我们使用 `transfer_ownership` "
"函数转移合约的所有权。"

#: src/ch02-02-compile-deploy-interact.md:495
msgid ""
"Replace `<CONTRACT_ADDRESS>` with the address of the contract and "
"`<NEW_OWNER_ADDRESS>` with the address you want to transfer ownership to. If "
"the smart wallet you’re using isn’t the contract’s owner, an error will "
"appear. Note that the initial owner was set when deploying the contract:"
msgstr ""
"将 `<CONTRACT_ADDRESS>` 替换为合约地址，将 `<NEW_OWNER_ADDRESS>`替换为你想转移"
"所有权的地址。如果您使用的智能钱包不是合约的所有者，则会出现错误。请注意，初始"
"所有者是在部署合约时设置的："

#: src/ch02-02-compile-deploy-interact.md:505
msgid ""
"The failure reason is encoded as a felt. o decode it, use the starkli’s "
"`parse-cairo-string` command."
msgstr ""
"失败的原因被编码成了`felt`类型。要解码失败原因，请使用 starkli 的 `parse-"
"cairo-string` 命令。"

#: src/ch02-02-compile-deploy-interact.md:512
msgid ""
"For example, if you see `0x43616c6c6572206973206e6f7420746865206f776e6572`, "
"decoding it will yield \"Caller is not the owner.\""
msgstr ""
"例如，如果您看到 \"0x43616c6c6572206973206e6f7420746865206f776e6572\"，它解码"
"结果将是 \"Caller is not the owner.\"。"

#: src/ch02-02-compile-deploy-interact.md:516
msgid ""
"After a successful transaction on L2, use a block explorer like StarkScan or "
"Voyager to confirm the transaction status using the hash provided by the "
"`invoke` command."
msgstr ""
"在 L2 上成功进行交易后，使用 StarkScan 或 Voyager 等区块资源管理器，使用 "
"`invoke`命令提供的哈希值确认交易状态。"

#: src/ch02-02-compile-deploy-interact.md:520
msgid ""
"To verify that the ownership has successfully transferred, you can call the "
"`get_owner` function again:"
msgstr "要验证所有权是否已成功转移，可以再次调用 `get_owner` 函数："

#: src/ch02-02-compile-deploy-interact.md:529
msgid ""
"If the function returns the new owner’s address, the transfer was successful."
msgstr "如果函数返回新所有者的地址，则说明转账成功。"

#: src/ch02-02-compile-deploy-interact.md:532
msgid ""
"Congratulations! You’ve successfully deployed and interacted with a Starknet "
"contract."
msgstr "恭喜您！您已成功部署Starknet合约并与之交互。"

#: src/ch02-03-scarb.md:12
msgid ""
"Scarb is Cairo’s package manager designed for both Cairo and Starknet "
"projects. It handles dependencies, compiles projects, and integrates with "
"tools like Foundry. It is built by the same team that created Foundry for "
"Starknet."
msgstr ""
"Scarb 是 Cairo 的软件包管理器，专为 Cairo 和 Starknet 项目设计。它处理依赖关"
"系、编译项目，并与 Foundry 等工具集成。它由为 Starknet 创建 Foundry 的同一团队"
"打造。"

#: src/ch02-03-scarb.md:17
msgid "Scarb Workflow"
msgstr "Scarb 工作流程"

#: src/ch02-03-scarb.md:19
msgid "Follow these steps to develop a Starknet contract using Scarb:"
msgstr "请按照以下步骤使用 Scarb 来开发Starknet合约："

#: src/ch02-03-scarb.md:21
msgid ""
"**Initialize:** Use `scarb new` to set up a new project, generating a `Scarb."
"toml` file and initial `src/lib.cairo`."
msgstr ""
"**初始化：** 使用 `scarb new` 建立一个新项目，生成一个 `Scarb.toml` 文件和初始"
"的 `src/lib.cairo` 文件。"

#: src/ch02-03-scarb.md:24
msgid "**Code:** Add your Cairo code in the `src` directory."
msgstr "**代码：** 在`src`目录下添加你的Cairo代码。"

#: src/ch02-03-scarb.md:26
msgid "**Dependencies:** Add external libraries using `scarb add`."
msgstr "**依赖关系：** 使用 `scarb add` 添加外部库。"

#: src/ch02-03-scarb.md:28
msgid ""
"**Compile:** Execute `scarb build` to convert your contract into Sierra code."
msgstr "**编译：** 执行 `scarb build` 将合约转换为 Sierra 代码。"

#: src/ch02-03-scarb.md:31
msgid ""
"Scarb simplifies your development workflow, making it efficient and "
"streamlined."
msgstr "Scarb 简化了您的开发工作流程，使其高效、精简。"

#: src/ch02-03-scarb.md:36
msgid ""
"Scarb is cross-platform, supporting macOS, Linux, and Windows. For "
"installation, refer to the [Chapter 1 setup guide](https://book.starknet.io/"
"chapter_1/environment_setup.html#the_scarb_package_manager_installation)."
msgstr ""
"Scarb 可跨平台运行，支持 macOS、Linux 和 Windows。有关安装，请参阅 [第1章的安"
"装指南](https://book.starknet.io/chapter_1/environment_setup."
"html#the_scarb_package_manager_installation)。"

#: src/ch02-03-scarb.md:40
msgid "Cairo Project Structure"
msgstr "Cairo项目结构"

#: src/ch02-03-scarb.md:42
msgid "Next, we’ll dive into the key components that make up a Cairo project."
msgstr "接下来，我们将深入探讨Cairo项目的关键组成部分。"

#: src/ch02-03-scarb.md:44
msgid "Cairo Packages"
msgstr "Cairo 包"

#: src/ch02-03-scarb.md:46
msgid ""
"Cairo packages, also referred to as \"crates\" in some contexts, are the "
"building blocks of a Cairo project. Each package must follow several rules:"
msgstr ""
"Cairo 包在某些情况下也被称为 \"crate\"，是 Cairo 项目的组成部分。每个包都必须"
"遵循几条规则："

#: src/ch02-03-scarb.md:50
msgid ""
"A package must include a `Scarb.toml` file, which is Scarb’s manifest file. "
"It contains the dependencies for your package."
msgstr ""
"包必须包含一个 `Scarb.toml` 文件，它是 Scarb 的清单文件。它包含软件包的依赖"
"项。"

#: src/ch02-03-scarb.md:53
msgid ""
"A package must include a `src/lib.cairo` file, which is the root of the "
"package tree. It allows you to define functions and declare used modules."
msgstr ""
"包必须包含一个 `src/lib.cairo` 文件，它是包的树形结构的根。它允许你定义函数和"
"声明使用的模块。"

#: src/ch02-03-scarb.md:57
msgid ""
"Package structures might look like the following case where we have a package "
"named `my_package`, which includes a `src` directory with the `lib.cairo` "
"file inside, a `snips` directory which in itself a package we can use, and a "
"`Scarb.toml` file in the top-level directory."
msgstr ""
"软件包结构可能如下所示：我们有一个名为 `my_package`的包，其中包括一个包含`lib."
"cairo` 文件的 `src` 目录、一个本身就是我们可以使用的软件包的 `snips`目录和一个"
"位于顶层目录的`Scarb.toml`文件。"

#: src/ch02-03-scarb.md:73
msgid "Within the `Scarb.toml` file, you might have:"
msgstr "在 `Scarb.toml` 文件中，可能有："

#: src/ch02-03-scarb.md:75
msgid ""
"```\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.0.1\"\n"
"snips = { path = \"snips\" }\n"
"```"
msgstr ""
"```\n"
"[package]\n"
"name = \"my_package\"\n"
"version = \"0.1.0\"\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.0.1\"\n"
"snips = { path = \"snips\" }\n"
"```"

#: src/ch02-03-scarb.md:83
msgid ""
"Here starknet and snips are the dependencies of the package. The `starknet` "
"dependency is hosted on the Scarb registry (we do not need to download it), "
"while the `snips` dependency is located in the `snips` directory."
msgstr ""
"这里的 `starknet`  和 `snips` 是软件包的依赖项。`starknet` 依赖项位于 Scarb 注"
"册表中（我们无需下载），而 `snips`依赖项位于 `snips`目录中。"

#: src/ch02-03-scarb.md:88
msgid "Setting Up a Project with Scarb"
msgstr "使用 Scarb 设置项目"

#: src/ch02-03-scarb.md:90
msgid ""
"To create a new project using Scarb, navigate to your desired project "
"directory and execute the following command:"
msgstr "要使用 Scarb 创建新项目，请导航到所需的项目目录并执行以下命令："

#: src/ch02-03-scarb.md:95
msgid ""
"This command will create a new project directory named `hello_scarb`, "
"including a `Scarb.toml` file, a `src` directory with a `lib.cairo` file "
"inside, and initialize a new Git repository with a `.gitignore` file."
msgstr ""
"该命令将创建一个名为 `hello_scarb` 的新项目目录，包括一个 `Scarb.toml` 文件、"
"一个包含 `lib.cairo` 文件的 `src` 目录，并使用 `.gitignore` 文件初始化一个新"
"的 Git 仓库。"

#: src/ch02-03-scarb.md:104
msgid ""
"Upon opening `Scarb.toml` in a text editor, you should see something similar "
"to the code snippet below:"
msgstr ""
"在文本编辑器中打开`Scarb.toml`后，您应该会看到与下面代码片段类似的内容："

#: src/ch02-03-scarb.md:107
msgid ""
"```\n"
"[package]\n"
"name = \"hello_scarb\"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/"
"docs/reference/manifest.html\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"
msgstr ""
"```\n"
"[package]\n"
"name = \"hello_scarb\"\n"
"version = \"0.1.0\"\n"
"\n"
"# See more keys and their definitions at https://docs.swmansion.com/scarb/"
"docs/reference/manifest.html\n"
"[dependencies]\n"
"# foo = { path = \"vendor/foo\" }\n"
"```"

#: src/ch02-03-scarb.md:115
msgid "Building a Scarb Project"
msgstr "编译Scarb项目"

#: src/ch02-03-scarb.md:117
msgid "Clear all content in `src/lib.cairo` and replace with the following:"
msgstr "删除 `src/lib.cairo` 中的所有内容，并替换为以下内容："

#: src/ch02-03-scarb.md:119
msgid ""
"```\n"
"// src/lib.cairo\n"
"mod hello_scarb;\n"
"```"
msgstr ""
"```\n"
"// src/lib.cairo\n"
"mod hello_scarb;\n"
"```"

#: src/ch02-03-scarb.md:122
msgid ""
"Next, create a new file titled `src/hello_scarb.cairo` and add the following:"
msgstr "接下来，创建一个名为 `src/hello_scarb.cairo` 的新文件，并添加以下内容："

#: src/ch02-03-scarb.md:125
msgid ""
"```\n"
"// src/hello_scarb.cairo\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, Scarb!'.print();\n"
"}\n"
"```"
msgstr ""
"```\n"
"// src/hello_scarb.cairo\n"
"use debug::PrintTrait;\n"
"fn main() {\n"
"    'Hello, Scarb!'.print();\n"
"}\n"
"```"

#: src/ch02-03-scarb.md:131
msgid ""
"In this instance, the `lib.cairo` file contains a module declaration "
"referencing _hello_scarb_, which includes the _hello_scarb.cairo_ file’s "
"implementation. For more on modules, imports, and the `lib.cairo` file, "
"please refer to the subchapter on [imports in Chapter 2](https://book."
"starknet.io/chapter_2/imports.html)."
msgstr ""
"在这个例子中，`lib.cairo`文件包含了引用 _hello_scarb_ 的模块声明，其中包含了 "
"_hello_scarb.cairo_ 文件的实现。有关模块、导入和`lib.cairo`文件的更多信息，请"
"参阅[第2章里的 导入 ](https://book.starknet.io/chapter_2/imports.html)。"

#: src/ch02-03-scarb.md:137
msgid ""
"Scarb mandates that your source files be located within the `src` directory."
msgstr "Scarb 要求代码源文件应位于 `src` 目录中。"

#: src/ch02-03-scarb.md:140
msgid ""
"To build (compile) your project from your `hello_scarb` directory, use the "
"following command:"
msgstr "要在 `hello_scarb` 目录中构建（编译）项目，请使用以下命令："

#: src/ch02-03-scarb.md:145
msgid ""
"This command compiles your project and produces the Sierra code in the "
"`target/dev/hello_scarb.sierra` file. Sierra serves as an intermediate layer "
"between high-level Cairo and compilation targets such as Cairo Assembly "
"(CASM). To understand more about Sierra, check out this [article](https://"
"medium.com/nethermind-eth/under-the-hood-of-cairo-1-0-exploring-"
"sierra-7f32808421f5/)."
msgstr ""
"该命令可编译项目并在 `target/dev/hello_scarb.sierra` 文件中生成 Sierra 代码。"
"Sierra 是高级 Cairo 和编译目标（如 Cairo Assembly (CASM)）之间的中间层。要了解"
"有关 Sierra 的更多信息，请参阅此 [文章](https://medium.com/nethermind-eth/"
"under-the-hood-of-cairo-1-0-exploring-sierra-7f32808421f5/)。"

#: src/ch02-03-scarb.md:151
msgid ""
"To remove the build artifacts and delete the target directory, use the `scarb "
"clean` command."
msgstr "要移除编译成果并删除目标目录，请使用 `scarb clean` 命令。"

#: src/ch02-03-scarb.md:154
msgid "Adding Dependencies"
msgstr "添加依赖项"

#: src/ch02-03-scarb.md:156
msgid ""
"Scarb facilitates the seamless management of dependencies for your Cairo "
"packages. Here are two methods to add dependencies to your project:"
msgstr ""
"Scarb 可以帮助你无缝管理 Cairo 软件包的依赖关系。以下是为项目添加依赖包的两种"
"方法："

#: src/ch02-03-scarb.md:159
msgid "Edit Scarb.toml File"
msgstr "编辑 Scarb.toml 文件"

#: src/ch02-03-scarb.md:161
msgid ""
"Open the Scarb.toml file in your project directory and locate the "
"`[dependencies]` section. If it doesn’t exist, add it. To include a "
"dependency hosted on a Git repository, use the following format:"
msgstr ""
"打开项目目录中的 Scarb.toml 文件，找到`[dependencies]`部分。如果不存在，请添"
"加。要包含托管在 Git 仓库中的依赖项，请使用以下格式："

#: src/ch02-03-scarb.md:165
msgid ""
"```\n"
"[dependencies]\n"
"alexandria_math = { git = \"https://github.com/keep-starknet-strange/"
"alexandria.git\" }\n"
"```"
msgstr ""
"```\n"
"[dependencies]\n"
"alexandria_math = { git = \"https://github.com/keep-starknet-strange/"
"alexandria.git\" }\n"
"```"

#: src/ch02-03-scarb.md:168
msgid ""
"For consistency, it’s recommended to pin Git dependencies to specific "
"commits. This can be done by adding the `rev` field with the commit hash:"
msgstr ""
"为保持一致性，建议将 Git 依赖项固定在某个特定提交上。这可以通过添加带有提交哈"
"希值的 `rev` 字段来实现："

#: src/ch02-03-scarb.md:172
msgid ""
"```\n"
"[dependencies]\n"
"alexandria_math = { git = \"https://github.com/keep-starknet-strange/"
"alexandria.git\", rev = \"81bb93c\" }\n"
"```"
msgstr ""
"```\n"
"[dependencies]\n"
"alexandria_math = { git = \"https://github.com/keep-starknet-strange/"
"alexandria.git\", rev = \"81bb93c\" }\n"
"```"

#: src/ch02-03-scarb.md:175
msgid "After adding the dependency, remember to save the file."
msgstr "添加依赖项后，记得保存文件。"

#: src/ch02-03-scarb.md:177
msgid "Use the scarb add Command"
msgstr "使用 scarb add 命令"

#: src/ch02-03-scarb.md:179
msgid ""
"Alternatively, you can use the `scarb add` command to add dependencies to "
"your project. Open your terminal and execute the following command:"
msgstr "您也可以使用 `scarb add` 命令为项目添加依赖项。打开终端并执行以下命令："

#: src/ch02-03-scarb.md:182
msgid ""
"```\n"
"$ scarb add alexandria_math --git https://github.com/keep-starknet-strange/"
"alexandria.git\n"
"```"
msgstr ""
"```\n"
"$ scarb add alexandria_math --git https://github.com/keep-starknet-strange/"
"alexandria.git\n"
"```"

#: src/ch02-03-scarb.md:184
msgid ""
"This command will add the alexandria_math dependency from the specified Git "
"repository to your project."
msgstr "这条命令会将指定 Git 仓库中的 alexandria_math 外部依赖项添加到项目中。"

#: src/ch02-03-scarb.md:187
msgid "To remove a dependency, you can use the `scarb rm` command."
msgstr "要删除依赖项，可以使用 `scarb rm` 命令。"

#: src/ch02-03-scarb.md:189
msgid ""
"Once a dependency is added, the Scarb.toml file will be automatically updated "
"with the new dependency information."
msgstr "一旦添加了依赖项，Scarb.toml 文件就会自动更新，加入新的依赖项信息。"

#: src/ch02-03-scarb.md:192
msgid "Using Dependencies in Your Code"
msgstr "在代码中使用依赖项"

#: src/ch02-03-scarb.md:194
msgid ""
"After dependencies are added to your project, you can start utilizing them in "
"your Cairo code."
msgstr "将依赖项添加到项目中后，就可以开始在 Cairo 代码中使用它们了。"

#: src/ch02-03-scarb.md:197
msgid ""
"For example, let’s assume you have added the alexandria_math dependency. Now, "
"you can import and utilize functions from the alexandria_math library in your "
"`src/hello_scarb.cairo` file:"
msgstr ""
"例如，假设你已经添加了 alexandria_math 依赖项。现在，你可以在你的 `src/"
"hello_scarb.cairo` 文件中导入并使用 alexandria_math 库中的函数："

#: src/ch02-03-scarb.md:201
msgid ""
"```\n"
"// src/hello_scarb.cairo\n"
"use alexandria_math::fibonacci;\n"
"\n"
"fn main() -> felt252 {\n"
"    fibonacci::fib(0, 1, 10)\n"
"}\n"
"```"
msgstr ""
"```\n"
"// src/hello_scarb.cairo\n"
"use alexandria_math::fibonacci;\n"
"\n"
"fn main() -> felt252 {\n"
"    fibonacci::fib(0, 1, 10)\n"
"}\n"
"```"

#: src/ch02-03-scarb.md:208
msgid ""
"In the above example, we import the fibonacci function from the "
"alexandria_math library and utilize it in the main function."
msgstr ""
"在上面的示例中，我们从 alexandria_math 库中导入了 fibonacci 函数，并在主函数中"
"使用了它。"

#: src/ch02-03-scarb.md:211
msgid "Scarb Cheat Sheet"
msgstr "Scarb Cheat Sheet"

#: src/ch02-03-scarb.md:213
msgid ""
"Here’s a quick cheat sheet of some of the most commonly used Scarb commands:"
msgstr "下面是一些最常用的 Scarb 命令的cheat sheet："

#: src/ch02-03-scarb.md:216
msgid ""
"`scarb new <project_name>`: Initialize a new project with the given project "
"name."
msgstr "`scarb new <project_name>`: 用给定的项目名称初始化一个新项目。"

#: src/ch02-03-scarb.md:219
msgid "`scarb build`: Compile your Cairo code into Sierra code."
msgstr "`scarb build`: 编译将 Cairo 代码编译成 Sierra 代码。"

#: src/ch02-03-scarb.md:221
msgid ""
"`scarb add <dependency> --git <repository>`: Add a dependency to your project "
"from a specified Git repository."
msgstr ""
"`scarb add <dependency> --git <repository>`: 从指定的 Git 仓库向项目添加依赖"
"项。"

#: src/ch02-03-scarb.md:224
msgid "`scarb rm <dependency>`: Remove a dependency from your project."
msgstr "`scarb rm <dependency>`: 从项目中移除一个依赖项。"

#: src/ch02-03-scarb.md:226
msgid ""
"`scarb run <script>`: Run a custom script defined in your `Scarb.toml` file."
msgstr "`scarb run <script>`: 运行在`Scarb.toml`文件中定义的自定义脚本。"

#: src/ch02-03-scarb.md:229
msgid ""
"Scarb is a versatile tool, and this is just the beginning of what you can "
"achieve with it. As you gain more experience in the Cairo language and the "
"Starknet platform, you’ll discover how much more you can do with Scarb."
msgstr ""
"Scarb 是一个多功能工具，上面的教程只是一个开始，这这些仅仅只是它所能实现功能的"
"一小部分。随着您在Cairo语言和Starknet平台上获得更多的经验，您会发现 Scarb 能为"
"您做更多的事情。"

#: src/ch02-03-scarb.md:234
msgid ""
"To stay updated on Scarb and its features, be sure to check the [official "
"Scarb documentation](https://docs.swmansion.com/scarb/docs.html) regularly. "
"Happy coding!"
msgstr ""
"要了解 Scarb 及其功能的最新情况，请务必定期查看 [Scarb 官方文档](https://docs."
"swmansion.com/scarb/docs.html)。祝您代码写的愉快！"

#: src/ch02-03-scarb.md:239 src/ch02-07-starknet-js.md:174
#: src/ch02-08-starknet-react.md:395 src/ch03-00-architecture.md:264
#: src/ch03-02-sequencers.md:254 src/ch03-03-provers.md:233
#: src/ch03-04-nodes.md:439 src/ch04-00-account-abstraction.md:297
#: src/ch04-01-accounts.md:116 src/ch04-02-hello-account.md:199
#: src/ch04-03-standard-account.md:370 src/ch04-04-01-multicaller.md:91
#: src/ch04-04-02-multisig.md:412
msgid "The Book is a community-driven effort created for the community."
msgstr "这本书由社区推动，为社区而生。"

#: src/ch02-03-scarb.md:241 src/ch02-07-starknet-js.md:176
#: src/ch02-08-starknet-react.md:397 src/ch03-00-architecture.md:266
#: src/ch03-02-sequencers.md:256 src/ch03-03-provers.md:235
#: src/ch03-04-nodes.md:441 src/ch04-00-account-abstraction.md:299
#: src/ch04-01-accounts.md:118 src/ch04-02-hello-account.md:201
#: src/ch04-03-standard-account.md:372 src/ch04-04-01-multicaller.md:93
#: src/ch04-04-02-multisig.md:414
msgid ""
"If you’ve learned something, or not, please take a moment to provide feedback "
"through [this 3-question survey](https://a.sprig.com/"
"WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=)."
msgstr ""
"如果您有所收获，或者没有收获，请花点时间在这个 [三问调查](https://a.sprig.com/"
"WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=) 上提"
"供一些反馈意见。"

#: src/ch02-03-scarb.md:245 src/ch02-07-starknet-js.md:180
#: src/ch02-08-starknet-react.md:401 src/ch03-00-architecture.md:270
#: src/ch03-02-sequencers.md:260 src/ch03-03-provers.md:239
#: src/ch03-04-nodes.md:445 src/ch04-00-account-abstraction.md:303
#: src/ch04-01-accounts.md:122 src/ch04-02-hello-account.md:205
#: src/ch04-03-standard-account.md:376 src/ch04-04-01-multicaller.md:97
#: src/ch04-04-02-multisig.md:418
msgid ""
"If you discover any errors or have additional suggestions, don’t hesitate to "
"open an [issue on our GitHub repository](https://github.com/starknet-edu/"
"starknetbook/issues)."
msgstr ""
"如果您发现任何错误或有其他建议，请随时在 [GitHub 代码库](https://github.com/"
"starknet-edu/starknetbook/issues) 上提出一个issue。"

#: src/ch02-05-katana.md:3
msgid ""
"`Katana` is an indispensable tool designed to aid in local development. This "
"creation by the [Dojo team](https://github.com/dojoengine/dojo/blob/main/"
"crates/katana/README.md) enables you to perform all Starknet-related "
"activities in a local environment, thus serving as an efficient platform for "
"development and testing."
msgstr ""
"`Katana`是一个不可或缺的本地开发工具。这个由[Dojo 团队](https://github.com/"
"dojoengine/dojo/blob/main/crates/katana/README.md)创建的工具可以让您在本地环境"
"中执行所有与Starknet有关的活动，从而成为一个高效的开发和测试平台。"

#: src/ch02-05-katana.md:10
msgid ""
"We suggest employing either `katana` or `starknet-devnet` for testing your "
"contracts, with the latter discussed in detail in the following subchapter. "
"The `starknet-devnet` is a public testnet, maintained by the [Shard Labs team]"
"(https://github.com/Shard-Labs/starknet-devnet). Both these tools offer an "
"effective environment for development and testing."
msgstr ""
"我们建议使用 `katana` 或 `starknet-devnet` \"来测试你的合约，后者将在下一章中"
"详细讨论。`starknet-devnet`是一个公共测试网络，由[Shard Labs team](https://"
"github.com/Shard-Labs/starknet-devnet)维护。这两种工具都为开发和测试提供了有效"
"的环境。"

#: src/ch02-05-katana.md:16
msgid ""
"For an example of how to use `katana` to deploy and interact with a contract, "
"see [Chapter 2’s Voting contract example](https://book.starknet.io/chapter_2/"
"deploy_call_invoke.html)."
msgstr ""
"有关如何使用 `katana` 部署合约并与之交互的示例，请参阅 [第 2 章 投票合约示例]"
"(https://book.starknet.io/chapter_2/deploy_call_invoke.html)。"

#: src/ch02-05-katana.md:20
msgid "Understanding RPC in Starknet"
msgstr "了解Starknet中的 RPC"

#: src/ch02-05-katana.md:22
msgid ""
"Remote Procedure Call (RPC) establishes the communication between nodes in "
"the Starknet network. Essentially, it allows us to interact with a node in "
"the Starknet network. The RPC server is responsible for receiving these calls."
msgstr ""
"远程过程调用（RPC）建立了Starknet节点之间的通信。从本质上讲，它允许我们与 "
"Starknet 网络中的节点进行交互。RPC 服务器负责接收这些调用。"

#: src/ch02-05-katana.md:27
msgid ""
"RPC can be obtained from various sources: . To support the decentralization "
"of the Network, you can use your own local Starknet node. Consult [Chapter 4]"
"(https://book.starknet.io/chapter_4/node.html) for guidelines on setting up "
"your node. . For ease of access, consider using a provider such as [Infura]"
"(https://docs.infura.io/networks/starknet/how-to) or [Alchemy](https://www."
"alchemy.com/starknet) to get an RPC client. . For development and testing, a "
"temporary local node such as `katana` can be used."
msgstr ""
"RPC 可从各种来源获取：.为了支持网络的分散化，您可以使用自己的本地Starknet节"
"点。请参阅 [Chapter 4](https://book.starknet.io/chapter_4/node.html)，了解如何"
"建立自己的节点。.为便于访问，可考虑使用 [Infura](https://docs.infura.io/"
"networks/starknet/how-to) 或 [Alchemy](https://www.alchemy.com/starknet) 等提"
"供商来获取 RPC 客户端。为便于开发和测试，可使用临时本地节点（如 `katana`）。"

#: src/ch02-05-katana.md:37
msgid "Getting Started with Katana"
msgstr "开始使用Katana"

#: src/ch02-05-katana.md:39
msgid "To install `katana` from its source code, run the following commands:"
msgstr "要从源代码安装 `katana`，请运行以下命令："

#: src/ch02-05-katana.md:41
msgid ""
"```\n"
"mkdir ~/.dojo && cd ~/.dojo\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"
msgstr ""
"```\n"
"mkdir ~/.dojo && cd ~/.dojo\n"
"git clone https://github.com/dojoengine/dojo\n"
"cd dojo\n"
"cargo install --path ./crates/katana --locked --force\n"
"```"

#: src/ch02-05-katana.md:46
msgid "Once installed, confirm it with the version command:"
msgstr "安装完成后，使用版本命令进行确认："

#: src/ch02-05-katana.md:50
msgid ""
"Updating `katana` to its latest version involves going back to the `dojo` "
"directory and running the following commands:"
msgstr "将 `katana` 更新到最新版本需要返回 `dojo` 目录并运行以下命令："

#: src/ch02-05-katana.md:59
msgid "To initialize a local Starknet node, execute the following command:"
msgstr "要初始化本地 Starknet 节点，请执行以下命令："

#: src/ch02-05-katana.md:63
msgid ""
"The `--accounts` flag determines the number of accounts to be created, while "
"the `--seed` flag sets the seed for the private keys of these accounts. This "
"ensures that initializing the node with the same seed will always yield the "
"same accounts. Lastly, the `--gas-price` flag specifies the transaction gas "
"price."
msgstr ""
"`--accounts` 标志决定要创建的账户数量，而 `--seed` 标志则为这些账户的私钥设置"
"种子。这样可以确保用相同的种子初始化节点时，总是会产生相同的账户。最后，\"--"
"gas-price \"标志指定了交易gas的价格。"

#: src/ch02-05-katana.md:69
msgid "Running the command produces output similar to this:"
msgstr "运行该命令会产生类似下面的输出结果："

#: src/ch02-05-katana.md:71
msgid ""
"```\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x0300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"| Account address |  "
"0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5\n"
"| Private key     |  "
"0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c\n"
"| Public key      |  "
"0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://0.0.0.0:5050\n"
"```"
msgstr ""
"```\n"
"██╗  ██╗ █████╗ ████████╗ █████╗ ███╗   ██╗ █████╗\n"
"██║ ██╔╝██╔══██╗╚══██╔══╝██╔══██╗████╗  ██║██╔══██╗\n"
"█████╔╝ ███████║   ██║   ███████║██╔██╗ ██║███████║\n"
"██╔═██╗ ██╔══██║   ██║   ██╔══██║██║╚██╗██║██╔══██║\n"
"██║  ██╗██║  ██║   ██║   ██║  ██║██║ ╚████║██║  ██║\n"
"╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝\n"
"\n"
"\n"
"PREFUNDED ACCOUNTS\n"
"==================\n"
"\n"
"| Account address |  "
"0x03ee9e18edc71a6df30ac3aca2e0b02a198fbce19b7480a63a0d71cbd76652e0\n"
"| Private key     |  "
"0x0300001800000000300000180000000000030000000000003006001800006600\n"
"| Public key      |  "
"0x01b7b37a580d91bc3ad4f9933ed61f3a395e0e51c9dd5553323b8ca3942bb44e\n"
"\n"
"| Account address |  "
"0x033c627a3e5213790e246a917770ce23d7e562baa5b4d2917c23b1be6d91961c\n"
"| Private key     |  "
"0x0333803103001800039980190300d206608b0070db0012135bd1fb5f6282170b\n"
"| Public key      |  "
"0x04486e2308ef3513531042acb8ead377b887af16bd4cdd8149812dfef1ba924d\n"
"\n"
"| Account address |  "
"0x01d98d835e43b032254ffbef0f150c5606fa9c5c9310b1fae370ab956a7919f5\n"
"| Private key     |  "
"0x07ca856005bee0329def368d34a6711b2d95b09ef9740ebf2c7c7e3b16c1ca9c\n"
"| Public key      |  "
"0x07006c42b1cfc8bd45710646a0bb3534b182e83c313c7bc88ecf33b53ba4bcbc\n"
"\n"
"\n"
"ACCOUNTS SEED\n"
"=============\n"
"0\n"
"\n"
"\n"
"🚀 JSON-RPC server started: http://0.0.0.0:5050\n"
"```"

#: src/ch02-05-katana.md:102
msgid ""
"The output includes the addresses, private keys, and public keys of the "
"created accounts. It also contains the seed used to generate the accounts. "
"This seed can be reused to create identical accounts in future runs. "
"Additionally, the output provides the URL of the JSON-RPC server. This URL "
"can be used to establish a connection to the local Starknet node."
msgstr ""
"输出结果包括已创建账户的地址、私钥和公钥。它还包含用于生成账户的种子。该种子可"
"重复使用，以便在以后的运行中创建相同的账户。此外，输出还提供了 JSON-RPC 服务器"
"的 URL。该 URL 可用于建立与本地 Starknet 节点的连接。"

#: src/ch02-05-katana.md:109
msgid "To stop the local Starknet node, simply press `Ctrl+C`."
msgstr "要停止本地 Starknet 节点，只需按`Ctrl+C`键。"

#: src/ch02-05-katana.md:111
msgid ""
"The local Starknet node does not persist data. Hence, once it’s stopped, all "
"data will be erased."
msgstr ""
"本地 Starknet 节点不会永久保存数据。因此，一旦停止运行，所有数据都将被清除。"

#: src/ch02-05-katana.md:114
msgid ""
"For a practical demonstration of `katana` to deploy and interact with a "
"contract, see [Chapter 2’s Voting contract example](https://book.starknet.io/"
"chapter_2/deploy_call_invoke.html)."
msgstr ""
"有关 `katana` 部署合约并与之交互的实际演示，请参阅 [第 2 章 投票合约示例]"
"(https://book.starknet.io/chapter_2/deploy_call_invoke.html)。"

#: src/ch02-07-starknet-js.md:3
msgid ""
"Starknet.js is a JavaScript/TypeScript library designed to connect your "
"website or decentralized application (D-App) to Starknet. It aims to mimic "
"the architecture of [ethers.js](https://docs.ethers.org/v5/), so if you are "
"familiar with ethers, you should find Starknet.js easy to work with."
msgstr ""
"Starknet.js 是一个 JavaScript/TypeScript 库，用于将您的网站或去中心化应用程序"
"（D-App）连接到Starknet。它旨在模仿 [ethers.js](https://docs.ethers.org/v5/) "
"的架构，所以如果你熟悉 ethers，你会发现 Starknet.js 很容易使用。"

#: src/ch02-07-starknet-js.md:11
msgid "Starknet-js in your dapp"
msgstr "在您的 dapp 中使用 Starknet-js"

#: src/ch02-07-starknet-js.md:15
msgid "To install Starknet.js, follow these steps:"
msgstr "按照以下步骤安装 Starknet.js："

#: src/ch02-07-starknet-js.md:17
msgid "For the latest official release (main branch):"
msgstr "最新正式版本（主分支）："

#: src/ch02-07-starknet-js.md:23
msgid "To use the latest features (merges in develop branch):"
msgstr "使用最新功能（合并到开发分支）："

#: src/ch02-07-starknet-js.md:31
msgid ""
"To build an app that users are able to connect to and interact with Starknet, "
"we recommend adding the [get-starknet](https://github.com/starknet-io/get-"
"starknet) library, which allows you to manage wallet connections."
msgstr ""
"要构建一个用户能够连接到Starknet并与之互动的应用程序，我们建议添加[get-"
"starknet](https://github.com/starknet-io/get-starknet)库，该库允许您管理钱包连"
"接。"

#: src/ch02-07-starknet-js.md:36
msgid ""
"With these tools ready, there are basically 3 main concepts to know on the "
"frontend: Account, Provider, and Contracts."
msgstr ""
"准备好这些工具后，在前端基本上需要了解 3 个主要概念：账户、提供商和合约。"

#: src/ch02-07-starknet-js.md:39
msgid "Account"
msgstr "帐户"

#: src/ch02-07-starknet-js.md:41
msgid ""
"We can generally think of the account as the \"end user\" of a dapp, and some "
"user interaction will be involved to gain access to it."
msgstr ""
"一般来说，我们可以把账户看作是 dapp 的 \"最终用户\"，要访问该账户，需要与用户"
"进行一些交互。"

#: src/ch02-07-starknet-js.md:44
msgid ""
"Think of a dapp where the user connects their browser extension wallet (such "
"as ArgentX or Braavos) - if the user accepts the connection, that gives us "
"access to the account and signer, which can sign transactions and messages."
msgstr ""
"想象一下用户连接浏览器扩展钱包（如 ArgentX 或 Braavos）的 dapp，如果用户接受连"
"接，我们就可以访问账户和签名者，从而签署交易和信息。"

#: src/ch02-07-starknet-js.md:49
msgid ""
"Unlike Ethereum, where user accounts are Externally Owned Accounts, Starknet "
"**accounts are contracts**. This might not necessarily impact your dapp’s "
"frontend, but you should definitely be aware of this difference."
msgstr ""
"以太坊的用户账户是EOA（外部拥有账户），而Starknet的**账户是合约**。这可能不一"
"定会影响你的 dapp 前端，但你一定要意识到这种差异。"

#: src/ch02-07-starknet-js.md:64
msgid ""
"The snippet above uses the `connect` function provided by `get-starknet` to "
"establish a connection to the user wallet. Once connected, we are able to "
"access account methods, such as `signMessage` or `execute`."
msgstr ""
"上面的代码段使用`get-starknet`提供的`connect`函数与用户钱包建立连接。连接后，"
"我们就可以访问账户方法，如 `signMessage` 或 `execute`。"

#: src/ch02-07-starknet-js.md:66 src/ch02-07-01-00-counter-ui.md:150
msgid "Provider"
msgstr "提供者"

#: src/ch02-07-starknet-js.md:68
msgid ""
"The provider allows you to interact with the Starknet network. You can think "
"of it as a \"read\" connection to the blockchain, as it doesn’t allow signing "
"transactions or messages. Just like in Ethereum, you can use a default "
"provider, or use services such as Infura or Alchemy, both of which support "
"Starknet, to create an RPC provider."
msgstr ""
"该提供商允许您与Starknet网络进行交互。你可以把它看作是与区块链的 \"只读 \"连"
"接，因为它不允许签署交易或消息。就像在以太坊中一样，你可以使用默认的提供者，也"
"可以使用 Infura 或 Alchemy（两者都支持 Starknet）等服务来创建 RPC 提供者。"

#: src/ch02-07-starknet-js.md:74
msgid "By default, the Provider is a sequencer provider."
msgstr "默认情况下，提供程序是一个排序器提供程序。"

#: src/ch02-07-starknet-js.md:76
msgid ""
"```ts\n"
"export const provider = new Provider({\n"
"  sequencer: {\n"
"    network: \"goerli-alpha\",\n"
"  },\n"
"  // rpc: {\n"
"  //   nodeUrl: INFURA_ENDPOINT\n"
"  // }\n"
"});\n"
"\n"
"const block = await provider.getBlock(\"latest\"); // <- Get latest block\n"
"console.log(block.block_number);\n"
"```"
msgstr ""
"```ts\n"
"export const provider = new Provider({\n"
"  sequencer: {\n"
"    network: \"goerli-alpha\",\n"
"  },\n"
"  // rpc: {\n"
"  //   nodeUrl: INFURA_ENDPOINT\n"
"  // }\n"
"});\n"
"\n"
"const block = await provider.getBlock(\"latest\"); // <- Get latest block\n"
"console.log(block.block_number);\n"
"```"

#: src/ch02-07-starknet-js.md:90
msgid "Contracts"
msgstr "合约"

#: src/ch02-07-starknet-js.md:92
msgid ""
"Your frontend will likely be interacting with deployed contracts. For each "
"contract, there should be a counterpart on the frontend. To create these "
"instances, you will need the contract’s address and ABI, and either a "
"provider or signer."
msgstr ""
"您的前端可能需要与已部署的合约进行交互。对于每个合约，前端都应该有一个对应的实"
"例。要创建这些实例，你需要合约的地址和 ABI，以及提供者或签署者。"

#: src/ch02-07-starknet-js.md:97
msgid ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, starknet.account);\n"
"\n"
"const balance = await contract.balanceOf(starknet.account.address);\n"
"const transfer = await contract.transfer(recipientAddress, amountFormatted);\n"
"//or: const transfer = await contract.invoke(\"transfer\", [to, "
"amountFormatted]);\n"
"\n"
"console.log(`Tx hash: ${transfer.transaction_hash}`);\n"
"```"
msgstr ""
"```ts\n"
"const contract = new Contract(abi_erc20, contractAddress, starknet.account);\n"
"\n"
"const balance = await contract.balanceOf(starknet.account.address);\n"
"const transfer = await contract.transfer(recipientAddress, amountFormatted);\n"
"//or: const transfer = await contract.invoke(\"transfer\", [to, "
"amountFormatted]);\n"
"\n"
"console.log(`Tx hash: ${transfer.transaction_hash}`);\n"
"```"

#: src/ch02-07-starknet-js.md:107
msgid ""
"If you create a contract instance with a provider, you’ll be limited to "
"calling read functions on the contract - only with a signer can you change "
"the state of the blockchain. However, you are able to connect a previously "
"created `Contract` instance with a new account:"
msgstr ""
"如果使用提供者创建合约实例，则只能调用合约上的只读函数，只有使用签名者才能改变"
"区块链的状态。不过，您可以将以前创建的 \"合约 \"实例与新账户连接起来："

#: src/ch02-07-starknet-js.md:118
msgid ""
"In the snippet above, after calling the `connect` method, it would be "
"possible to call read functions on the contract, but not before."
msgstr ""
"在上面的代码段中，在调用 `connect` 方法后，可以调用合约上的只读函数，但在此之"
"前则不行。"

#: src/ch02-07-starknet-js.md:122
msgid "Units"
msgstr "单位"

#: src/ch02-07-starknet-js.md:124
msgid ""
"If you have previous experience with web3, you know dealing with units "
"requires care, and Starknet is no exception. Once again, the docs are very "
"useful here, in particular [this section on data transformation](https://www."
"starknetjs.com/docs/guides/define_call_message/)."
msgstr ""
"如果你以前有过 web3开发经验，就会知道处理单位需要小心谨慎，Starknet 也不例外。"
"遇上这种情况时，文档总是非常有用的，尤其是[关于数据转换的这一部分](https://"
"www.starknetjs.com/docs/guides/define_call_message/)。"

#: src/ch02-07-starknet-js.md:129
msgid ""
"Very often you will need to convert Cairo structs (such as Uint256) that are "
"returned from contracts into numbers:"
msgstr "您经常需要将从合约返回的 Cairo 结构体（如 Uint256）转换为数字："

#: src/ch02-07-starknet-js.md:132
msgid ""
"```ts\n"
"// Uint256 shape:\n"
"// {\n"
"//    type: 'struct',\n"
"//    low: Uint256.low,\n"
"//    high: Uint256.high\n"
"//\n"
"// }\n"
"const balance = await contract.balanceOf(address); // <- uint256\n"
"const asBN = uint256.uint256ToBN(uint256); // <- uint256 into BN\n"
"const asString = asBN.toString(); //<- BN into string\n"
"```"
msgstr ""
"```ts\n"
"// Uint256 shape:\n"
"// {\n"
"//    type: 'struct',\n"
"//    low: Uint256.low,\n"
"//    high: Uint256.high\n"
"//\n"
"// }\n"
"const balance = await contract.balanceOf(address); // <- uint256\n"
"const asBN = uint256.uint256ToBN(uint256); // <- uint256 into BN\n"
"const asString = asBN.toString(); //<- BN into string\n"
"```"

#: src/ch02-07-starknet-js.md:145
msgid "And vice versa:"
msgstr "反之亦然："

#: src/ch02-07-starknet-js.md:147
msgid ""
"```ts\n"
"const amount = 1;\n"
"\n"
"const amountFormatted = {\n"
"  type: \"struct\",\n"
"  ...uint256.bnToUint256(amount),\n"
"};\n"
"```"
msgstr ""
"```ts\n"
"const amount = 1;\n"
"\n"
"const amountFormatted = {\n"
"  type: \"struct\",\n"
"  ...uint256.bnToUint256(amount),\n"
"};\n"
"```"

#: src/ch02-07-starknet-js.md:156
msgid ""
"There are other helpful utils, besides `bnToUint256` and `uint256ToBN`, "
"provided by Starknet.js."
msgstr ""
"除了 `bnToUint256` 和 `uint256ToBN` 之外，Starknet.js 还提供了其他有用的工具。"

#: src/ch02-07-starknet-js.md:159
msgid ""
"We now have a solid foundation to build a Starknet dapp. However, there are "
"framework specific tools that help us build Starknet dapps, which are covered "
"in chaper 5."
msgstr ""
"我们现在有了构建Starknet应用程序的坚实基础。不过，还有一些特定的框架工具可以帮"
"助我们构建Starknet应用程序，这将在第 5 章中介绍。"

#: src/ch02-07-starknet-js.md:163
msgid "Additional Resources"
msgstr "更多资源"

#: src/ch02-07-starknet-js.md:165
msgid "Starknet.js GitHub Repository: <https://github.com/0xs34n/starknet.js>"
msgstr "Starknet.js GitHub 代码仓库：<https://github.com/0xs34n/starknet.js>"

#: src/ch02-07-starknet-js.md:168
msgid ""
"Official Starknet.js Website and documentation: <https://www.starknetjs.com/>"
msgstr "官方 Starknet.js 网站和文档：<https://www.starknetjs.com/>"

#: src/ch02-07-starknet-js.md:171
msgid ""
"Stay tuned for more updates on Starknet.js, including detailed guides, "
"examples, and comprehensive documentation."
msgstr ""
"请继续关注有关 Starknet.js 的更多更新，包括详细的指南、示例和全面的文档。"

#: src/ch02-07-01-examples.md:3
msgid ""
"In this subchapter, readers will find practical examples demonstrating the "
"usage of both `starknet-js` and `starknet-react`. It provides insight into "
"real-world applications and serves as a guide for developers to understand "
"and implement these tools effectively."
msgstr ""
"在本分章中，读者将看到演示使用 `starknet-js` 和 `starknet-react` 的实际示例。"
"它提供了对真实世界应用的洞察，可作为开发人员理解和有效实施这些工具的指南。"

#: src/ch02-07-01-examples.md:5
msgid "We value the contribution of our developer community:"
msgstr "我们重视开发人员社区的贡献："

#: src/ch02-07-01-examples.md:7
msgid "We encourage developers to contribute additional examples."
msgstr "我们鼓励开发人员提供更多示例。"

#: src/ch02-07-01-examples.md:8
msgid "Please inform us if you identify any mistakes or inaccuracies."
msgstr "如果您发现任何错误或不准确之处，请通知我们。"

#: src/ch02-07-01-examples.md:10
msgid ""
"Your insights and feedback are instrumental in making this resource more "
"comprehensive and accurate."
msgstr "您的见解和反馈有助于使本资料更加全面和准确。"

#: src/ch02-07-01-00-counter-ui.md:1
msgid "Counter Smart Contract UI Integration"
msgstr "计数器智能合约用户界面集成"

#: src/ch02-07-01-00-counter-ui.md:3
msgid ""
"This guide walks readers through integrating a simple counter smart contract "
"with a frontend. By the end of this guide, readers will understand how to:"
msgstr ""
"本指南指导读者如何将简单的计数器智能合约与前端集成。在本指南结束时，读者将了解"
"如何："

#: src/ch02-07-01-00-counter-ui.md:5
msgid "Connect the frontend to a smart contract."
msgstr "将前端连接到智能合约。"

#: src/ch02-07-01-00-counter-ui.md:6
msgid "Initiate transactions, such as incrementing or decrementing the counter."
msgstr "启动交易，如递增或递减计数器。"

#: src/ch02-07-01-00-counter-ui.md:7
msgid ""
"Read and display data, such as showing the counter value on the frontend."
msgstr "读取和显示数据，例如在前端显示计数器的数值。"

#: src/ch02-07-01-00-counter-ui.md:9 src/ch02-07-01-00-counter-ui.md:246
msgid ""
"For a visual walkthrough, do check out the [Basecamp frontend session]"
"(https://drive.google.com/file/d/1Dtb3Ol_BVoNV4w-_MKV8aeyyRra8nRtz/view). "
"This comprehensive session delves deeper into the nuances of the concepts "
"we've touched upon, presenting a mix of theoretical explanations and hands-on "
"demonstrations."
msgstr ""
"要获得直观的演示，请查看 [Basecamp 前端课程](https://drive.google.com/file/"
"d/1Dtb3Ol_BVoNV4w-_MKV8aeyyRra8nRtz/view)。这节综合课程深入探讨了我们所涉及概"
"念的细微差别，既有理论解释，也有实践演示。"

#: src/ch02-07-01-00-counter-ui.md:11
msgid "Tools Used"
msgstr "使用的工具"

#: src/ch02-07-01-00-counter-ui.md:13
msgid ""
"[Reactjs](https://react.dev/learn/start-a-new-react-project): A frontend "
"building framework."
msgstr ""
"[Reactjs](https://react.dev/learn/start-a-new-react-project)：前端构建框架。"

#: src/ch02-07-01-00-counter-ui.md:14
msgid ""
"[@argent/get-starknet](https://www.npmjs.com/package/@argent/get-starknet): A "
"wrapper for **[starknet.js](https://github.com/0xs34n/starknet.js)**, aiding "
"interaction with wallet extensions."
msgstr ""
"[@argent/get-starknet](https://www.npmjs.com/package/@argent/get-starknet)：一"
"个对于 **[starknet.js](https://github.com/0xs34n/starknet.js)**的封装，帮助与"
"钱包扩展进行交互。"

#: src/ch02-07-01-00-counter-ui.md:15
msgid ""
"[starknet](https://www.npmjs.com/package/starknet): A JavaScript library for "
"Starknet."
msgstr ""
"[starknet](https://www.npmjs.com/package/starknet)：用于 Starknet 的 "
"JavaScript 库。"

#: src/ch02-07-01-00-counter-ui.md:17
msgid "Setting Up the Environment"
msgstr "配置环境"

#: src/ch02-07-01-00-counter-ui.md:19
msgid "To begin, clone the project repository:"
msgstr "首先，克隆项目仓库："

#: src/ch02-07-01-00-counter-ui.md:21
msgid ""
"```bash\n"
"git clone https://github.com/Darlington02/basecamp-frontend-boilerplate\n"
"```"
msgstr ""
"```bash\n"
"git clone https://github.com/Darlington02/basecamp-frontend-boilerplate\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:25
msgid "Then, navigate to the project directory and install necessary packages:"
msgstr "然后，导航至项目目录并安装必要的软件包："

#: src/ch02-07-01-00-counter-ui.md:32
msgid "To launch the project, run:"
msgstr "要启动该项目，请运行"

#: src/ch02-07-01-00-counter-ui.md:38
msgid "In `index.js`, several key functions are provided:"
msgstr "在 `index.js` 中，提供了几个关键函数："

#: src/ch02-07-01-00-counter-ui.md:40
msgid ""
"```javascript\n"
"// Connect to the blockchain via a wallet provider (argentX or Bravoos)\n"
"const connectWallet = async() => {\n"
"}\n"
"\n"
"// Terminate the connection\n"
"const disconnectWallet = async() => {\n"
"}\n"
"\n"
"// Trigger increment\n"
"const increaseCounter = async() => {\n"
"}\n"
"\n"
"// Trigger decrement\n"
"const decreaseCounter = async() => {\n"
"}\n"
"\n"
"// Retrieve current count\n"
"const getCounter = async() => {\n"
"}\n"
"```"
msgstr ""
"```javascript\n"
"// Connect to the blockchain via a wallet provider (argentX or Bravoos)\n"
"const connectWallet = async() => {\n"
"}\n"
"\n"
"// Terminate the connection\n"
"const disconnectWallet = async() => {\n"
"}\n"
"\n"
"// Trigger increment\n"
"const increaseCounter = async() => {\n"
"}\n"
"\n"
"// Trigger decrement\n"
"const decreaseCounter = async() => {\n"
"}\n"
"\n"
"// Retrieve current count\n"
"const getCounter = async() => {\n"
"}\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:62
msgid "Managing Connection"
msgstr "管理连接"

#: src/ch02-07-01-00-counter-ui.md:64
msgid "`connectWallet`"
msgstr "`connectWallet`"

#: src/ch02-07-01-00-counter-ui.md:66
msgid ""
"The `connectWallet` function serves as the mechanism to establish a "
"connection to the blockchain through specific wallet providers such as "
"ArgentX or Braavos. It is asynchronous, allowing the use of `await` for "
"handling asynchronous tasks."
msgstr ""
"`connectWallet` 函数是通过 ArgentX 或 Braavos 等特定钱包提供商与区块链建立连接"
"的机制。它是异步的，允许使用 `await` 来处理异步任务。"

#: src/ch02-07-01-00-counter-ui.md:68
msgid ""
"```JavaScript\n"
"const connectWallet = async() => {\n"
"    const connection = await connect({webWalletUrl: \"https://web.argent."
"xyz\"});\n"
"    if (connection && connection.isConnected) {\n"
"      setConnection(connection);\n"
"      setAccount(connection.account);\n"
"      setAddress(connection.selectedAddress);\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```JavaScript\n"
"const connectWallet = async() => {\n"
"    const connection = await connect({webWalletUrl: \"https://web.argent."
"xyz\"});\n"
"    if (connection && connection.isConnected) {\n"
"      setConnection(connection);\n"
"      setAccount(connection.account);\n"
"      setAddress(connection.selectedAddress);\n"
"    }\n"
"}\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:79
msgid ""
"Initiates the connection using the **`connect`** method from the **`@argent/"
"get-starknet`** library, targeting Starknet."
msgstr ""
"使用 **`connect`** 方法从 **`@argent/get-starknet`** 库启动连接，目标是 "
"Starknet。"

#: src/ch02-07-01-00-counter-ui.md:80
msgid ""
"Upon a successful connection, updates the React component's state with "
"details of the **`connection`**, **`account`**, and **`selectedAddress`**."
msgstr ""
"连接成功后，用**`connection`**, **`account`**, 和**`selectedAddress`**的详细信"
"息更新 React 组件的状态。"

#: src/ch02-07-01-00-counter-ui.md:83
msgid "`disconnectWallet`"
msgstr "`disconnectWallet`"

#: src/ch02-07-01-00-counter-ui.md:85
msgid ""
"The `disconnectWallet` function is designed to sever the connection with the "
"web wallet asynchronously. After disconnection, it updates the component's "
"state, resetting connection details."
msgstr ""
"`disconnectWallet`函数旨在异步断开与网络钱包的连接。断开连接后，它会更新组件的"
"状态，重置连接详情。"

#: src/ch02-07-01-00-counter-ui.md:96
msgid ""
"It utilizes the **`disconnect`** function, possibly from an external library, "
"and handles the operation asynchronously with **`await`**."
msgstr ""
"它会使用**`disconnect`**函数（可能来自外部库），并通过**`await`**异步处理操"
"作。"

#: src/ch02-07-01-00-counter-ui.md:97
msgid "Post-disconnection, the state of the React component is updated:"
msgstr "断开连接后，React 组件的状态会被更新："

#: src/ch02-07-01-00-counter-ui.md:98
msgid "**`setConnection`** is set to **`undefined`**."
msgstr "***`setConnection`**被设置为**`undefined`**。"

#: src/ch02-07-01-00-counter-ui.md:99
msgid "**`setAccount`** is set to **`undefined`**."
msgstr "***`setAccount`**被设置为**`undefined`**。"

#: src/ch02-07-01-00-counter-ui.md:100
msgid "**`setAddress`** is cleared with an empty string."
msgstr "**`setAddress`** 被清空为空字符串。"

#: src/ch02-07-01-00-counter-ui.md:103
msgid "`EagerlyConnect`"
msgstr "`EagerlyConnect`"

#: src/ch02-07-01-00-counter-ui.md:105
msgid ""
"The `EagerlyConnect` mechanism leverages React's `useEffect` hook to initiate "
"a connection to Starknet upon the component's mounting or initial rendering."
msgstr ""
"`EagerlyConnect`机制利用 React 的 `useEffect` 钩子，在组件挂载或初始渲染时启动"
"与Starknet的连接。"

#: src/ch02-07-01-00-counter-ui.md:107
msgid ""
"```javascript\n"
"useEffect(() => {\n"
"    const connectToStarknet = async() => {\n"
"      const connection = await connect({ modalMode: \"neverAsk\", "
"webWalletUrl: \"https://web.argent.xyz\" });\n"
"\n"
"      if(connection && connection.isConnected) {\n"
"        setConnection(connection);\n"
"        setAccount(connection.account);\n"
"        setAddress(connection.selectedAddress);\n"
"      }\n"
"    }\n"
"    connectToStarknet();\n"
"  }, [])\n"
"```"
msgstr ""
"```javascript\n"
"useEffect(() => {\n"
"    const connectToStarknet = async() => {\n"
"      const connection = await connect({ modalMode: \"neverAsk\", "
"webWalletUrl: \"https://web.argent.xyz\" });\n"
"\n"
"      if(connection && connection.isConnected) {\n"
"        setConnection(connection);\n"
"        setAccount(connection.account);\n"
"        setAddress(connection.selectedAddress);\n"
"      }\n"
"    }\n"
"    connectToStarknet();\n"
"  }, [])\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:122
msgid ""
"Inside the **`useEffect`**, the **`connectToStarknet`** function is defined, "
"aiming to establish an asynchronous connection using the **`connect`** "
"function. Parameters like **`modalMode`** and **`webWalletUrl`** are passed "
"to guide the connection process."
msgstr ""
"在**`useEffect`**内部，定义了**`connectToStarknet`**函数，旨在使用"
"**`connect`**函数建立异步连接。传递**`modalMode`**和**`webWalletUrl`**等参数以"
"指导连接过程。"

#: src/ch02-07-01-00-counter-ui.md:123
msgid ""
"If successful in connecting (**`connection && connection.isConnected`**), the "
"state updates with details of the connection, the account, and the selected "
"address using **`setConnection`**, **`setAccount`**, and **`setAddress`**."
msgstr ""
"如果连接成功（**`connection && connection.isConnected`**），则使用"
"**`setConnection`**、**`setAccount`**和**`setAddress`**更新状态，包括连接、账"
"户和所选地址的详细信息。"

#: src/ch02-07-01-00-counter-ui.md:124
msgid ""
"The **`connectToStarknet`** function is executed immediately after its "
"definition."
msgstr "**`connectToStarknet`**函数在定义后立即执行。"

#: src/ch02-07-01-00-counter-ui.md:127
msgid "Important Refresher on Smart Contract Interactions"
msgstr "智能合约互动的重要复习"

#: src/ch02-07-01-00-counter-ui.md:129
msgid ""
"For effective interaction with a smart contract on the network, it's crucial "
"to understand key components after establishing a connection. Among these are "
"the `contract address`, `ABI`, `Signer`, and `Provider`."
msgstr ""
"要与网络上的智能合约进行有效互动，关键是要了解建立连接后的关键组件。其中包括 "
"`contract address`, `ABI`, `Signer`, 和 `Provider`.。"

#: src/ch02-07-01-00-counter-ui.md:131
msgid "ABI (Application Binary Interface)"
msgstr "ABI（应用程序二进制接口）"

#: src/ch02-07-01-00-counter-ui.md:133
msgid ""
"ABI is a standardized bridge between two binary program modules. It is "
"essential for:"
msgstr "ABI 是两个二进制程序模块之间的标准化桥梁。它对以下方面至关重要："

#: src/ch02-07-01-00-counter-ui.md:135
msgid "Interacting with smart contracts on the blockchain."
msgstr "与区块链上的智能合约互动。"

#: src/ch02-07-01-00-counter-ui.md:136
msgid ""
"Specifying the structure of functions, events, and variables for software "
"applications."
msgstr "为软件应用程序指定函数、事件和变量的结构。"

#: src/ch02-07-01-00-counter-ui.md:137
msgid ""
"Enabling smooth communication with the smart contract, detailing function "
"signatures, input/output types, event formats, and variable types."
msgstr ""
"实现与智能合约的顺畅通信，详细说明函数签名、输入/输出类型、事件格式和变量类"
"型。"

#: src/ch02-07-01-00-counter-ui.md:138
msgid ""
"Facilitating invocation of functions and data retrieval from the contract."
msgstr "为调用函数和从合约中检索数据提供便利。"

#: src/ch02-07-01-00-counter-ui.md:140
msgid "Signer"
msgstr "签名者"

#: src/ch02-07-01-00-counter-ui.md:142
msgid "The Signer plays a pivotal role in:"
msgstr "签名者在以下方面发挥着关键作用："

#: src/ch02-07-01-00-counter-ui.md:144
msgid "Signing transactions."
msgstr "签署交易。"

#: src/ch02-07-01-00-counter-ui.md:145
msgid "Authorizing actions on the blockchain."
msgstr "授权区块链上的行为。"

#: src/ch02-07-01-00-counter-ui.md:146
msgid "Bearing the fees associated with blockchain operations."
msgstr "承担与区块链业务相关的费用。"

#: src/ch02-07-01-00-counter-ui.md:148
msgid ""
"Signers are especially linked to write operations that change the state of "
"the blockchain. These operations need cryptographic signing for security and "
"validity."
msgstr ""
"签名者与改变区块链状态的写入操作尤其相关。这些操作需要加密签名来保证安全性和有"
"效性。"

#: src/ch02-07-01-00-counter-ui.md:152
msgid "The Provider acts as the medium for:"
msgstr "提供者充当以下活动的媒介："

#: src/ch02-07-01-00-counter-ui.md:154
msgid "Communication with the blockchain."
msgstr "与区块链通信。"

#: src/ch02-07-01-00-counter-ui.md:155
msgid "Creating transactions."
msgstr "创建交易。"

#: src/ch02-07-01-00-counter-ui.md:156
msgid "Fetching data from the blockchain."
msgstr "从区块链中获取数据。"

#: src/ch02-07-01-00-counter-ui.md:158
msgid ""
"To initiate a write transaction, the connected account (signer) must be "
"provided. This signer then signs the transaction, bearing the necessary fee "
"for execution."
msgstr ""
"要启动写入交易，必须提供连接账户（签名者）。签名者随后签署交易，并承担执行所需"
"的费用。"

#: src/ch02-07-01-00-counter-ui.md:161
msgid "Invoking the `increment` Function"
msgstr "调用 `increment` 函数"

#: src/ch02-07-01-00-counter-ui.md:163
msgid ""
"```javascript\n"
"const increaseCounter = async() => {\n"
"    try {\n"
"      const contract = new Contract(contractAbi, contractAddress, account)\n"
"      await contract.increment()\n"
"      alert(\"You successfully incremented the counter!\")\n"
"    }\n"
"    catch(err) {\n"
"      alert(err.message)\n"
"    }\n"
"  }\n"
"```"
msgstr ""
"```javascript\n"
"const increaseCounter = async() => {\n"
"    try {\n"
"      const contract = new Contract(contractAbi, contractAddress, account)\n"
"      await contract.increment()\n"
"      alert(\"You successfully incremented the counter!\")\n"
"    }\n"
"    catch(err) {\n"
"      alert(err.message)\n"
"    }\n"
"  }\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:176
msgid ""
"The **`increaseCounter`** function is crafted to interact with a smart "
"contract and increment a specific counter. Here's a step-by-step breakdown:"
msgstr ""
"**`increaseCounter`**函数用于与智能合约交互并递增特定计数器。下面是按照步骤的"
"分解讲解："

#: src/ch02-07-01-00-counter-ui.md:178
msgid ""
"Establishes a new contract instance using the provided contract's ABI, its "
"address, and the connected account. The account is essential since this write "
"transaction alters the contract's state."
msgstr ""
"使用提供的合约 ABI、合约地址和连接的账户建立一个新的合约实例。账户是必不可少"
"的，因为这个写入交易会改变合约的状态。"

#: src/ch02-07-01-00-counter-ui.md:179
msgid ""
"Executes the contract's **`increment`** method. The **`await`** keyword "
"ensures the program pauses until this action completes."
msgstr ""
"执行合约的 **`increment`** 方法。**`await`**关键字确保程序暂停，直到该操作完"
"成。"

#: src/ch02-07-01-00-counter-ui.md:180
msgid ""
"On successful execution, the user receives a confirmation alert indicating "
"the counter's increment."
msgstr "执行成功后，用户会收到计数器增量的确认提示。"

#: src/ch02-07-01-00-counter-ui.md:181
msgid ""
"In case of any errors during the process, an alert displays the corresponding "
"error message to the user."
msgstr ""
"如果在运行过程中出现任何错误，系统会向用户发出警报，显示相应的错误信息。"

#: src/ch02-07-01-00-counter-ui.md:184
msgid "Invoking the `decrement` Function"
msgstr "调用 `decrement` 函数"

#: src/ch02-07-01-00-counter-ui.md:186
msgid ""
"```javascript\n"
"const decreaseCounter = async() => {\n"
"    try {\n"
"      const contract = new Contract(contractAbi, contractAddress, account)\n"
"      await contract.decrement()\n"
"      alert(\"You successfully decremented the counter!\")\n"
"    }\n"
"    catch(err) {\n"
"      alert(err.message)\n"
"    }\n"
"  }\n"
"```"
msgstr ""
"```javascript\n"
"const decreaseCounter = async() => {\n"
"    try {\n"
"      const contract = new Contract(contractAbi, contractAddress, account)\n"
"      await contract.decrement()\n"
"      alert(\"You successfully decremented the counter!\")\n"
"    }\n"
"    catch(err) {\n"
"      alert(err.message)\n"
"    }\n"
"  }\n"
"```"

#: src/ch02-07-01-00-counter-ui.md:199
msgid ""
"The **`decreaseCounter`** function is designed to interact with a smart "
"contract and decrement a specific counter. Here's a succinct breakdown of its "
"operation:"
msgstr ""
"递减计数器（**`decreaseCounter`** ）函数旨在与智能合约交互，让一个特定的计数器"
"递减。下面是其操作的简要说明："

#: src/ch02-07-01-00-counter-ui.md:201
msgid ""
"Creates a new contract instance by utilizing the provided contract's ABI, its "
"address, and the connected account. The account is vital as this write "
"transaction modifies the contract's state."
msgstr ""
"利用提供的合约 ABI、地址和连接的账户创建新合约实例。账户至关重要，因为该写入事"
"务会修改合约的状态。"

#: src/ch02-07-01-00-counter-ui.md:202
msgid ""
"Initiates the contract's **`decrement`** method. With the use of the "
"**`await`** keyword, the program ensures it waits for the decrement action to "
"finalize."
msgstr ""
"启动合约的 **`decrement`** 方法。使用**`await`**关键字，程序可确保等待递减操作"
"最终完成。"

#: src/ch02-07-01-00-counter-ui.md:203
msgid ""
"Upon successful execution, the user is notified with an alert indicating the "
"counter's decrement."
msgstr "执行成功后，用户会收到计数器递减的提示。"

#: src/ch02-07-01-00-counter-ui.md:204
msgid ""
"Should any errors arise during the interaction, the user is promptly alerted "
"with the pertinent error message."
msgstr "如果在交互过程中出现任何错误，用户会立即收到相关的错误信息提醒。"

#: src/ch02-07-01-00-counter-ui.md:206
msgid "Fetching the Current Count with `get_current_count` Function"
msgstr "使用 `get_current_count` 函数获取当前计数"

#: src/ch02-07-01-00-counter-ui.md:222
msgid ""
"The **`getCounter`** function is designed to retrieve the current count from "
"a smart contract. Here's a breakdown of its operation:"
msgstr ""
"**`getCounter`**函数旨在从智能合约中获取当前计数。下面是该函数的具体操作："

#: src/ch02-07-01-00-counter-ui.md:224
msgid ""
"Establishes a provider instance, specifying the sequencer network – in this "
"instance, it's set to the **`mainnet`** through **`constants.NetworkName."
"SN_MAIN`**."
msgstr ""
"建立提供商实例，指定排序器网络--在本例中，通过**`constants.NetworkName."
"SN_MAIN`**设置为**`mainnet`**。"

#: src/ch02-07-01-00-counter-ui.md:225
msgid ""
"With this provider, it then initiates a contract instance using the provided "
"contract's ABI, its address, and the aforementioned provider."
msgstr ""
"有了这个提供商，它就会使用所提供的合同 ABI、其地址和上述提供商启动一个合同实"
"例。"

#: src/ch02-07-01-00-counter-ui.md:226
msgid ""
"The function then invokes the **`get_current_count`** method of the contract "
"to fetch the current count. This is an asynchronous action, and the program "
"waits for its completion with the **`await`** keyword."
msgstr ""
"然后，函数会调用合约的 **`get_current_count`** 方法来获取当前计数。这是一个异"
"步操作，程序会使用**`await`**关键字等待其完成。"

#: src/ch02-07-01-00-counter-ui.md:227
msgid ""
"Once successfully retrieved, the count, which is presumably a number, is "
"converted to a string and stored using the **`setRetrievedValue`** function."
msgstr ""
"成功检索后，计数（可能是一个数字）将转换为字符串，并使用 "
"**`setRetrievedValue`** 函数进行存储。"

#: src/ch02-07-01-00-counter-ui.md:228
msgid ""
"In the event of any errors during the process, an alert provides the user "
"with the relevant error message."
msgstr "如果过程中出现任何错误，系统会发出警报，向用户提供相关的错误信息。"

#: src/ch02-07-01-00-counter-ui.md:230
msgid ""
"It's essential to emphasize that while performing read operations, like "
"fetching data from a blockchain network, the function uses the provider. "
"Unlike write operations, which typically require a signer (or an account) for "
"transaction signing, read operations don't mandate such authentication. Thus, "
"in this function, only the provider is specified, and not the signer."
msgstr ""
"必须强调的是，在执行读取操作（如从区块链网络中获取数据）时，该功能使用的是提供"
"商。与通常需要签名者（或账户）进行交易签名的写入操作不同，读取操作并不强制要求"
"进行此类身份验证。因此，在该函数中，只指定了提供商，而没有指定签名者。"

#: src/ch02-07-01-00-counter-ui.md:233
msgid "Wrapping It Up: Integrating a Frontend with a Counter Smart Contract"
msgstr "包起来：将前端与计数器智能合约整合在一起"

#: src/ch02-07-01-00-counter-ui.md:235
msgid ""
"In this tutorial, we review the process of integrating a basic counter smart "
"contract with a frontend application."
msgstr "在本教程中，我们将回顾将基本计数器智能合约与前端应用程序集成的过程。"

#: src/ch02-07-01-00-counter-ui.md:237
msgid "Here's a quick recap:"
msgstr "下面是简要回顾："

#: src/ch02-07-01-00-counter-ui.md:239
msgid ""
"**Establishing Connection**: With the **`connectWallet`** function, we made "
"seamless connections to the blockchain, paving the way for interactions with "
"our smart contract."
msgstr ""
"**建立连接**：通过**`connectWallet`**函数，我们与区块链建立了无缝连接，为与我"
"们的智能合约进行交互铺平了道路。"

#: src/ch02-07-01-00-counter-ui.md:240
msgid ""
"**Terminating Connection**: The **`disconnectWallet`** function ensures that "
"users can safely terminate their active connections to the blockchain, "
"maintaining security and control."
msgstr ""
"**终止连接**：**`disconnectWallet`**函数确保用户可以安全地终止与区块链的活动连"
"接，保持安全和控制。"

#: src/ch02-07-01-00-counter-ui.md:241
msgid ""
"**Interacting with the Smart Contract**: Using the **`increaseCounter`**, "
"**`decreaseCounter`**, and **`getCounter`** functions, we explored how to:"
msgstr ""
"**与智能合约交互**：使用**`increaseCounter`**、**`decreaseCounter`**和"
"**`getCounter`**函数，我们探索了如何："

#: src/ch02-07-01-00-counter-ui.md:242
msgid "Initiate transactions"
msgstr "启动交易"

#: src/ch02-07-01-00-counter-ui.md:243
msgid "Adjust the counter value (increment or decrement)"
msgstr "调整计数器数值（递增或递减）"

#: src/ch02-07-01-00-counter-ui.md:244
msgid "Fetch data from the blockchain"
msgstr "从区块链中获取数据"

#: src/ch02-07-01-01-erc20-ui.md:1
msgid "ERC-20 UI"
msgstr "ERC-20 UI"

#: src/ch02-07-01-01-erc20-ui.md:3
msgid ""
"This guide offers steps to build an ERC20 smart contract using Cairo and to "
"incorporate it within a React web application with Starknet React. Readers "
"will:"
msgstr ""
"本指南提供了使用 Cairo 构建 ERC20 智能合约的步骤，并将其纳入使用 Starknet "
"React 的 React Web 应用程序中。读者将："

#: src/ch02-07-01-01-erc20-ui.md:5
msgid "Understand how to implement the ERC20 interface"
msgstr "了解如何实现 ERC20 接口"

#: src/ch02-07-01-01-erc20-ui.md:6
msgid "Learn how to deploy contracts on the Starknet network"
msgstr "了解如何在Starknet网络上部署合约"

#: src/ch02-07-01-01-erc20-ui.md:7
msgid "Discover ways to engage with contracts within a React application"
msgstr "探索在 React 应用中使用合约的方法"

#: src/ch02-07-01-01-erc20-ui.md:8
msgid "Design their own ERC20 token and initiate it on Starknet"
msgstr "设计自己的 ERC20 代币，并在Starknet启动它"

#: src/ch02-07-01-01-erc20-ui.md:10
msgid ""
"A prerequisite for this guide is a foundational understanding of both the "
"Cairo programming language and ReactJS. Additionally, ensure Node.js and NPM "
"are installed on the system."
msgstr ""
"本指南的前提条件是对 Cairo 编程语言和 ReactJS 有基本的了解。此外，确保系统上已"
"安装 Node.js 和 NPM。"

#: src/ch02-07-01-01-erc20-ui.md:12
msgid ""
"The example will walk through creating an ERC20 token named MKT and crafting "
"a web3 interface for functionalities such as balance verification and token "
"transfer."
msgstr ""
"该示例将介绍如何创建一个名为 MKT 的 ERC20 令牌，并为余额验证和令牌转移等功能创"
"建一个 web3 界面。"

#: src/ch02-07-01-01-erc20-ui.md:17
msgid ""
"Throughout this guide, the following tools and libraries will be utilized:"
msgstr "本指南将使用以下工具和库："

#: src/ch02-07-01-01-erc20-ui.md:19
msgid "Scarb 0.7.0 with Cairo 2.2.0"
msgstr "Scarb 0.7.0 与 Cairo 2.2.0"

#: src/ch02-07-01-01-erc20-ui.md:20
msgid "Starkli 0.1.9"
msgstr "Starkli 0.1.9"

#: src/ch02-07-01-01-erc20-ui.md:21
msgid "Oppenzeppelin libraries v0.7.0"
msgstr "Oppenzeppelin libraries v0.7.0"

#: src/ch02-07-01-01-erc20-ui.md:22
msgid "Starknet React v1.0.4"
msgstr "Starknet React v1.0.4"

#: src/ch02-07-01-01-erc20-ui.md:23
msgid "NodeJS v19.6.1"
msgstr "NodeJS v19.6.1"

#: src/ch02-07-01-01-erc20-ui.md:24
msgid "Next.js 13.1.6"
msgstr "Next.js 13.1.6"

#: src/ch02-07-01-01-erc20-ui.md:25
msgid "Visual Studio Code"
msgstr "Visual Studio Code"

#: src/ch02-07-01-01-erc20-ui.md:26
msgid "Vercel"
msgstr "Vercel"

#: src/ch02-07-01-01-erc20-ui.md:28
msgid "Initiating a New Starknet Project"
msgstr "启动新的Starknet项目"

#: src/ch02-07-01-01-erc20-ui.md:30
msgid ""
"Begin by establishing a new Starknet project named \"erc20\" using Scarb:"
msgstr "首先使用 Scarb 建立一个名为 \"erc20 \"的新Starknet项目："

#: src/ch02-07-01-01-erc20-ui.md:38
msgid ""
"Subsequently, update the Scarb.toml to include the essential OpenZeppelin "
"libraries. Post edits, the Scarb.toml should appear as:"
msgstr ""
"随后，更新 Scarb.toml，使其包含 OpenZeppelin 的基本库。编辑完成后，Scarb.toml "
"应显示为："

#: src/ch02-07-01-01-erc20-ui.md:40
msgid ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/"
"reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin-contracts.git\", tag "
"= \"v0.7.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"name = \"erc20\"\n"
"version = \"0.1.0\"\n"
"\n"
"# For more keys and definitions, visit https://docs.swmansion.com/scarb/docs/"
"reference/manifest.html\n"
"\n"
"[dependencies]\n"
"starknet = \">=2.2.0\"\n"
"openzeppelin = { git = \"https://github.com/OpenZeppelin-contracts.git\", tag "
"= \"v0.7.0\" }\n"
"\n"
"[[target.starknet-contract]]\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:54
msgid "Implementing the ERC20 Token"
msgstr "实现 ERC20 token"

#: src/ch02-07-01-01-erc20-ui.md:56
msgid ""
"Begin by creating a new file named `src/erc20.cairo`. In this file, the ERC20 "
"token named MKT, along with its associated functions, will be defined:"
msgstr ""
"首先创建一个名为`src/erc20.cairo`的新文件。在该文件中，将定义名为 MKT 的 "
"ERC20 令牌及其相关函数："

#: src/ch02-07-01-01-erc20-ui.md:99
msgid "Upon completing your contract, proceed to compile it using Scarb:"
msgstr "完成合约后，使用 Scarb 进行编译："

#: src/ch02-07-01-01-erc20-ui.md:105
msgid ""
"Subsequent to the compilation, declare the smart contract on the Starknet "
"testnet:"
msgstr "编译完成后，在Starknet测试网上声明智能合约："

#: src/ch02-07-01-01-erc20-ui.md:112 src/ch02-07-01-01-erc20-ui.md:139
msgid "The output should appear similar to:"
msgstr "输出结果应类似于："

#: src/ch02-07-01-01-erc20-ui.md:121
msgid ""
"In cases where no modifications have been made to the provided contract, a "
"notification will indicate that the contract has previously been declared on "
"Starknet:"
msgstr ""
"如果你没有对所提供的合约进行修改，则会有一个显示该合约之前已在Starknet声明的通"
"知出现："

#: src/ch02-07-01-01-erc20-ui.md:128
msgid "Deploying the ERC20 Contract"
msgstr "部署 ERC20 合约"

#: src/ch02-07-01-01-erc20-ui.md:130
msgid ""
"Proceed to deploy the MKT Token using Starkli. Provide these arguments for "
"successful deployment:"
msgstr "继续使用 Starkli 部署 MKT 令牌。想要成功部署需提供这些参数："

#: src/ch02-07-01-01-erc20-ui.md:132
msgid ""
"`Initial mint`: Mint 1,000,000 tokens. Given that the MKT token comprises 18 "
"decimals (a standard of OpenZeppelin), the input required is 1,000,000 * "
"10^18 or 0xd3c21bcecceda1000000. Due to the contract's expectation of a u256 "
"mint value, provide both low and high values: 0xd3c21bcecceda1000000 and 0 "
"respectively."
msgstr ""
"`Initial mint`: 铸造 1,000,000 个代币。鉴于 MKT 代币包含 18 位小数"
"（OpenZeppelin 的标准），所需的输入值为 1,000,000 * 10^18 或 "
"0xd3c21bcecceda1000000。由于合约期望的初始铸造数值是一个 u256 类型的值，因此需"
"要同时提供低值和高值：分别为 0xd3c21bcecceda1000000 和 0。"

#: src/ch02-07-01-01-erc20-ui.md:133
msgid ""
"`Receiver address`: Use a preferred address. In this example: "
"0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"
msgstr ""
"`Receiver address`: 使用首选地址。例如："
"0x0334863e3e851de87fb4b6b6113aa2a6b40ea20f22dbec55536e4eac912206fc"

#: src/ch02-07-01-01-erc20-ui.md:147
msgid ""
"NOTE: The deployed address received will differ for every user. Retain this "
"address, as it will replace instances in subsequent TypeScript files to match "
"the specific contract address."
msgstr ""
"注意：每个用户收到的部署地址都不同。请保留此地址，因为它将替换后续 TypeScript "
"文件中的实例，以匹配特定的合约地址。"

#: src/ch02-07-01-01-erc20-ui.md:149
msgid ""
"Well done! The Cairo ERC20 smart contract has been deployed successfully on "
"Starknet."
msgstr "干得漂亮！Cairo ERC20 智能合约已在Starknet成功部署。"

#: src/ch02-07-01-01-erc20-ui.md:151
#, fuzzy
msgid "Installing the Starknet React Library"
msgstr "安装 Starknet React 库"

#: src/ch02-07-01-01-erc20-ui.md:153
#, fuzzy
msgid ""
"With the contract in place, initiate the development of the web application. "
"Begin by incorporating the Starknet React library:"
msgstr "签订合约后，开始开发网络应用程序。首先纳入 Starknet React 库："

#: src/ch02-07-01-01-erc20-ui.md:159
#, fuzzy
msgid "Post-installation, confirm the version of the Starknet React library:"
msgstr "安装后，确认 Starknet React 库的版本："

#: src/ch02-07-01-01-erc20-ui.md:165
#, fuzzy
msgid ""
"The output should display the installed version, such as `@starknet-react/"
"core@1.0.4`."
msgstr "输出结果应显示已安装的版本，如 `@starknet-react/core@1.0.4`。"

#: src/ch02-07-01-01-erc20-ui.md:167
#, fuzzy
msgid "Setting Up a New React Project"
msgstr "设置新的 React 项目"

#: src/ch02-07-01-01-erc20-ui.md:169
#, fuzzy
msgid ""
"Starknet React library provides the `create-starknet` script that streamlines "
"the setup of a Starknet application using TypeScript:"
msgstr ""
"Starknet React 库提供了 \"create-starknet \"脚本，可使用 TypeScript 简化 "
"Starknet 应用程序的设置："

#: src/ch02-07-01-01-erc20-ui.md:175
#, fuzzy
msgid ""
"Once set up, make modifications to `erc20_web/index.tsx` by replacing its "
"content with the following code:"
msgstr ""
"设置完成后，用以下代码替换 `erc20_web/index.tsx` 中的内容，对其进行修改："

#: src/ch02-07-01-01-erc20-ui.md:177
#, fuzzy
msgid ""
"```typescript\n"
"import Head from 'next/head'\n"
"import { useBlock } from '@starknet-react/core'\n"
"import WalletBar from '../components/WalletBar'\n"
"import { BlockTag } from 'starknet';\n"
"\n"
"export default function Home() {\n"
"  const { data, isLoading, isError } = useBlock({\n"
"    refetchInterval: 3000,\n"
"    blockIdentifier: BlockTag.latest,\n"
"  })\n"
"  return (\n"
"    <>\n"
"      <Head>\n"
"        <title>Create Starknet</title>\n"
"        <meta name=\"description\" content=\"Generated by create-starknet\" /"
">\n"
"        <meta name=\"viewport\" content=\"width=device-width, initial-"
"scale=1\" />\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"        <p>\n"
"          A basic web3 example with Starknet&nbsp;\n"
"        </p>\n"
"        <div>\n"
"          {isLoading\n"
"            ? 'Loading...'\n"
"            : isError\n"
"            ? 'Error while fetching the latest block hash'\n"
"            : `Latest block hash: ${data?.block_hash}`}\n"
"        </div>\n"
"        <WalletBar />\n"
"      </main>\n"
"    </>\n"
"  )\n"
"}\n"
"```"
msgstr ""
"```typescript\n"
"从'next/head'导入 Head\n"
"从'@starknet-react/core'导入 { useBlock }\n"
"从'.../components/WalletBar'导入 WalletBar\n"
"import { BlockTag } from 'starknet'；\n"
"\n"
"导出默认函数 Home() {\n"
"  const { data, isLoading, isError } = useBlock({\n"
"    refetchInterval：3000,\n"
"    blockIdentifier：blockTag.latest、\n"
"  })\n"
"  返回 (\n"
"    &lt;&gt;\n"
"      <Head>\n"
"        <title>创建Starknet</title>\n"
"        <meta name=\"description\" content=\"Generated by create-starknet\" /"
">\n"
"        <meta name=\"viewport\" content=\"width=device-width, initial-"
"scale=1\" />\n"
"        <link rel=\"icon\" href=\"/favicon.ico\" />\n"
"      </Head>\n"
"      <main>\n"
"        <p>\n"
"          使用Starknet的基本 web3 示例 \n"
"        </p>\n"
"        <div>\n"
"          {isLoading\n"
"            ?正在加载...\n"
"            : isError\n"
"            ?获取最新区块散列时出错\n"
"            : `最新区块哈希值：${data?.block_hash}`}\n"
"        </div>\n"
"        <WalletBar />\n"
"      </main>\n"
"    &lt;/&gt;\n"
"  )\n"
"}\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:214
#, fuzzy
msgid "To launch the web3 application:"
msgstr "启动 web3 应用程序："

#: src/ch02-07-01-01-erc20-ui.md:221
#, fuzzy
msgid ""
"NOTE: Observe the server port that appears during launch. This will be useful "
"for subsequent testing."
msgstr "注意：观察启动过程中出现的服务器端口。这将有助于后续测试。"

#: src/ch02-07-01-01-erc20-ui.md:224
#, fuzzy
msgid "Enhancing Your React Application with Additional Features"
msgstr "利用附加功能增强 React 应用程序"

#: src/ch02-07-01-01-erc20-ui.md:226
#, fuzzy
msgid ""
"To enhance the app's functionality, create two components for balance and "
"transfer. Subsequently, update the `Wallet.tsx` file to incorporate the new "
"features:"
msgstr ""
"为增强应用程序的功能，创建余额和转账两个组件。随后，更新 `Wallet.tsx` 文件以纳"
"入新功能："

#: src/ch02-07-01-01-erc20-ui.md:231
#, fuzzy
msgid "Balance Component"
msgstr "余额部分"

#: src/ch02-07-01-01-erc20-ui.md:232
#, fuzzy
msgid ""
"Design a balance component inside `components/Balance.tsx` and integrate the "
"following code:"
msgstr "在 `components/Balance.tsx` 中设计一个平衡组件，并整合以下代码："

#: src/ch02-07-01-01-erc20-ui.md:234
#, fuzzy
msgid ""
"```typescript\n"
"import { useAccount, useContractRead } from \"@starknet-react/core\";\n"
"import erc20ABI from '../assets/erc20.json';\n"
"\n"
"function Balance() {\n"
"  const { address } = useAccount();\n"
"  const { data, isLoading, error, refetch } = useContractRead({\n"
"    address: "
"'0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"    abi: erc20ABI,\n"
"    functionName: 'balance_of',\n"
"    args: [address],\n"
"    watch: false\n"
"  });\n"
"\n"
"  if (isLoading) return <span>Loading...</span>;\n"
"  if (error) return <span>Error: {JSON.stringify(error)}</span>;\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>Balance:</p>\n"
"      <p>{data?data.toString(): 0}</p>\n"
"      <p><button onClick={refetch}>Refresh Balance</button></p>\n"
"      <hr/>\n"
"    </div>\n"
"  );\n"
"}\n"
"  \n"
"export default Balance;\n"
"```"
msgstr ""
"```类型脚本\n"
"import { useAccount, useContractRead } from \"@starknet-react/core\"；\n"
"从'../assets/erc20.json'导入 erc20ABI；\n"
"\n"
"函数 Balance() {\n"
"  const { address }= useAccount()；\n"
"  const { data, isLoading, error, refetch }= useContractRead({\n"
"    地"
"址'0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"    abi: erc20ABI、\n"
"    functionName：balance_of'、\n"
"    args: [address]、\n"
"    watch: false\n"
"  });\n"
"\n"
"  if (isLoading) 返回<span>正在加载</span>.....；\n"
"  if (error) return<span>Error:{JSON.stringify(error)}</span> ；\n"
"\n"
"  return (\n"
"    <div>\n"
"      <p>余额：</p>\n"
"      <p>{data?data.toString()：0}</p>\n"
"      <p>&lt;button onClick={refetch}&gt;刷新余额</button></p>\n"
"      <hr/>\n"
"    </div>\n"
"  );\n"
"}\n"
"  \n"
"export default Balance；\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:264
#, fuzzy
msgid "NOTE: Replace the address with the address of your deployed contract."
msgstr "注意：请将地址替换为已部署合约的地址。"

#: src/ch02-07-01-01-erc20-ui.md:266
#, fuzzy
msgid "Transfer Component"
msgstr "转移部分"

#: src/ch02-07-01-01-erc20-ui.md:268
#, fuzzy
msgid ""
"Craft a transfer component in `components/Transfer.tsx` and embed the "
"subsequent code:"
msgstr "在 `components/Transfer.tsx` 中制作一个传输组件，并嵌入后续代码："

#: src/ch02-07-01-01-erc20-ui.md:270
#, fuzzy
msgid ""
"```typescript\n"
"import { useAccount, useContractWrite } from \"@starknet-react/core\";\n"
"import React, { useState, useMemo } from \"react\";\n"
"\n"
"function Transfer() {\n"
"    const { address } = useAccount();\n"
"    const [count] = useState(1);\n"
"    const [recipient, setRecipient] = useState('0x');\n"
"    const [amount, setAmount] = useState('1000000000000000000');\n"
"  \n"
"    const calls = useMemo(() => {\n"
"      const tx = {\n"
"        contractAddress: "
"'0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"        entrypoint: 'transfer',\n"
"        calldata: [recipient, amount, 0]\n"
"      };\n"
"      return Array(count).fill(tx);\n"
"    }, [address, count, recipient, amount]);\n"
"\n"
"    const { write } = useContractWrite({ calls });\n"
"  \n"
"    return (\n"
"      <>\n"
"        <p>Transfer:</p>\n"
"        <p>\n"
"          Recipient:\n"
"          <input type=\"text\" value={recipient} onChange={(e) => "
"setRecipient(e.target.value)} />\n"
"        </p>\n"
"        <p>\n"
"          Amount (default: 1 MKT with 18 decimals):\n"
"          <input type=\"number\" value={amount} onChange={(e) => setAmount(e."
"target.value)} />\n"
"        </p>\n"
"        <p><button onClick={() => write()}>Execute Transfer</button></p>\n"
"        <hr/>\n"
"      </>\n"
"    );\n"
"}\n"
"\n"
"export default Transfer;\n"
"```"
msgstr ""
"```类型脚本\n"
"import { useAccount, useContractWrite } from \"@starknet-react/core\"；\n"
"import React, { useState, useMemo } from \"react\"；\n"
"\n"
"函数 Transfer() {\n"
"    const { address }= useAccount()；\n"
"    const [count] = useState(1)；\n"
"    const [recipient, setRecipient] = useState('0x')；\n"
"    const [amount, setAmount] = useState('1000000000000000000')；\n"
"  \n"
"    const calls = useMemo(() =&gt; {\n"
"      const tx = {\n"
"        contractAddress：'0x001892d81e09cb2c2005f0112891dacb92a6f8ce571edd03ed1f3e549abcf37f',\n"
"        entrypoint: 'transfer'、\n"
"        calldata：[收件人、金额、0］\n"
"      };\n"
"      return Array(count).fill(tx)；\n"
"    }, [address, count, recipient, amount])；\n"
"\n"
"    const { write }= useContractWrite({ calls })；\n"
"  \n"
"    返回 (\n"
"      &lt;&gt;\n"
"       <p>转移：</p>\n"
"       <p>\n"
"          收件人：\n"
"          &lt;input type=\"text\" value={recipient} onChange={(e) =&gt; "
"setRecipient(e.target.value)} /&gt;\n"
"       </p>\n"
"       <p>\n"
"          金额（默认：1 MKT，18 位小数）：\n"
"          &lt;input type=\"number\" value={amount} onChange={(e) =&gt; "
"setAmount(e.target.value)} /&gt; 金额（默认值：1 MKT，18 位小数\n"
"       </p>\n"
"        <p><button onClick={() =>write()}&gt; 执行转账</button></p>\n"
"       <hr/>\n"
"      &lt;/&gt;\n"
"    );\n"
"}\n"
"\n"
"export default Transfer；\n"
"```"

#: src/ch02-07-01-01-erc20-ui.md:311
#, fuzzy
msgid ""
"NOTE: Replace contractAddress with the address of your deployed contract."
msgstr "注意：将 contractAddress 替换为已部署合约的地址。"

#: src/ch02-07-01-01-erc20-ui.md:314
#, fuzzy
msgid "Updating the Wallet Component"
msgstr "更新钱包组件"

#: src/ch02-07-01-01-erc20-ui.md:316
#, fuzzy
msgid ""
"Proceed to modify the `components/Wallet.tsx` file. Replace any existing "
"content with the following enhanced code:"
msgstr "继续修改 `components/Wallet.tsx` 文件。用以下增强代码替换任何现有内容："

#: src/ch02-07-01-01-erc20-ui.md:368
#, fuzzy
msgid ""
"This updated code refines the Wallet component to offer a more interactive "
"experience for users intending to connect or manage their wallets."
msgstr ""
"更新后的代码完善了钱包组件，为打算连接或管理钱包的用户提供了交互性更强的体验。"

#: src/ch02-07-01-01-erc20-ui.md:371
#, fuzzy
msgid "Finalizing the MKT Token Application"
msgstr "完成 MKT 令牌申请"

#: src/ch02-07-01-01-erc20-ui.md:373
#, fuzzy
msgid ""
"To finalize the application setup, we need the ABI file for the MKT token. "
"Follow the steps below to generate and integrate it:"
msgstr ""
"要完成应用程序设置，我们需要 MKT 令牌的 ABI 文件。请按照以下步骤生成并集成该文"
"件："

#: src/ch02-07-01-01-erc20-ui.md:375
#, fuzzy
msgid "At the root of your project, create a new directory named `assets/`."
msgstr "在项目根目录下新建一个名为 `assets/` 的目录。"

#: src/ch02-07-01-01-erc20-ui.md:376
#, fuzzy
msgid ""
"Inside the `assets/` directory, create an empty JSON file named `erc20.json`."
msgstr "在 `assets/` 目录中，创建一个名为 `erc20.json` 的空 JSON 文件。"

#: src/ch02-07-01-01-erc20-ui.md:377
#, fuzzy
msgid ""
"Go back to your ERC20 Cairo project folder and locate the `erc20/target/"
"erc20_erc20_sierra.json` file."
msgstr ""
"返回 ERC20 Cairo 项目文件夹，找到 `erc20/target/erc20_erc20_sierra.json` 文"
"件。"

#: src/ch02-07-01-01-erc20-ui.md:381
#, fuzzy
msgid ""
"Extract the ABI definition (ensuring you include the square brackets) and "
"integrate it into the previously created `assets/erc20.json` file."
msgstr ""
"提取 ABI 定义（确保包含方括号）并将其整合到之前创建的 `assets/erc20.json` 文件"
"中。"

#: src/ch02-07-01-01-erc20-ui.md:385
#, fuzzy
msgid ""
"Well done! The basic MKT token application is now operational locally. Access "
"it via `http://localhost:3000` or the port noted from earlier server setup. "
"The app allows users to connect their wallets, review their balances, and "
"perform token transfers."
msgstr ""
"做得好！基本的 MKT 令牌应用程序现已在本地运行。请通过 \"http://localhost:3000 "
"\"或先前服务器设置中指出的端口访问该应用程序。该应用程序允许用户连接自己的钱"
"包、查看余额和执行令牌转账。"

#: src/ch02-07-01-01-erc20-ui.md:390
#, fuzzy
msgid "Deploying Your Project Online"
msgstr "在线部署项目"

#: src/ch02-07-01-01-erc20-ui.md:392
#, fuzzy
msgid ""
"To share your application with friends and allow them to check their balances "
"and transfer tokens, publish your app online. Vercel offers a straightforward "
"way to do this:"
msgstr ""
"要与朋友分享您的应用程序，并允许他们查看余额和转移代币，请在线发布您的应用程"
"序。Vercel 提供了一种简单易行的方法："

#: src/ch02-07-01-01-erc20-ui.md:394
#, fuzzy
msgid "Set Up Vercel"
msgstr "设置 Vercel"

#: src/ch02-07-01-01-erc20-ui.md:396
#, fuzzy
msgid "Register for an account at [Vercel Signup](https://vercel.com/signup)."
msgstr "在 [Vercel Signup](https://vercel.com/signup) 上注册账户。"

#: src/ch02-07-01-01-erc20-ui.md:397
#, fuzzy
msgid "Install Vercel in your web application folder (`erc20_web`):"
msgstr "在网络应用程序文件夹 (`erc20_web`) 中安装 Vercel："

#: src/ch02-07-01-01-erc20-ui.md:405
#, fuzzy
msgid "Authenticate your Vercel account:"
msgstr "验证您的 Vercel 账户："

#: src/ch02-07-01-01-erc20-ui.md:411
#, fuzzy
msgid ""
"After entering your email, check your inbox and click on the \"Verify\" "
"button."
msgstr "输入电子邮件后，检查收件箱并点击 \"验证 \"按钮。"

#: src/ch02-07-01-01-erc20-ui.md:418
#, fuzzy
msgid ""
"On successful verification, you'll receive a confirmation in the console."
msgstr "验证成功后，您将在控制台中收到确认信息。"

#: src/ch02-07-01-01-erc20-ui.md:420
#, fuzzy
msgid "Link your project to Vercel:"
msgstr "将您的项目链接到 Vercel："

#: src/ch02-07-01-01-erc20-ui.md:426
#, fuzzy
msgid "Upload it:"
msgstr "上传："

#: src/ch02-07-01-01-erc20-ui.md:432
#, fuzzy
msgid "Publish your project:"
msgstr "发布您的项目："

#: src/ch02-07-01-01-erc20-ui.md:438
#, fuzzy
msgid ""
"Congratulations! Your MKT token web3 application is now accessible to "
"everyone."
msgstr "恭喜您！现在所有人都可以访问您的 MKT 令牌 web3 应用程序了。"

#: src/ch02-07-01-01-erc20-ui.md:442
#, fuzzy
msgid "Engage with your app by:"
msgstr "通过以下方式与您的应用程序互动"

#: src/ch02-07-01-01-erc20-ui.md:444
#, fuzzy
msgid "Connecting your wallet:"
msgstr "连接您的钱包"

#: src/ch02-07-01-01-erc20-ui.md:448
#, fuzzy
msgid "Checking your balance:"
msgstr "查看余额"

#: src/ch02-07-01-01-erc20-ui.md:452
#, fuzzy
msgid "Transferring tokens:"
msgstr "转让代币："

#: src/ch02-07-01-01-erc20-ui.md:456
#, fuzzy
msgid "Wrapping Up"
msgstr "总结"

#: src/ch02-07-01-01-erc20-ui.md:458
#, fuzzy
msgid ""
"Throughout this tutorial, you've walked through the steps to craft a web3 "
"application using React and Starknet Cairo. This application, complete with "
"an ERC20 smart contract, offers a modern web interface for user interaction. "
"Here's a snapshot of your achievements:"
msgstr ""
"在本教程中，您将学习使用 React 和 Starknet Cairo 制作 Web3 应用程序的步骤。这"
"个应用程序包含一个 ERC20 智能合约，为用户交互提供了一个现代化的 Web 界面。下面"
"是您的成果快照："

#: src/ch02-07-01-01-erc20-ui.md:460
#, fuzzy
msgid ""
"**Project Initialization**: Set up a Starknet project with Scarb and "
"incorporated OpenZeppelin libraries."
msgstr "**项目初始化**：使用 Scarb 和 OpenZeppelin 库建立Starknet项目。"

#: src/ch02-07-01-01-erc20-ui.md:462
#, fuzzy
msgid ""
"**Crafting the ERC20 Contract**: Developed an ERC20 token using Cairo, "
"enriched with functionalities like balance checks and token transfers. This "
"was then compiled and launched on the Starknet network."
msgstr ""
"**起草 ERC20 合约**：使用Cairo开发了一种 ERC20 代币，并丰富了余额检查和代币转"
"账等功能。然后对其进行编译，并在Starknet（Starknet）网络上发布。"

#: src/ch02-07-01-01-erc20-ui.md:464
#, fuzzy
msgid ""
"**React Application**: Built a React application powered by Starknet React, "
"featuring components dedicated to balance inquiries and token transactions."
msgstr ""
"**React 应用程序**：构建了一个由 Starknet React 支持的 React 应用程序，其中包"
"含专门用于余额查询和代币交易的组件。"

#: src/ch02-07-01-01-erc20-ui.md:466
#, fuzzy
msgid ""
"**ABI Creation**: Produced the ABI for the MKT token, a critical component to "
"liaise with the contract."
msgstr "**ABI 创建**：为 MKT 令牌制作 ABI，这是联络合约的关键部分。"

#: src/ch02-07-01-01-erc20-ui.md:468
#, fuzzy
msgid ""
"**Online Deployment**: Brought your application to a wider audience by "
"deploying it on Vercel. This empowered users to connect their wallets, "
"scrutinize their balances, and execute token transactions."
msgstr ""
"**在线部署**：通过在 Vercel 上部署，将您的应用程序带给更多用户。这样，用户就可"
"以连接他们的钱包，仔细检查他们的余额，并执行代币交易。"

#: src/ch02-07-01-01-erc20-ui.md:470
#, fuzzy
msgid ""
"The insights you've gathered from this tutorial lay a solid groundwork for "
"creating intricate web3 applications. You're now equipped with the prowess to "
"craft more intricate decentralized applications and smart contracts. The vast "
"expanse of decentralized finance and blockchain is ripe for your innovative "
"inputs. Dive in and happy coding!"
msgstr ""
"通过本教程的学习，您将为创建复杂的 Web3 应用程序打下坚实的基础。现在，您已经具"
"备了制作更复杂的去中心化应用程序和智能合约的能力。去中心化金融和区块链的广阔天"
"地正等着你的创新投入。投入其中，快乐编码！"

#: src/ch02-07-01-02-million-dollar-homepage.md:1
#, fuzzy
msgid "Million Dollar Homepage"
msgstr "百万美元主页"

#: src/ch02-07-01-02-million-dollar-homepage.md:3
#, fuzzy
msgid ""
"[Starknet Homepage](https://github.com/dbejarano820/starknet_homepage) is a "
"decentralized application on the Starknet blockchain. It provides a virtual "
"space where users can claim and personalize sections of a 100x100 grid, known "
"as \"Starknet Homepage\". Each section is a 10x10 pixel area. Users can "
"acquire these sections by minting non-fungible tokens (NFTs) and then "
"personalizing them with images and other content."
msgstr ""
"[Starknet主页](https://github.com/dbejarano820/starknet_homepage) 是Starknet区"
"块链上的一个去中心化应用程序。它为用户提供了一个虚拟空间，用户可以在这个 "
"100x100 网格（即 \"Starknet主页\"）上申请并个性化自己的部分。每个区域为 10x10 "
"像素。用户可以通过铸造不可兑换代币（NFT）获得这些区域，然后用图片和其他内容对"
"其进行个性化设置。"

#: src/ch02-07-01-02-million-dollar-homepage.md:5
#, fuzzy
msgid ""
"View the live app on testnet [here](https://starknet-homepage-kappa.vercel."
"app/)."
msgstr ""
"在 testnet [此处](https://starknet-homepage-kappa.vercel.app/) 上查看实时应用"
"程序。"

#: src/ch02-07-01-02-million-dollar-homepage.md:9
#, fuzzy
msgid ""
"This initiative is an adaptation of the renowned Million Dollar Homepage and "
"was conceived at the Starknet Summit 2023 Hacker House in Palo Alto, "
"California. The following is a guide to understanding how this project was "
"developed using the available tools in the ecosystem."
msgstr ""
"该项目是对著名的 \"百万美元主页\"（Million Dollar Homepage）的改编，是在加利福"
"尼亚州帕洛阿尔托的 \"Starknet峰会 2023 创客之家\"（Starknet Summit 2023 "
"Hacker House）上构思的。下面的内容将帮助你了解这个项目是如何利用生态系统中的可"
"用工具开发出来的。"

#: src/ch02-07-01-02-million-dollar-homepage.md:11
#, fuzzy
msgid "Tools Utilized:"
msgstr "使用的工具"

#: src/ch02-07-01-02-million-dollar-homepage.md:13
#, fuzzy
msgid "[Starknet-react](https://github.com/apibara/starknet-react)"
msgstr "[Starknet反应](https://github.com/apibara/starknet-react)"

#: src/ch02-07-01-02-million-dollar-homepage.md:14
#, fuzzy
msgid "[Starknet.js](https://github.com/0xs34n/starknet.js)"
msgstr "[Starknet.js](https://github.com/0xs34n/starknet.js)"

#: src/ch02-07-01-02-million-dollar-homepage.md:15
#, fuzzy
msgid ""
"[OpenZeppelin Cairo Contracts](https://github.com/OpenZeppelin/cairo-"
"contracts)"
msgstr ""
"[OpenZeppelinCairo合约](https://github.com/OpenZeppelin/cairo-contracts)"

#: src/ch02-07-01-02-million-dollar-homepage.md:16
#, fuzzy
msgid "[MaterialUI](https://mui.com/material-ui/)"
msgstr "[MaterialUI](https://mui.com/material-ui/)"

#: src/ch02-07-01-02-million-dollar-homepage.md:18
msgid "Initial Setup"
msgstr "初始设置步骤"

#: src/ch02-07-01-02-million-dollar-homepage.md:20
#, fuzzy
msgid ""
"The `Starknet-react` app offers a command to initialize a Starknet app. This "
"command sets up the foundational structure needed for a NextJS application."
msgstr ""
"Starknet-react \"应用程序提供了一个用于初始化 Starknet 应用程序的命令。该命令"
"设置了 NextJS 应用程序所需的基础结构。"

#: src/ch02-07-01-02-million-dollar-homepage.md:26
#, fuzzy
msgid ""
"The `StarknetConfig` component accepts a `connectors` prop, which defines "
"wallet connection options for the user. Additionally, it can take a "
"`defaultProvider` to set the network the application should connect to by "
"default."
msgstr ""
"StarknetConfig \"组件接受一个 \"connectors \"道具，为用户定义钱包连接选项。此"
"外，它还可以接受一个 `defaultProvider` 来设置应用程序默认应连接的网络。"

#: src/ch02-07-01-02-million-dollar-homepage.md:28
#, fuzzy
msgid ""
"```javascript\n"
"const connectors = [\n"
"  new InjectedConnector({ options: { id: \"braavos\" } }),\n"
"  new InjectedConnector({ options: { id: \"argentX\" } }),\n"
"];\n"
"const provider = new Provider({\n"
"  sequencer: { network: constants.NetworkName.SN_GOERLI },\n"
"});\n"
"return (\n"
"  <StarknetConfig\n"
"    autoConnect\n"
"    defaultProvider={provider}\n"
"    connectors={connectors}\n"
"  >\n"
"    <CacheProvider value={emotionCache}>\n"
"      <ThemeProvider theme={theme}>\n"
"        <Component {...pageProps} />\n"
"      </ThemeProvider>\n"
"    </CacheProvider>\n"
"  </StarknetConfig>\n"
");\n"
"```"
msgstr ""
"```javascript\n"
"连接器 = [\n"
"  new InjectedConnector({ options: { id: \"braavos\" })、\n"
"  new InjectedConnector({ options: { id: \"argentX\" })、\n"
"];\n"
"const provider = new Provider({\n"
"  sequencer：{network: constants.NetworkName.SN_GOERLI }、\n"
"});\n"
"返回 (\n"
"  &lt;StarknetConfig\n"
"    自动连接\n"
"    defaultProvider={provider}\n"
"    连接器{connectors}\n"
"  &gt;\n"
"    &lt;CacheProvider value={emotionCache}&gt;\n"
"      &lt;ThemeProvider theme={theme}&gt;\n"
"        &lt;Component{...pageProps} /&gt;\n"
"     </ThemeProvider>\n"
"    </CacheProvider>\n"
"  </StarknetConfig>\n"
");\n"
"```"

#: src/ch02-07-01-02-million-dollar-homepage.md:51
#, fuzzy
msgid ""
"Both `CacheProvider` and `ThemeProvider` are components that facilitate the "
"seamless integration of MaterialUI with NextJS. For a comprehensive setup "
"guide on these components, please refer to [this link](https://blog.logrocket."
"com/getting-started-with-mui-and-next-js/)."
msgstr ""
"CacheProvider \"和 \"ThemeProvider \"都是促进 MaterialUI 与 NextJS 无缝集成的"
"组件。有关这些组件的全面设置指南，请参阅 [this link](https://blog.logrocket."
"com/getting-started-with-mui-and-next-js/)。"

#: src/ch02-07-01-02-million-dollar-homepage.md:53
#, fuzzy
msgid "Main Functionality"
msgstr "主要功能"

#: src/ch02-07-01-02-million-dollar-homepage.md:55
#, fuzzy
msgid ""
"The core functionality of the Starknet Homepage centers around selecting a 4-"
"sided region on a matrix, representing the desired 10x10 cells, and minting a "
"token based on those cells. The responsibility of the smart contract is to "
"validate whether the selected cells are available for minting. If a user owns "
"Starknet Homepage tokens, they can access a dropdown to modify the token's "
"content, including the associated image and link on the grid."
msgstr ""
"Starknet Homepage 的核心功能是在矩阵上选择一个四边形区域（代表所需的 10x10 单"
"元），并根据这些单元铸造代币。智能合约的职责是验证所选单元格是否可用于铸币。如"
"果用户拥有Starknet主页代币，就可以访问下拉菜单来修改代币的内容，包括网格上的相"
"关图片和链接。"

#: src/ch02-07-01-02-million-dollar-homepage.md:57
#, fuzzy
msgid "The app's primary requirements are:"
msgstr "该应用程序的主要要求是"

#: src/ch02-07-01-02-million-dollar-homepage.md:59
#, fuzzy
msgid "Wallet connectivity"
msgstr "钱包连接"

#: src/ch02-07-01-02-million-dollar-homepage.md:60
#, fuzzy
msgid "Grid for displaying existing tokens"
msgstr "用于显示现有代币的网格"

#: src/ch02-07-01-02-million-dollar-homepage.md:61
#, fuzzy
msgid "Cell selection capability"
msgstr "细胞选择能力"

#: src/ch02-07-01-02-million-dollar-homepage.md:62
#, fuzzy
msgid "Multicall function for token approval and minting"
msgstr "用于代币审批和铸币的多重呼叫功能"

#: src/ch02-07-01-02-million-dollar-homepage.md:63
#, fuzzy
msgid "Dropdown to view owned tokens"
msgstr "下拉菜单可查看拥有的代币"

#: src/ch02-07-01-02-million-dollar-homepage.md:64
#, fuzzy
msgid "On-chain representation of the entire 1 million pixel grid"
msgstr "整个 100 万像素网格的链上表示法"

#: src/ch02-07-01-02-million-dollar-homepage.md:66
#, fuzzy
msgid ""
"A significant aspect to consider is the string limitation in Cairo contracts. "
"To store links of varying sizes, they are stored as arrays of `felt252`s. The "
"contract uses the following logic for this purpose:"
msgstr ""
"需要考虑的一个重要方面是 Cairo 合约中的字符串限制。为了存储不同大小的链接，它"
"们被存储为 \"felt252 \"数组。为此，合约使用了以下逻辑："

#: src/ch02-07-01-02-million-dollar-homepage.md:68
#, fuzzy
msgid ""
"```rust\n"
"impl StoreFelt252Array of Store<Array<felt252>> {\n"
"    fn read(address_domain: u32, base: StorageBaseAddress) -> "
"SyscallResult<Array<felt252>> {\n"
"        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
"    }\n"
"    fn write(\n"
"        address_domain: u32, base: StorageBaseAddress, value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
"    }\n"
"    fn read_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8\n"
"    ) -> SyscallResult<Array<felt252>> {\n"
"        let mut arr: Array<felt252> = ArrayTrait::new();\n"
"        // Read the stored array's length. If the length is superior to 255, "
"the read will fail.\n"
"        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, "
"offset)\n"
"            .expect('Storage Span too large');\n"
"\n"
"        offset += 1;\n"
"\n"
"        // Sequentially read all stored elements and append them to the "
"array.\n"
"        let exit = len + offset;\n"
"        loop {\n"
"            if offset >= exit {\n"
"                break;\n"
"            }\n"
"            let value = Store::<felt252>::read_at_offset(address_domain, "
"base, offset).unwrap();\n"
"            arr.append(value);\n"
"            offset += Store::<felt252>::size();\n"
"        };\n"
"        Result::Ok(arr)\n"
"    }\n"
"    fn write_at_offset(\n"
"        address_domain: u32, base: StorageBaseAddress, mut offset: u8, mut "
"value: Array<felt252>\n"
"    ) -> SyscallResult<()> {\n"
"        // // Store the length of the array in the first storage slot. 255 of "
"elements is max\n"
"        let len: u8 = value.len().try_into().expect('Storage - Span too "
"large');\n"
"        Store::<u8>::write_at_offset(address_domain, base, offset, len);\n"
"        offset += 1;\n"
"        // Store the array elements sequentially\n"
"        loop {\n"
"            match value.pop_front() {\n"
"                Option::Some(element) => {\n"
"                    Store::<felt252>::write_at_offset(address_domain, base, "
"offset, element);\n"
"                    offset += Store::<felt252>::size();\n"
"                },\n"
"                Option::None => {\n"
"                    break Result::Ok(());\n"
"                }\n"
"            };\n"
"        }\n"
"    }\n"
"    fn size() -> u8 {\n"
"        255 / Store::<felt252>::size()\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```信任\n"
"impl StoreFelt252Array of Store&lt;Array<felt252>&gt; {\n"
"    fn read(address_domain: u32, base: StorageBaseAddress) -&gt; "
"SyscallResult&lt;Array<felt252>&gt; {\n"
"        StoreFelt252Array::read_at_offset(address_domain, base, 0)\n"
"    }\n"
"    fn write(\n"
"        address_domain: u32, base：storeBaseAddress, value：数组<felt252>\n"
"    ) -&gt; SyscallResult<()> {\n"
"        StoreFelt252Array::write_at_offset(address_domain, base, 0, value)\n"
"    }\n"
"    fn read_at_offset(\n"
"        address_domain: u32, base：存储基地址，mut 偏移量：u8\n"
"    ) -&gt; SyscallResult&lt;Array<felt252>&gt; {\n"
"        让 mut arr：Array<felt252> = ArrayTrait::new()；\n"
"        // 读取存储数组的长度。如果长度大于 255，读取将失败。\n"
"        let len: u8 = Store::<u8>::read_at_offset(address_domain, base, "
"offset)\n"
"            .expect('Storage Span too large')；\n"
"\n"
"        offset += 1；\n"
"\n"
"        // 依次读取所有存储元素并将其追加到数组中。\n"
"        让 exit = len + offset；\n"
"        循环 {\n"
"            if offset &gt;= exit {\n"
"                break；\n"
"            }\n"
"            let value = Store::<felt252>::read_at_offset(address_domain, "
"base, offset).unwrap()；\n"
"            arr.append(value)；\n"
"            offset += Store::<felt252>::size()；\n"
"        };\n"
"        Result::Ok(arr)\n"
"    }\n"
"    fn write_at_offset(\n"
"        address_domain: u32, base：存储基地址，mut 偏移量：u8，mut 值：数组"
"<felt252>\n"
"    ) -&gt; SyscallResult<()> {\n"
"        // // 在第一个存储槽中存储数组的长度。255 个元素为最大值\n"
"        let len: u8 = value.len().try_into().expect('Storage - Span too "
"large')；\n"
"        存储::<u8>::write_at_offset(address_domain, base, offset, len)；\n"
"        offset += 1；\n"
"        // 按顺序存储数组元素\n"
"        循环 {\n"
"            匹配 value.pop_front() {\n"
"                选项::Some(元素) =&gt; {\n"
"                    Store::<felt252>::write_at_offset(address_domain, base, "
"offset, element)；\n"
"                    offset += Store::<felt252>::size()；\n"
"                },\n"
"                选项::无 =&gt; {\n"
"                    break Result::Ok(())；\n"
"                }\n"
"            };\n"
"        }\n"
"    }\n"
"    fn size() -&gt; u8 {\n"
"        255 / 存储::<felt252>::size()\n"
"    }\n"
"}\n"
"```"

#: src/ch02-07-01-02-million-dollar-homepage.md:126
#, fuzzy
msgid "The storage method for links in the contract state is structured as:"
msgstr "合约状态下链接的存储方法结构如下"

#: src/ch02-07-01-02-million-dollar-homepage.md:140
#, fuzzy
msgid ""
"The OpenZeppelin Cairo Contracts library played a crucial role in speeding up "
"the development of the ERC721 contract for Starknet Homepage. You can find "
"the contract for review [here](https://github.com/dbejarano820/"
"starknet_homepage/blob/main/cairo_contracts/src/ERC721.cairo). Once you have "
"installed the library, you can refer to the following example for typical "
"usage:"
msgstr ""
"OpenZeppelin Cairo Contracts 库在加速开发Starknet首页的 ERC721 合约方面发挥了"
"至关重要的作用。您可以在 [此处](https://github.com/dbejarano820/"
"starknet_homepage/blob/main/cairo_contracts/src/ERC721.cairo) 找到该合约以供查"
"阅。安装该库后，您可以参考以下示例了解其典型用法："

#: src/ch02-07-01-02-million-dollar-homepage.md:170
#, fuzzy
msgid "Component Logic"
msgstr "组件逻辑"

#: src/ch02-07-01-02-million-dollar-homepage.md:172
msgid "Grid"
msgstr "网格"

#: src/ch02-07-01-02-million-dollar-homepage.md:174
#, fuzzy
msgid ""
"The Grid component represents a 100x100 matrix, with each cell being 100 "
"pixels. This layout corresponds to the data structure found in the smart "
"contract. To showcase the tokens already minted on the Homepage, the app "
"employs a React Hook from `starknet-react` to invoke the `getAllTokens` "
"function from the contract."
msgstr ""
"网格组件表示一个 100x100 的矩阵，每个单元格为 100 个像素。这种布局与智能合约中"
"的数据结构相对应。为了展示主页上已经铸造的代币，该应用程序使用了来自 "
"`starknet-react` 的 React Hook 来调用合约中的 `getAllTokens` 函数。"

#: src/ch02-07-01-02-million-dollar-homepage.md:176
#, fuzzy
msgid ""
"```typescript\n"
"const [allNfts, setAllNfts] = useState<any[]>([]);\n"
"const { data, isLoading } = useContractRead({\n"
"  address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"  functionName: \"getAllTokens\",\n"
"  abi: starknetHomepageABI,\n"
"  args: [],\n"
"});\n"
"useEffect(() => {\n"
"  if (!isLoading) {\n"
"    const arr = data?.map((nft) => {\n"
"      return deserializeTokenObject(nft);\n"
"    });\n"
"    setAllNfts(arr || []);\n"
"  }\n"
"}, [data, isLoading]);\n"
"```"
msgstr ""
"```类型脚本\n"
"const [allNfts, setAllNfts] = useState<any[]>([])；\n"
"const { data, isLoading } = useContractRead({\n"
"  地址：starknet_homepage_erc721_address、\n"
"  functionName：\"getAllTokens\"、\n"
"  abi: starknetHomepageABI、\n"
"  args: []、\n"
"});\n"
"useEffect(() => {\n"
"  if (!isLoading) {\n"
"    const arr = data?.map((nft) => {\n"
"      return deserializeTokenObject(nft)；\n"
"    });\n"
"    setAllNfts(arr || [])；\n"
"  }\n"
"}, [data, isLoading])；\n"
"```"

#: src/ch02-07-01-02-million-dollar-homepage.md:194
#, fuzzy
msgid ""
"Deserialization ensures the data from the Starknet contract is aptly "
"transformed for frontend use. This process involves decoding the array of "
"`felt252`s into extensive strings."
msgstr ""
"反序列化可确保Starknet合约中的数据经过适当转换后供前端使用。这一过程包括将 "
"`felt252`s 数组解码为大量字符串。"

#: src/ch02-07-01-02-million-dollar-homepage.md:196
#, fuzzy
msgid ""
"```typescript\n"
"import { shortString, num } from \"starknet\";\n"
"const deserializeFeltArray = (arr: any) => {\n"
"    return arr\n"
"        .map((img: bigint) => {\n"
"            return shortString.decodeShortString(num.toHex(img));\n"
"        })\n"
"        .join(\"\");\n"
"};\n"
"...\n"
"img: deserializeFeltArray(tokenObject.img),\n"
"link: deserializeFeltArray(tokenObject.link),\n"
"...\n"
"```"
msgstr ""
"```类型脚本\n"
"从 \"starknet \"导入 { shortString, num }；\n"
"const deserializeFeltArray = (arr: any) => {\n"
"    return arr\n"
"        .map((img: bigint) => {\n"
"            return shortString.decodeShortString(num.toHex(img))；\n"
"        })\n"
"        .join(\"\")；\n"
"};\n"
"...\n"
"img: deserializeFeltArray(tokenObject.img)、\n"
"link: deserializeFeltArray(tokenObject.link)、\n"
"...\n"
"```"

#: src/ch02-07-01-02-million-dollar-homepage.md:211
#, fuzzy
msgid ""
"Furthermore, the Grid component manages the cell selection process, leading "
"to the minting of a corresponding token. Once an area is chosen, a modal "
"appears displaying the mint details and other necessary inputs for the call "
"data. The intricacies of the multicall will be addressed subsequently."
msgstr ""
"此外，网格组件还负责管理单元格的选择过程，从而铸造相应的代币。一旦选择了一个区"
"域，就会出现一个模态，显示铸币细节和其他必要的呼叫数据输入。多重呼叫的复杂性将"
"在随后讨论。"

#: src/ch02-07-01-02-million-dollar-homepage.md:215
msgid "Modals"
msgstr "模态"

#: src/ch02-07-01-02-million-dollar-homepage.md:217
#, fuzzy
msgid ""
"Modals offer a convenient means to present varied functionalities within the "
"app, such as wallet connection, token minting, and token editing."
msgstr ""
"模态提供了一种便捷的方式，可在应用程序中展示各种功能，如钱包连接、代币铸造和代"
"币编辑。"

#: src/ch02-07-01-02-million-dollar-homepage.md:221
#, fuzzy
msgid ""
"A recognized best practice is to invoke the React hook for shared information "
"at a top-level, ensuring components like the `WalletBar` remain streamlined "
"and focused."
msgstr ""
"公认的最佳做法是在顶层调用 React 钩子来共享信息，从而确保 \"WalletBar \"等组件"
"保持精简和集中。"

#: src/ch02-07-01-02-million-dollar-homepage.md:233
#, fuzzy
msgid ""
"Below, the `WalletConnected` function displays the connected wallet's "
"address, while the `ConnectWallet` function allows users to select and "
"connect their wallet. The `WalletBar` function renders the appropriate modal "
"based on the connection status."
msgstr ""
"下面，\"WalletConnected \"函数显示连接的钱包地址，而 \"ConnectWallet \"函数允"
"许用户选择并连接他们的钱包。钱包栏 \"函数会根据连接状态渲染相应的模态。"

#: src/ch02-07-01-02-million-dollar-homepage.md:235
#, fuzzy
msgid ""
"```typescript\n"
"function WalletConnected({ address }: { address: string }) {\n"
"  const { disconnect } = useConnectors();\n"
"  const { chain } = useNetwork();\n"
"  const shortenedAddress = useMemo(() => {\n"
"    if (!address) return \"\";\n"
"    return `${address.slice(0, 6)}...${address.slice(-4)}`;\n"
"  }, [address]);\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={disconnect}>\n"
"        {shortenedAddress}\n"
"      </StyledButton>\n"
"      <span>&nbsp;Connected to {chain && chain.name}</span>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"function ConnectWallet() {\n"
"  const { connectors, connect } = useConnectors();\n"
"  const [open, setOpen] = useState(false);\n"
"  const theme = useTheme();\n"
"\n"
"  const handleClickOpen = () => {\n"
"    setOpen(true);\n"
"  };\n"
"\n"
"  const handleClose = () => {\n"
"    setOpen(false);\n"
"  };\n"
"\n"
"  return (\n"
"    <StyledBox>\n"
"      <StyledButton color=\"inherit\" onClick={handleClickOpen}>\n"
"        Connect Wallet\n"
"      </StyledButton>\n"
"      <Dialog open={open} onClose={handleClose}>\n"
"        <DialogTitle>Connect to a wallet</DialogTitle>\n"
"        <DialogContent>\n"
"          <DialogContentText>\n"
"            <Grid container direction=\"column\" alignItems=\"flex-start\" "
"gap={1}>\n"
"              {connectors.map((connector) => (\n"
"                <ConnectWalletButton\n"
"                  key={connector.id}\n"
"                  onClick={() => {\n"
"                    connect(connector);\n"
"                    handleClose();\n"
"                  }}\n"
"                  sx={{ margin: theme.spacing(1) }}\n"
"                >\n"
"                  {connector.id}\n"
"                  <Image\n"
"                    src={`/${connector.id}-icon.png`}\n"
"                    alt={connector.id}\n"
"                    width={30}\n"
"                    height={30}\n"
"                  />\n"
"                </ConnectWalletButton>\n"
"              ))}\n"
"            </Grid>\n"
"          </DialogContentText>\n"
"        </DialogContent>\n"
"        <DialogActions>\n"
"          <Button onClick={handleClose} color=\"inherit\">\n"
"            Cancel\n"
"          </Button>\n"
"        </DialogActions>\n"
"      </Dialog>\n"
"    </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar({\n"
"  account,\n"
"}: {\n"
"  account: string | undefined;\n"
"}) {\n"
"  return account ? <WalletConnected address={account} /> : <ConnectWallet /"
">;\n"
"}\n"
"```"
msgstr ""
"```类型脚本\n"
"function WalletConnected({ address }: { address: string }) {\n"
"  const { disconnect }= useConnectors()；\n"
"  const { chain } = useNetwork()；\n"
"  const shortenedAddress = useMemo(() =&gt; {\n"
"    if (!address) return \"\"；\n"
"    返回 `${address.slice(0, 6)}...${address.slice(-4)}`；\n"
"  }, [address])；\n"
"\n"
"  返回 (\n"
"   <StyledBox>\n"
"      &lt;StyledButton color=\"inherit\" onClick={disconnect}&gt;\n"
"       {shortenedAddress}\n"
"      </StyledButton>\n"
"      <span> 连接到 {chain &amp;&amp; chain.name}</span>\n"
"   </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"函数 ConnectWallet() {\n"
"  const { connectors, connect }= useConnectors()；\n"
"  const [open, setOpen] = useState(false)；\n"
"  const theme = useTheme()；\n"
"\n"
"  const handleClickOpen = () =&gt; {\n"
"    setOpen(true)；\n"
"  };\n"
"\n"
"  const handleClose = () =&gt; {\n"
"    setOpen(false)；\n"
"  };\n"
"\n"
"  返回 (\n"
"   <StyledBox>\n"
"      &lt;StyledButton color=\"inherit\" onClick={handleClickOpen}&gt;\n"
"        连接钱包\n"
"     </StyledButton>\n"
"      &lt;Dialog open={open} onClose={handleClose}&gt;\n"
"       <DialogTitle>连接到钱包</DialogTitle>\n"
"       <DialogContent>\n"
"         <DialogContentText>\n"
"            &lt;Grid container direction=\"column\" alignItems=\"flex-start\" "
"gap={1}&gt;\n"
"              {connectors.map((connector) =&gt; (\n"
"                &lt;ConnectWalletButton\n"
"                  key={connector.id}\n"
"                  onClick={() =&gt; {\n"
"                    connect(connector)；\n"
"                    handleClose()；\n"
"                  }}\n"
"                  sx={{ margin: theme.spacing(1) }}\n"
"                &gt;\n"
"                 {connector.id}\n"
"                  &lt;图片\n"
"                    src={`/${connector.id}-icon.png`}\n"
"                    alt={connector.id}\n"
"                    width={30}\n"
"                    height={30}\n"
"                  /&gt;\n"
"               </ConnectWalletButton>\n"
"              ))}\n"
"           </Grid>\n"
"         </DialogContentText>\n"
"       </DialogContent>\n"
"       <DialogActions>\n"
"          &lt;Button onClick={handleClose} color=\"inherit\"&gt;\n"
"            取消\n"
"         </Button>\n"
"       </DialogActions>\n"
"     </Dialog>\n"
"   </StyledBox>\n"
"  );\n"
"}\n"
"\n"
"export default function WalletBar({\n"
"  account、\n"
"}:{\n"
"  account: string | undefined；\n"
"}) {\n"
"  return account ?&lt;WalletConnected address={account} /&gt; :"
"<ConnectWallet /> ；\n"
"}\n"
"```"

#: src/ch02-07-01-02-million-dollar-homepage.md:317
#, fuzzy
msgid "Token Dropdown"
msgstr "令牌下拉菜单"

#: src/ch02-07-01-02-million-dollar-homepage.md:319
#, fuzzy
msgid ""
"The dropdown component is dedicated to showcasing the tokens associated with "
"the currently connected wallet. To retrieve these tokens, a transaction like "
"the one shown below can be executed. The sole argument for this function is "
"the contract address of the intended owner."
msgstr ""
"下拉组件用于显示与当前连接的钱包相关的代币。要检索这些代币，可以执行下图所示的"
"交易。该功能的唯一参数是目标所有者的合约地址。"

#: src/ch02-07-01-02-million-dollar-homepage.md:321
#, fuzzy
msgid ""
"```typescript\n"
"const readTx = useMemo(() => {\n"
"  const tx = {\n"
"    address: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    functionName: \"getTokensByOwner\",\n"
"    abi: starknetHomepageABI,\n"
"    args: [account || \"0x0000000\"],\n"
"  };\n"
"  return tx;\n"
"}, [account]);\n"
"\n"
"const { data, isLoading } = useContractRead(readTx);\n"
"```"
msgstr ""
"```类型脚本\n"
"const readTx = useMemo(() => {\n"
"  const tx = {\n"
"    地址starknet_homepage_erc721_address、\n"
"    functionName：\"getTokensByOwner\"、\n"
"    abi: starknetHomepageABI、\n"
"    args: [account || \"0x0000000\"]、\n"
"  };\n"
"  return tx；\n"
"}, [account])；\n"
"\n"
"const { data, isLoading } = useContractRead(readTx)；\n"
"```"

#: src/ch02-07-01-02-million-dollar-homepage.md:335
#, fuzzy
msgid "Multicall Contract Interaction"
msgstr "多呼叫合约互动"

#: src/ch02-07-01-02-million-dollar-homepage.md:337
#, fuzzy
msgid ""
"The provided code offers an illustration of a multicall, specifically to "
"approve a transaction for the mint price transfer followed by the actual "
"minting action. Notably, the `shortString` module from `starknet.js` plays a "
"pivotal role; it encodes and segments a lengthy string into an array of "
"`felt252`s, the expected argument type for the contract on Starknet."
msgstr ""
"所提供的代码提供了多重调用的示例，特别是批准铸币价格转让交易，然后进行实际的铸"
"币操作。值得注意的是，\"starknet.js \"中的 \"shortString \"模块发挥了关键作"
"用；它将冗长的字符串编码并分割成 \"felt252 \"数组，这是Starknet合约的预期参数"
"类型。"

#: src/ch02-07-01-02-million-dollar-homepage.md:339
#, fuzzy
msgid ""
"The `useContractWrite` is a Hook dedicated to executing a Starknet multicall, "
"which can be employed for a singular transaction or multiple ones."
msgstr ""
"useContractWrite\" 是一个专门用于执行Starknet多重调用的钩子，可用于单个或多个"
"事务。"

#: src/ch02-07-01-02-million-dollar-homepage.md:341
#, fuzzy
msgid ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  const tx2 = {\n"
"    contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"    entrypoint: \"mint\",\n"
"    calldata: [\n"
"      startCell.col,\n"
"      startCell.row,\n"
"      width,\n"
"      height,\n"
"      splitNewImage,\n"
"      splitNewLink,\n"
"    ],\n"
"  };\n"
"\n"
"  const price = selectedCells.length * 1000000000000000;\n"
"\n"
"  const tx1 = {\n"
"    contractAddress: ERC_20_ADDRESS,\n"
"    entrypoint: \"approve\",\n"
"    calldata: [STARKNET_HOMEPAGE_ERC721_ADDRESS, `${price}`, \"0\"],\n"
"  };\n"
"  return [tx1, tx2];\n"
"}, [startCell, newImage, newLink, width, height, selectedCells.length]);\n"
"\n"
"const { writeAsync: writeMulti } = useContractWrite({ calls });\n"
"```"
msgstr ""
"```类型脚本\n"
"const calls = useMemo(() => {\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage)；\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink)；\n"
"\n"
"  const tx2 = {\n"
"    contractAddress：starknet_homepage_erc721_address、\n"
"    entrypoint: \"mint\"、\n"
"    calldata：[\n"
"      startCell.col、\n"
"      startCell.row、\n"
"      width、\n"
"      高度\n"
"      splitNewImage、\n"
"      splitNewLink、\n"
"    ],\n"
"  };\n"
"\n"
"  const price = selectedCells.length * 1000000000000000；\n"
"\n"
"  const tx1 = {\n"
"    contractAddress：erc_20_address、\n"
"    entrypoint: \"approve\"、\n"
"    calldata：[starknet_homepage_erc721_address,`${price}`, \"0\"]、\n"
"  };\n"
"  返回 [tx1、tx2]；\n"
"}, [startCell, newImage, newLink, width, height, selectedCells.length])；\n"
"\n"
"const { writeAsync: writeMulti }= useContractWrite({ calls })；\n"
"```"

#: src/ch02-07-01-02-million-dollar-homepage.md:372
#, fuzzy
msgid ""
"Another crucial aspect to point out is the `calldata` of the approve function "
"for the ether transfer: calldata: `[STARKNET_HOMEPAGE_ERC721_ADDRESS, "
"'${price}', \"0\"],`. The amount argument is split into two parts because "
"it's a `u256`, which is composed of two separate `felt252` values."
msgstr ""
"需要指出的另一个重要方面是以太网传输批准函数的 \"calldata\"： calldata："
"[starknet_homepage_erc721_address,'${price}', \"0\"],`。金额参数被分成两部分，"
"因为它是一个 `u256`，由两个独立的 `felt252` 值组成。"

#: src/ch02-07-01-02-million-dollar-homepage.md:374
#, fuzzy
msgid ""
"Once the multicall is prepared, the next step is to initiate the function and "
"sign the transaction using the connected wallet."
msgstr "准备好多路调用后，下一步就是使用连接的钱包启动功能并签署交易。"

#: src/ch02-07-01-02-million-dollar-homepage.md:376
#, fuzzy
msgid ""
"```typescript\n"
"const handleMintClick = async (): Promise<void> => {\n"
"  setIsMintLoading(true);\n"
"  try {\n"
"    await writeMulti();\n"
"    setIsMintLoading(false);\n"
"    setState((prevState) => ({\n"
"      ...prevState,\n"
"      showPopup: false,\n"
"      selectedCells: [],\n"
"      mintPrice: undefined,\n"
"    }));\n"
"  } catch (error) {\n"
"    console.error(\"Error approving transaction:\", error);\n"
"  }\n"
"};\n"
"```"
msgstr ""
"```类型脚本\n"
"const handleMintClick = async ()：Promise<void> =&gt; {\n"
"  setIsMintLoading(true)；\n"
"  try {\n"
"    await writeMulti()；\n"
"    setIsMintLoading(false)；\n"
"    setState((prevState) =&gt; ({\n"
"      ...prevState、\n"
"      showPopup: false、\n"
"      selectedCells: []、\n"
"      mintPrice: undefined、\n"
"    }));\n"
"  } catch (error) {\n"
"    console.error(\"Error Approving transaction:\", error)；\n"
"  }\n"
"};\n"
"```"

#: src/ch02-07-01-02-million-dollar-homepage.md:394
#, fuzzy
msgid "Conditional Multicall for Token Editing"
msgstr "令牌编辑的条件多呼"

#: src/ch02-07-01-02-million-dollar-homepage.md:396
#, fuzzy
msgid ""
"Another instructive illustration of a conditional multicall setup is the "
"modal used to modify the data associated with a token."
msgstr "条件多呼设置的另一个有启发性的例子是用于修改标记相关数据的模态。"

#: src/ch02-07-01-02-million-dollar-homepage.md:400
#, fuzzy
msgid ""
"There are scenarios where the user may wish to alter just one attribute of "
"the token, rather than both. Consequently, a conditional multicall "
"configuration becomes necessary. It's essential to recall that the token id "
"in the Cairo contract is defined as a `u256`, implying it comprises two "
"`felt252` values."
msgstr ""
"在某些情况下，用户可能只想更改令牌的一个属性，而不是两个都改。因此，有条件的多"
"调用配置就变得很有必要。必须记住，Cairo合约中的令牌 id 被定义为 \"u256\"，这意"
"味着它由两个 \"felt252 \"值组成。"

#: src/ch02-07-01-02-million-dollar-homepage.md:402
#, fuzzy
msgid ""
"```typescript\n"
"const calls = useMemo(() => {\n"
"  const txs = [];\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage);\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink);\n"
"\n"
"  if (newImage !== \"\" && nft) {\n"
"    const tx1 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenImg\",\n"
"      calldata: [nft.token_id, 0, splitNewImage],\n"
"    };\n"
"    txs.push(tx1);\n"
"  }\n"
"\n"
"  if (newLink !== \"\" && nft) {\n"
"    const tx2 = {\n"
"      contractAddress: STARKNET_HOMEPAGE_ERC721_ADDRESS,\n"
"      entrypoint: \"setTokenLink\",\n"
"      calldata: [nft.token_id, 0, splitNewLink],\n"
"    };\n"
"    txs.push(tx2);\n"
"  }\n"
"\n"
"  return txs;\n"
"}, [nft, newImage, newLink]);\n"
"```"
msgstr ""
"```类型脚本\n"
"const calls = useMemo(() => {\n"
"  const txs = []；\n"
"  const splitNewImage: string[] = shortString.splitLongString(newImage)；\n"
"  const splitNewLink: string[] = shortString.splitLongString(newLink)；\n"
"\n"
"  if (newImage !== \"\" && nft) {\n"
"    const tx1 = {\n"
"      contractAddress：starknet_homepage_erc721_address、\n"
"      entrypoint: \"setTokenImg\"、\n"
"      calldata：[nft.token_id，0，splitNewImage]、\n"
"    };\n"
"    txs.push(tx1)；\n"
"  }\n"
"\n"
"  if (newLink !== \"\" && nft) {\n"
"    const tx2 = {\n"
"      contractAddress：starknet_homepage_erc721_address、\n"
"      entrypoint: \"setTokenLink\"、\n"
"      calldata：[nft.token_id，0，splitNewLink]、\n"
"    };\n"
"    txs.push(tx2)；\n"
"  }\n"
"\n"
"  return txs；\n"
"}, [nft, newImage, newLink])；\n"
"```"

#: src/ch02-07-01-02-million-dollar-homepage.md:430
#, fuzzy
msgid "Starknet Homepage Overview"
msgstr "Starknet主页概述"

#: src/ch02-07-01-02-million-dollar-homepage.md:432
#, fuzzy
msgid ""
"**Grid Component**: Represents a 100x100 matrix, allowing users to select "
"cells and mint corresponding tokens. It fetches existing tokens using the "
"`getAllTokens` function from the contract and displays them."
msgstr ""
"**网格组件**：代表一个 100x100 的矩阵，允许用户选择单元格和相应的代币。它使用 "
"\"getAllTokens \"函数从合约中获取并显示现有代币。"

#: src/ch02-07-01-02-million-dollar-homepage.md:433
#, fuzzy
msgid ""
"**Modals**: Serve as the user interface for actions like wallet connection, "
"token minting, and token editing."
msgstr "**模块**：作为钱包连接、代币铸造和代币编辑等操作的用户界面。"

#: src/ch02-07-01-02-million-dollar-homepage.md:434
#, fuzzy
msgid ""
"**Token Dropdown**: Displays tokens associated with a connected wallet. It "
"retrieves these tokens using the `getTokensByOwner` function."
msgstr ""
"**令牌下拉**：显示与已连接钱包相关的令牌。它使用 \"getTokensByOwner \"函数检索"
"这些令牌。"

#: src/ch02-07-01-02-million-dollar-homepage.md:435
#, fuzzy
msgid ""
"**Multicall Contract Interaction**: Enables token minting and editing. This "
"process utilizes conditional multicalls based on user preferences, especially "
"for editing token attributes."
msgstr ""
"**Multicall Contract Interaction**：启用令牌铸造和编辑。该流程根据用户偏好使用"
"有条件多all，特别是在编辑令牌属性时。"

#: src/ch02-07-01-02-million-dollar-homepage.md:437
#, fuzzy
msgid ""
"Throughout the platform, string limitations in Cairo contracts require "
"encoding lengthy strings into arrays of `felt252`s. The OpenZeppelin Cairo "
"Contracts library significantly expedites the development of the ERC721 "
"contract for the Starknet Homepage."
msgstr ""
"在整个平台中，Cairo合约中的字符串限制要求将冗长的字符串编码为 \"felt252 \"数"
"组。OpenZeppelin Cairo合约库大大加快了Starknet主页 ERC721 合约的开发。"

#: src/ch02-08-starknet-react.md:3
#, fuzzy
msgid ""
"Several tools exist in the starknet ecosystem to build the front-end for your "
"application. The most popular ones are:"
msgstr ""
"Starknet生态系统中有多个工具可用于为您的应用程序构建前端。最受欢迎的工具有"

#: src/ch02-08-starknet-react.md:6
#, fuzzy
msgid ""
"[starknet-react](https://github.com/apibara/starknet-react) ([documentation]"
"(https://apibara.github.io/starknet-react)): Collection of React hooks for "
"Starknet. It is inspired by [wagmi](https://github.com/tmm/wagmi), powered by "
"[starknet.js](https://github.com/0xs34n/starknet.js)."
msgstr ""
"[starknet-react](https://github.com/apibara/starknet-react) ([documentation]"
"(https://apibara.github.io/starknet-react))：用于 Starknet 的 React 钩子集合。"
"其灵感来自 [wagmi](https://github.com/tmm/wagmi)，由 [starknet.js](https://"
"github.com/0xs34n/starknet.js) 提供。"

#: src/ch02-08-starknet-react.md:12
#, fuzzy
msgid ""
"[starknet.js](https://github.com/0xs34n/starknet.js): A JavaScript library "
"for interacting with Starknet contracts. It would be the equivalent of [web3."
"js](https://web3js.org/) for Ethereum."
msgstr ""
"[starknet.js](https://github.com/0xs34n/starknet.js)：用于与 Starknet 合约交互"
"的 JavaScript 库。它相当于以太坊的 [web3.js](https://web3js.org/)。"

#: src/ch02-08-starknet-react.md:16
#, fuzzy
msgid ""
"For Vue developers, vue-stark-boil, created by the team at [Don’t Panic DAO]"
"(https://github.com/dontpanicdao), is a great option. For a deeper "
"understanding of Vue, visit their [website](https://vuejs.org/). The vue-"
"stark-boil boilerplate enables various functionalities, such as connecting to "
"a wallet, listening for account changes, and calling a contract."
msgstr ""
"对于 Vue 开发人员来说，[Don't Panic DAO](https://github.com/dontpanicdao) 团队"
"创建的 vue-stark-boil 是一个不错的选择。要深入了解 Vue，请访问他们的 [网站]"
"(https://vuejs.org/)。vue-stark-boil 模板可实现各种功能，如连接到钱包、监听账"
"户变动和调用合约。"

#: src/ch02-08-starknet-react.md:23
#, fuzzy
msgid ""
"Authored by the [Apibara](https://github.com/apibara/) team, [Starknet React]"
"(https://github.com/apibara/starknet-react/) is an open-source collection of "
"React providers and hooks meticulously designed for Starknet."
msgstr ""
"由[Apibara](https://github.com/apibara/)团队编写的[Starknet React](https://"
"github.com/apibara/starknet-react/)是为Starknet精心设计的React提供程序和钩子的"
"开源集合。"

#: src/ch02-08-starknet-react.md:28
#, fuzzy
msgid ""
"To immerse in the real-world application of Starknet React, we recommend "
"exploring the comprehensive example dApp project at [starknet-demo-dapp]"
"(https://github.com/finiam/starknet-demo-dapp/)."
msgstr ""
"要深入了解 Starknet React 在现实世界中的应用，我们建议您访问 [starknet-demo-"
"dapp](https://github.com/finiam/starknet-demo-dapp/) 上的综合 dApp 示例项目。"

#: src/ch02-08-starknet-react.md:32
#, fuzzy
msgid "Integrating Starknet React"
msgstr "集成Starknet React"

#: src/ch02-08-starknet-react.md:34
#, fuzzy
msgid ""
"Embarking on your Starknet React journey necessitates the incorporation of "
"vital dependencies. Let’s start by adding them to your project."
msgstr ""
"要开始 Starknet React 之旅，就必须加入重要的依赖项。让我们先将它们添加到您的项"
"目中。"

#: src/ch02-08-starknet-react.md:39
#, fuzzy
msgid ""
"[Starknet.js](https://www.starknetjs.com/) is an essential SDK facilitating "
"interactions with Starknet. In contrast, [get-starknet](https://github.com/"
"starknet-io/get-starknet/) is a package adept at managing wallet connections."
msgstr ""
"[Starknet.js](https://www.starknetjs.com/)是促进与Starknet互动的重要 SDK。相"
"反，[get-starknet](https://github.com/starknet-io/get-starknet/) 是一个善于管"
"理钱包连接的软件包。"

#: src/ch02-08-starknet-react.md:44
#, fuzzy
msgid ""
"Proceed by swaddling your app within the `StarknetConfig` component. This "
"enveloping action offers a degree of configuration, while simultaneously "
"providing a React Context for the application beneath to utilize shared data "
"and hooks. The `StarknetConfig` component accepts a connectors prop, allowing "
"the definition of wallet connection options available to the user."
msgstr ""
"将您的应用程序裹在 \"StarknetConfig \"组件中。这一封装动作提供了一定程度的配"
"置，同时还为下面的应用程序提供了一个 React 上下文，以便使用共享数据和钩子。"
"StarknetConfig \"组件接受连接器道具，允许定义用户可用的钱包连接选项。"

#: src/ch02-08-starknet-react.md:51
#, fuzzy
msgid ""
"```\n"
"const connectors = [\n"
"  new InjectedConnector({ options: { id: \"braavos\" } }),\n"
"  new InjectedConnector({ options: { id: \"argentX\" } }),\n"
"];\n"
"\n"
"return (\n"
"    <StarknetConfig\n"
"      connectors={connectors}\n"
"      autoConnect\n"
"    >\n"
"      <App />\n"
"    </StarknetConfig>\n"
")\n"
"```"
msgstr ""
"```\n"
"连接器 = [\n"
"  new InjectedConnector({ options: { id: \"braavos\" })、\n"
"  new InjectedConnector({ options: { id: \"argentX\" })、\n"
"];\n"
"\n"
"返回 (\n"
"    &lt; Starknet配置\n"
"      连接器={connectors}\n"
"      自动连接\n"
"    &gt;\n"
"     <App />\n"
"    </StarknetConfig>\n"
")\n"
"```"

#: src/ch02-08-starknet-react.md:65
#, fuzzy
msgid "Establishing Connection and Managing Account"
msgstr "建立连接和管理账户"

#: src/ch02-08-starknet-react.md:67
#, fuzzy
msgid ""
"Once the connectors are defined in the config, the stage is set to use a hook "
"to access these connectors, enabling users to connect their wallets:"
msgstr ""
"一旦在配置中定义了连接器，舞台就会使用钩子访问这些连接器，使用户能够连接他们的"
"钱包："

#: src/ch02-08-starknet-react.md:89
#, fuzzy
msgid ""
"Observe the `disconnect` function that terminates the connection when "
"invoked. Post connection, access to the connected account is provided through "
"the `useAccount` hook, offering insight into the current state of connection:"
msgstr ""
"观察 \"disconnect \"函数，该函数会在调用时终止连接。连接后，可通过 "
"`useAccount` 钩子访问已连接的账户，从而了解连接的当前状态："

#: src/ch02-08-starknet-react.md:106
#, fuzzy
msgid ""
"The state values, such as `isConnected` and `isReconnecting`, receive "
"automatic updates, simplifying UI conditional updates. This convenient "
"pattern shines when dealing with asynchronous processes, as it eliminates the "
"need to manually manage the state within your components."
msgstr ""
"状态值（如 \"isConnected \"和 \"isReconnecting\"）会自动更新，从而简化了用户界"
"面的条件更新。在处理异步进程时，这种方便的模式可以省去在组件中手动管理状态的麻"
"烦。"

#: src/ch02-08-starknet-react.md:111
#, fuzzy
msgid ""
"Having established a connection, signing messages becomes a breeze using the "
"account value returned from the `useAccount` hook. For a more streamlined "
"experience, the `useSignTypedData` hook is at your disposal."
msgstr ""
"建立连接后，使用`useAccount`钩子返回的账户值签署邮件就变得轻而易举了。如果想获"
"得更简化的体验，可以使用 `useSignTypedData` 钩子。"

#: src/ch02-08-starknet-react.md:126
#, fuzzy
msgid ""
"Starknet React supports signing an array of `BigNumberish` values or an "
"object. While signing an object, it is crucial to ensure that the data "
"conforms to the EIP712 type. For a more comprehensive guide on signing, refer "
"to the Starknet.js documentation: [here](https://www.starknetjs.com/docs/"
"guides/signature/)."
msgstr ""
"Starknet React 支持签署 \"BigNumberish \"值数组或对象。在签署对象时，确保数据"
"符合 EIP712 类型至关重要。有关签名的更全面指南，请参阅 Starknet.js 文档："
"[here](https://www.starknetjs.com/docs/guides/signature/)."

#: src/ch02-08-starknet-react.md:132
#, fuzzy
msgid "Displaying StarkName"
msgstr "显示斯塔克名称"

#: src/ch02-08-starknet-react.md:134
#, fuzzy
msgid ""
"After an account has been connected, the `useStarkName` hook can be used to "
"retrieve the StarkName of this connected account. Related to [Starknet.id]"
"(https://www.starknet.id/) it permits to display the user address in a more "
"user friendly way."
msgstr ""
"账户连接后，可以使用 `useStarkName` 钩子来获取已连接账户的 StarkName。与 "
"[Starknet.id](https://www.starknet.id/)相关，它允许以更友好的方式显示用户地"
"址。"

#: src/ch02-08-starknet-react.md:139
#, fuzzy
msgid ""
"```\n"
"const { data, isError, isLoading, status } = useStarkName({ address });\n"
"// You can track the status of the request with the status variable ('idle' | "
"'error' | 'loading' | 'success')\n"
"\n"
"if (isLoading) return <p>Loading...</p>\n"
"return <p>Account: {isError ? address : data}</p>\n"
"```"
msgstr ""
"```\n"
"const { data, isError, isLoading, status }= useStarkName({ address })；\n"
"// 可以使用状态变量跟踪请求的状态（'空闲' | '错误' | '正在加载' | '成功'）。\n"
"\n"
"if (isLoading) return<p>Loading</p>...\n"
"return<p>Account：{isError ?｝</p>\n"
"```"

#: src/ch02-08-starknet-react.md:145
#, fuzzy
msgid ""
"You also have additional information you can get from this hook → **error**, "
"**isIdle**, **isFetching**, **isSuccess**, **isFetched**, "
"**isFetchedAfterMount**, **isRefetching**, **refetch** which can give you "
"more precise information on what is happening."
msgstr ""
"您还可以从该钩子获取其他信息 → **error**、**isIdle**、**isFetching**、"
"**isSuccess**、**isFetched**、**isFetchedAfterMount**、**isRefetching**、"
"**refetch**，这些信息可以让您更准确地了解发生了什么。"

#: src/ch02-08-starknet-react.md:150
#, fuzzy
msgid "Fetching address from StarkName"
msgstr "从 StarkName 获取地址"

#: src/ch02-08-starknet-react.md:152
#, fuzzy
msgid ""
"You could also want to retrieve an address corresponding to a StarkName. For "
"this purpose, you can use the `useAddressFromStarkName` hook."
msgstr ""
"您可能还想获取与 StarkName 相对应的地址。为此，您可以使用 "
"`useAddressFromStarkName` 钩子。"

#: src/ch02-08-starknet-react.md:161
#, fuzzy
msgid ""
"If the provided name does not have an associated address, it will return "
"**\"0x0\"**"
msgstr "如果所提供的名称没有相关地址，它将返回 **\"0x0\"**"

#: src/ch02-08-starknet-react.md:164
#, fuzzy
msgid "Navigating the Network"
msgstr "网络导航"

#: src/ch02-08-starknet-react.md:166
#, fuzzy
msgid ""
"In addition to wallet and account management, Starknet React equips "
"developers with hooks for network interactions. For instance, useBlock "
"enables the retrieval of the latest block:"
msgstr ""
"除了钱包和账户管理，Starknet React 还为开发人员提供了网络交互钩子。例如，"
"useBlock 可以检索最新的区块："

#: src/ch02-08-starknet-react.md:170
#, fuzzy
msgid ""
"```\n"
"const { data, isError, isFetching } = useBlock({\n"
"    refetchInterval: 10_000,\n"
"    blockIdentifier: \"latest\",\n"
"});\n"
"\n"
"if (isError) {\n"
"  return (\n"
"    <p>Something went wrong</p>\n"
"  )\n"
"}\n"
"\n"
"return (\n"
"    <p>Current block: {isFetching ? \"Loading...\" : data?.block_number}<p>\n"
")\n"
"```"
msgstr ""
"```\n"
"const { data, isError, isFetching } = useBlock({\n"
"    refetchInterval: 10_000、\n"
"    blockIdentifier：\"latest\"、\n"
"});\n"
"\n"
"if (isError) {\n"
"  返回 (\n"
"   <p>出错了</p>\n"
"  )\n"
"}\n"
"\n"
"return (\n"
"   <p>当前区块：{isFetching ?\"Loading...\" : data?｝<p>\n"
")\n"
"```"

#: src/ch02-08-starknet-react.md:185
#, fuzzy
msgid ""
"In the aforementioned code, refetchInterval controls the frequency of data "
"refetching. Behind the scenes, Starknet React harnesses [react-query](https://"
"github.com/TanStack/query/) for managing state and queries. In addition to "
"useBlock, Starknet React offers other hooks like useContractRead and "
"useWaitForTransaction, which can be configured to update at regular intervals."
msgstr ""
"在上述代码中，refetchInterval 控制数据重新获取的频率。在幕后，Starknet React "
"利用 [react-query](https://github.com/TanStack/query/) 来管理状态和查询。除了 "
"useBlock 之外，Starknet React 还提供了其他钩子，如 useContractRead 和 "
"useWaitForTransaction，这些钩子可以配置为定期更新。"

#: src/ch02-08-starknet-react.md:192
#, fuzzy
msgid "The useStarknet hook provides direct access to the ProviderInterface:"
msgstr "useStarknet 钩子可直接访问 ProviderInterface："

#: src/ch02-08-starknet-react.md:194
#, fuzzy
msgid ""
"```\n"
"const { library } = useStarknet();\n"
"\n"
"// library.getClassByHash(...)\n"
"// library.getTransaction(...)\n"
"```"
msgstr ""
"```\n"
"const { library } = useStarknet()；\n"
"\n"
"// library.getClassByHash(...)\n"
"// library.getTransaction(...)\n"
"```"

#: src/ch02-08-starknet-react.md:199
#, fuzzy
msgid "Tracking Wallet changes"
msgstr "跟踪钱包变化"

#: src/ch02-08-starknet-react.md:201
#, fuzzy
msgid ""
"To improve your dApp User Experience, you can track the user wallet changes, "
"especially when the user changes the wallet account (or connects/"
"disconnects). But also when the user changes the network. You could want to "
"reload correct balances when the user changes the account, or to reset the "
"state of your dApp when the user changes the network. To do so, you can use a "
"previous hook we already looked at: `useAccount` and a new one `useNetwork`."
msgstr ""
"为了改善您的 dApp 用户体验，您可以跟踪用户钱包的变化，尤其是当用户更改钱包账户"
"（或连接/断开连接）时。用户更换网络时也是如此。您可能希望在用户更改账户时重新"
"加载正确的余额，或者在用户更改网络时重置 dApp 的状态。为此，您可以使用我们之前"
"介绍过的钩子：useAccount \"和一个新钩子 \"useNetwork\"。"

#: src/ch02-08-starknet-react.md:209
#, fuzzy
msgid ""
"The `useNetwork` hook can provide you with the network chain currently in use."
msgstr "`useNetwork` 钩子可提供当前使用的网络链。"

#: src/ch02-08-starknet-react.md:221
#, fuzzy
msgid ""
"You also have additional information you can get from this hook → "
"**blockExplorer**, **testnet** which can give you more precise information "
"about the current network being used."
msgstr ""
"您还可以从该钩子获取其他信息 → **blockExplorer**、**testnet**，它们可以为您提"
"供有关当前正在使用的网络的更精确信息。"

#: src/ch02-08-starknet-react.md:225
#, fuzzy
msgid ""
"After knowing this you have all you need to track user interaction on the "
"using account and network. You can use the `useEffect` hook to do some work "
"on changes."
msgstr ""
"了解这些信息后，您就掌握了跟踪用户在使用账户和网络上的交互所需的一切。您可以使"
"用 `useEffect` 钩子对更改进行一些处理。"

#: src/ch02-08-starknet-react.md:229
#, fuzzy
msgid ""
"```\n"
"const { chain } = useNetwork();\n"
"const { address } = useAccount();\n"
"\n"
"useEffect(() => {\n"
"    if(address) {\n"
"        // Do some work when the user changes the account on the wallet\n"
"        // Like reloading the balances\n"
"    }else{\n"
"        // Do some work when the user disconnects the wallet\n"
"        // Like reseting the state of your dApp\n"
"    }\n"
"}, [address]);\n"
"\n"
"useEffect(() => {\n"
"    // Do some work when the user changes the network on the wallet\n"
"    // Like reseting the state of your dApp\n"
"}, [chain]);\n"
"```"
msgstr ""
"```\n"
"const { chain } = useNetwork()；\n"
"const { address }= useAccount()；\n"
"\n"
"useEffect(() => {\n"
"    if(address) {\n"
"        // 当用户更改钱包账户时执行一些操作\n"
"        // 比如重新加载余额\n"
"    }else{\n"
"        // 当用户断开钱包连接时做一些工作\n"
"        // 比如重置 dApp 的状态\n"
"    }\n"
"}, [address])；\n"
"\n"
"useEffect(() => {\n"
"    // 当用户在钱包上更改网络时做一些工作\n"
"    // 比如重置 dApp 的状态\n"
"}, [chain])；\n"
"```"

#: src/ch02-08-starknet-react.md:247
#, fuzzy
msgid "Contract Interactions"
msgstr "合约互动"

#: src/ch02-08-starknet-react.md:249
#, fuzzy
msgid "Read Functions"
msgstr ""
"你可以使用 `starkli call` 命令来调用这些函数。请注意，`call`命令用于只读函数，"
"而 `invoke`命令用于也可以写入存储空间的函数。调用 `call` 命令不需要签名，而 "
"`invoke`命令需要签名。"

#: src/ch02-08-starknet-react.md:251
#, fuzzy
msgid ""
"Starknet React presents useContractRead, a specialized hook for invoking read "
"functions on contracts, akin to wagmi. This hook functions independently of "
"the user’s connection status, as read operations do not necessitate a signer."
msgstr ""
"Starknet React 推出了 useContractRead，这是一个专门的钩子，用于调用合约上的读"
"取功能，类似于 wagmi。该钩子的功能与用户的连接状态无关，因为读取操作不需要签名"
"者。"

#: src/ch02-08-starknet-react.md:256
#, fuzzy
msgid ""
"```\n"
"const { data: balance, isLoading, isError, isSuccess } = useContractRead({\n"
"    abi: abi_erc20,\n"
"    address: CONTRACT_ADDRESS,\n"
"    functionName: \"allowance\",\n"
"    args: [owner, spender],\n"
"    // watch: true <- refresh at every block\n"
"});\n"
"```"
msgstr ""
"```\n"
"const { data: balance, isLoading, isError, isSuccess }= useContractRead({\n"
"    abi: abi_erc20、\n"
"    address：contract_address、\n"
"    functionName：\"津贴\"、\n"
"    args: [owner, spender]、\n"
"    // watch: true <- 每块刷新一次\n"
"});\n"
"```"

#: src/ch02-08-starknet-react.md:264
#, fuzzy
msgid ""
"For ERC20 operations, Starknet React offers a convenient useBalance hook. "
"This hook exempts you from passing an ABI and returns a suitably formatted "
"balance value."
msgstr ""
"对于 ERC20 操作，Starknet React 提供了方便的 useBalance 挂钩。该钩子无需传递 "
"ABI，并返回适当格式化的余额值。"

#: src/ch02-08-starknet-react.md:268
#, fuzzy
msgid ""
"```\n"
"  const { data, isLoading } = useBalance({\n"
"    address,\n"
"    token: CONTRACT_ADDRESS, // <- defaults to the ETH token\n"
"    // watch: true <- refresh at every block\n"
"  });\n"
"\n"
"  return (\n"
"    <p>Balance: {data?.formatted} {data?.symbol}</p>\n"
"  )\n"
"```"
msgstr ""
"```\n"
"  const { data, isLoading } = useBalance({\n"
"    address、\n"
"    token：CONTRACT_ADDRESS, // &lt;- 默认为 ETH 令牌\n"
"    // watch: true &lt;- 每块刷新一次\n"
"  });\n"
"\n"
"  返回 (\n"
"   <p>余额{data?.formatted} {data?.symbol} \n"
"  )\n"
"```</p>"

#: src/ch02-08-starknet-react.md:278
#, fuzzy
msgid "Write Functions"
msgstr "写入功能"

#: src/ch02-08-starknet-react.md:280
#, fuzzy
msgid ""
"The useContractWrite hook, designed for write operations, deviates slightly "
"from wagmi. The unique architecture of Starknet facilitates multicall "
"transactions natively at the account level. This feature enhances the user "
"experience when executing multiple transactions, eliminating the need to "
"approve each transaction individually. Starknet React capitalizes on this "
"functionality through the useContractWrite hook. Below is a demonstration of "
"its usage:"
msgstr ""
"专为写操作设计的 useContractWrite 钩子与 wagmi 略有不同。Starknet的独特架构有"
"利于在账户层面进行多呼叫交易。在执行多笔交易时，该功能增强了用户体验，无需逐笔"
"批准每笔交易。Starknet React 通过 useContractWrite 钩子利用了这一功能。下面是"
"其用法演示："

#: src/ch02-08-starknet-react.md:288
#, fuzzy
msgid ""
"```\n"
"const calls = useMemo(() => {\n"
"    // compile the calldata to send\n"
"    const calldata = stark.compileCalldata({\n"
"      argName: argValue,\n"
"    });\n"
"\n"
"    // return a single object for single transaction,\n"
"    // or an array of objects for multicall**\n"
"    return {\n"
"      contractAddress: CONTRACT_ADDRESS,\n"
"      entrypoint: functionName,\n"
"      calldata,\n"
"    };\n"
"}, [argValue]);\n"
"\n"
"\n"
"// Returns a function to trigger the transaction\n"
"// and state of tx after being sent\n"
"const { write, isLoading, data } = useContractWrite({\n"
"    calls,\n"
"});\n"
"\n"
"function execute() {\n"
"  // trigger the transaction\n"
"  write();\n"
"}\n"
"\n"
"return (\n"
"  <button type=\"button\" onClick={execute}>\n"
"    Make a transaction\n"
"  </button>\n"
")\n"
"```"
msgstr ""
"```\n"
"const calls = useMemo(() =&gt; {\n"
"    // 编译要发送的 calldata\n"
"    const calldata = stark.compileCalldata({\n"
"      argName: argValue、\n"
"    });\n"
"\n"
"    // 对于单个事务，返回单个对象、\n"
"    // 对于多调用**，返回对象数组\n"
"    返回 {\n"
"      contractAddress：contract_address、\n"
"      entrypoint: functionName、\n"
"      calldata、\n"
"    };\n"
"}, [argValue])；\n"
"\n"
"\n"
"// 返回触发事务的函数\n"
"// 和发送后的 tx 状态\n"
"const { write, isLoading, data } = useContractWrite({\n"
"    calls、\n"
"});\n"
"\n"
"function execute() {\n"
"  // 触发事务\n"
"  write()；\n"
"}\n"
"\n"
"return (\n"
"  &lt;button type=\"button\" onClick={execute}&gt;\n"
"    进行交易\n"
" </button>\n"
")\n"
"```"

#: src/ch02-08-starknet-react.md:321
#, fuzzy
msgid ""
"The code snippet begins by compiling the calldata using the compileCalldata "
"utility provided by Starknet.js. This calldata, along with the contract "
"address and entry point, are passed to the useContractWrite hook. The hook "
"returns a write function that is subsequently used to execute the "
"transaction. The hook also provides the transaction’s hash and state."
msgstr ""
"代码片段首先使用 Starknet.js 提供的编译 Calldata 实用程序编译 calldata。该 "
"calldata 与合约地址和入口点一起传递给 useContractWrite 钩子。钩子会返回一个写"
"入函数，随后用于执行事务。该钩子还提供了事务的哈希值和状态。"

#: src/ch02-08-starknet-react.md:328
#, fuzzy
msgid "A Single Contract Instance"
msgstr "单个合约实例"

#: src/ch02-08-starknet-react.md:330
#, fuzzy
msgid ""
"In certain use cases, working with a single contract instance may be "
"preferable to specifying the contract address and ABI in each hook. Starknet "
"React accommodates this requirement with the useContract hook:"
msgstr ""
"在某些用例中，使用单个合约实例可能比在每个钩子中指定合约地址和 ABI 更可取。"
"Starknet React 使用 useContract 钩子满足了这一要求："

#: src/ch02-08-starknet-react.md:334
#, fuzzy
msgid ""
"```\n"
"const { contract } = useContract({\n"
"    address: CONTRACT_ADDRESS,\n"
"    abi: abi_erc20,\n"
"});\n"
"\n"
"// Call functions directly on contract\n"
"// contract.transfer(...);\n"
"// contract.balanceOf(...);\n"
"```"
msgstr ""
"```\n"
"const { contract }= useContract({\n"
"    address：contract_address、\n"
"    abi: abi_erc20、\n"
"});\n"
"\n"
"// 直接在合约上调用函数\n"
"// contract.transfer(...)；\n"
"// contract.balanceOf(...)；\n"
"```"

#: src/ch02-08-starknet-react.md:343
#, fuzzy
msgid "Tracking Transactions"
msgstr "跟踪交易"

#: src/ch02-08-starknet-react.md:345
#, fuzzy
msgid ""
"The useTransaction hook allows for the tracking of transaction states given a "
"transaction hash. This hook maintains a cache of all transactions, thereby "
"minimizing redundant network requests."
msgstr ""
"使用事务钩子（useTransaction）可根据事务哈希值跟踪事务状态。该钩子会对所有事务"
"进行缓存，从而最大限度地减少冗余网络请求。"

#: src/ch02-08-starknet-react.md:357
#, fuzzy
msgid ""
"The full array of available hooks can be discovered in the Starknet React "
"documentation, accessible here: <https://apibara.github.io/starknet-react/>."
msgstr ""
"全部可用钩子可在 Starknet React 文档中找到，可在此处访问：<https://apibara."
"github.io/starknet-react/>。"

#: src/ch02-08-starknet-react.md:363
#, fuzzy
msgid ""
"The Starknet React library offers a comprehensive suite of React hooks and "
"providers, purpose-built for Starknet and the Starknet.js SDK. By taking "
"advantage of these well-crafted tools, developers can build robust "
"decentralized applications that harness the power of the Starknet network."
msgstr ""
"Starknet React 库提供了一整套 React 钩子和提供程序，专为 Starknet 和 Starknet."
"js SDK 而设计。通过利用这些精心设计的工具，开发人员可以构建强大的去中心化应用"
"程序，充分利用 Starknet 网络的力量。"

#: src/ch02-08-starknet-react.md:369
#, fuzzy
msgid ""
"Through the diligent work of dedicated developers and contributors, Starknet "
"React continues to evolve. New features and optimizations are regularly "
"added, fostering a dynamic and growing ecosystem of decentralized "
"applications."
msgstr ""
"通过尽职尽责的开发人员和贡献者的辛勤工作，Starknet React 不断发展。我们定期添"
"加新功能并进行优化，为去中心化应用营造了一个充满活力、不断发展的生态系统。"

#: src/ch02-08-starknet-react.md:374
#, fuzzy
msgid ""
"It’s a fascinating journey, filled with innovative technology, endless "
"opportunities, and a growing community of passionate individuals. As a "
"developer, you’re not only building applications, but contributing to the "
"advancement of a global, decentralized network."
msgstr ""
"这是一个令人着迷的旅程，充满了创新的技术、无尽的机会和不断壮大的激情社区。作为"
"一名开发人员，你不仅要开发应用程序，还要为全球去中心化网络的发展做出贡献。"

#: src/ch02-08-starknet-react.md:379
#, fuzzy
msgid ""
"Have questions or need help? The Starknet community is always ready to "
"assist. Join the [Starknet Discord](https://discord.gg/starknet) or explore "
"the [StarknetBook’s GitHub repository](https://github.com/starknet-edu/"
"starknetbook) for resources and support."
msgstr ""
"有问题或需要帮助？Starknet社区随时准备提供帮助。加入 [Starknet Discord]"
"(https://discord.gg/starknet) 或访问 [StarknetBook's GitHub repository]"
"(https://github.com/starknet-edu/starknetbook) 获取资源和支持。"

#: src/ch02-08-starknet-react.md:385
msgid "Further Reading"
msgstr "延伸阅读"

#: src/ch02-08-starknet-react.md:387
#, fuzzy
msgid "[Starknet.js](https://starknet.js.org)"
msgstr "[Starknet.js](https://starknet.js.org)"

#: src/ch02-08-starknet-react.md:389
#, fuzzy
msgid "[Starknet React Docs](https://www.apibara.com/starknet-react-docs)"
msgstr "[Starknet React 文档](https://www.apibara.com/starknet-react-docs)"

#: src/ch02-08-starknet-react.md:391
#, fuzzy
msgid "[Mastering Ethereum](https://github.com/ethereumbook/ethereumbook)"
msgstr "[掌握以太坊](https://github.com/ethereumbook/ethereumbook)"

#: src/ch02-08-starknet-react.md:393
#, fuzzy
msgid "[Mastering Bitcoin](https://github.com/bitcoinbook/bitcoinbook)"
msgstr "[掌握比特币](https://github.com/bitcoinbook/bitcoinbook)"

#: src/ch02-11-foundry-forge.md:3
#, fuzzy
msgid ""
"[Starknet Foundry](https://github.com/foundry-rs/starknet-foundry) is a tool "
"designed for testing and developing Starknet contracts. It is an adaptation "
"of the Ethereum Foundry for Starknet, aiming to expedite the development "
"process."
msgstr ""
"[Starknet Foundry](https://github.com/foundry-rs/starknet-foundry) 是一个用于"
"测试和开发Starknet合约的工具。它是以太坊 Foundry 对 Starknet 的改造，旨在加快"
"开发过程。"

#: src/ch02-11-foundry-forge.md:5
#, fuzzy
msgid "The project consists of two primary components:"
msgstr "该项目由两个主要部分组成："

#: src/ch02-11-foundry-forge.md:7
#, fuzzy
msgid ""
"**Forge**: A testing tool specifically for Cairo contracts. This tool acts as "
"a test runner and boasts features designed to enhance your testing process. "
"Tests are written directly in Cairo, eliminating the need for other "
"programming languages. Additionally, the Forge implementation uses Rust, "
"mirroring Ethereum Foundry's choice of language."
msgstr ""
"**Forge**：专门针对Cairo合约的测试工具。该工具可充当测试运行器，并具有旨在增强"
"测试过程的功能。测试直接用Cairo语言编写，无需使用其他编程语言。此外，Forge 采"
"用 Rust 语言，与以太坊 Foundry 的语言选择如出一辙。"

#: src/ch02-11-foundry-forge.md:8
#, fuzzy
msgid ""
"**Cast**: This serves as a DevOps tool for StarkNet, initially supporting a "
"series of commands to interface with StarkNet. In the future, Cast aims to "
"offer deployment scripts for contracts and other DevOps functions."
msgstr ""
"**Cast**：它是 StarkNet 的 DevOps 工具，最初支持一系列与 StarkNet 接口的命令。"
"未来，Cast 的目标是为合约和其他 DevOps 功能提供部署脚本。"

#: src/ch02-11-foundry-forge.md:10
msgid "Forge"
msgstr "锻造"

#: src/ch02-11-foundry-forge.md:12
#, fuzzy
msgid ""
"Merely deploying contracts is not the end game. Many tools have offered this "
"capability in the past. Forge sets itself apart by hosting a Cairo VM "
"instance, enabling the sequential execution of tests. It employs Scarb for "
"contract compilation."
msgstr ""
"仅仅部署合约并不是最终目的。过去，许多工具都提供了这种功能。Forge 通过托管 "
"Cairo 虚拟机实例，实现了测试的顺序执行，从而与众不同。它采用 Scarb 进行合约编"
"译。"

#: src/ch02-11-foundry-forge.md:14
#, fuzzy
msgid ""
"To utilize Forge, define test functions and label them with test attributes. "
"Users can either test standalone Cairo functions or integrate contracts, "
"dispatchers, and test contract interactions on-chain."
msgstr ""
"要使用 Forge，只需定义测试功能并标注测试属性即可。用户既可以测试独立的 Cairo "
"函数，也可以集成合约、调度程序，并测试链上的合约交互。"

#: src/ch02-12-foundry-cast.md:3
#, fuzzy
msgid ""
"While Forge handles testing, Cast focuses on the Command Line Interface (CLI) "
"for StarkNet. This straightforward tool, written in Rust, leverages StarkNet "
"Rust for its operations and is also integrated with Scarb. This integration "
"permits the specification of arguments in Scarb Toml, simplifying the overall "
"process."
msgstr ""
"Forge 负责测试，而 Cast 则专注于 StarkNet 的命令行界面（CLI）。这个用 Rust 编"
"写的简单工具利用 StarkNet Rust 进行操作，并与 Scarb 集成。这种集成允许在 "
"Scarb Toml 中指定参数，从而简化了整个过程。"

#: src/ch03-00-architecture.md:3
#, fuzzy
msgid ""
"This is an introduction to Starknet’s Layer 2 architecture, designed for both "
"beginners and experienced users. It focuses on the key components: "
"Sequencers, Provers, and nodes."
msgstr ""
"本书介绍了Starknet的第 2 层架构，专为初学者和有经验的用户设计。它侧重于关键组"
"件：序列器、证明器和节点。"

#: src/ch03-00-architecture.md:7
#, fuzzy
msgid ""
"Starknet is a coordinated system, with each component—Sequencers, Provers, "
"and nodes—playing a specific yet interconnected role. Although Starknet "
"hasn’t fully decentralized yet, it’s actively moving toward that goal. This "
"understanding of the roles and interactions within the system will help you "
"better grasp the intricacies of the Starknet ecosystem."
msgstr ""
"Starknet是一个协调的系统，每个组成部分--序列器、证明者和节点--都扮演着特定而又"
"相互关联的角色。虽然 Starknet 还没有完全去中心化，但它正积极地向这个目标迈进。"
"对系统内角色和互动的了解将帮助你更好地掌握Starknet生态系统的复杂性。"

#: src/ch03-00-architecture.md:14
#, fuzzy
msgid "High-Level Overview"
msgstr "高层概述"

#: src/ch03-00-architecture.md:16
#, fuzzy
msgid ""
"Starknet’s operation begins when a transaction is received by a gateway, "
"which serves as the Mempool. This stage could also be managed by the "
"Sequencer. The transaction is initially marked as \"RECEIVED.\" The Sequencer "
"then incorporates the transaction into the network state and tags it as "
"\"ACCEPTED_ON_L2.\" The final step involves the Prover, which executes the "
"operating system on the new block, calculates its proof, and submits it to "
"the Layer 1 (L1) for verification."
msgstr ""
"当网关（作为 Mempool）接收到一笔交易时，Starknet 的运行就开始了。这一阶段也可"
"以由序列器管理。事务最初被标记为 \"已接收\"。然后，序列器将事务纳入网络状态，"
"并标记为 \"ACCEPTED_ON_L2\"。最后一步涉及证明者，它在新区块上执行操作系统，计"
"算其证明，并提交给第一层（L1）进行验证。"

#: src/ch03-00-architecture.md:26
#, fuzzy
msgid "Starknet architecture"
msgstr "Starknet架构"

#: src/ch03-00-architecture.md:28
#, fuzzy
msgid "In essence, Starknet’s architecture involves multiple components:"
msgstr "从本质上讲，Starknet的架构涉及多个组成部分："

#: src/ch03-00-architecture.md:30
#, fuzzy
msgid ""
"The Sequencer is responsible for receiving transactions, ordering them, and "
"producing blocks. It operates similarly to validators in Ethereum or Bitcoin."
msgstr ""
"序列器负责接收交易、对交易排序并生成区块。它的操作类似于以太坊或比特币中的验证"
"器。"

#: src/ch03-00-architecture.md:34
#, fuzzy
msgid ""
"The Prover is tasked with generating proofs for the created blocks and "
"transactions. It uses Cairo’s Virtual Machine to run provable programs, "
"thereby creating execution traces necessary for generating STARK proofs."
msgstr ""
"证明者的任务是为创建的区块和事务生成证明。它使用Cairo虚拟机运行可证明程序，从"
"而创建生成 STARK 证明所需的执行轨迹。"

#: src/ch03-00-architecture.md:39
#, fuzzy
msgid ""
"Layer 1 (L1), in this case Ethereum, hosts a smart contract capable of "
"verifying these STARK proofs. If the proofs are valid, Starknet’s state root "
"on L1 is updated."
msgstr ""
"第 1 层（L1），这里指的是以太坊，承载着一个能够验证这些 STARK 证明的智能合约。"
"如果证明有效，Starknet 在 L1 上的状态根就会更新。"

#: src/ch03-00-architecture.md:43
#, fuzzy
msgid ""
"Starknet’s state is a comprehensive snapshot maintained through Merkle trees, "
"much like in Ethereum. This establishes the architecture of the validity roll-"
"up and the roles of each component."
msgstr ""
"Starknet的状态是通过梅克尔树（Merkle tree）维护的综合快照，这与以太坊的情况非"
"常相似。这就确立了有效性卷积的架构和每个组件的作用。"

#: src/ch03-00-architecture.md:47
#, fuzzy
msgid "For a more in-depth look at each component, read on."
msgstr "如需更深入地了解每个组件，请继续阅读。"

#: src/ch03-00-architecture.md:49
#, fuzzy
msgid ""
"After exploring the introductory overview of the different components, delve "
"deeper into their specific roles by referring to their dedicated subchapters "
"in this Chapter."
msgstr ""
"在了解了不同组件的介绍性概述后，请参阅本章中的专门子章节，深入了解它们的具体作"
"用。"

#: src/ch03-00-architecture.md:55
#, fuzzy
msgid ""
"Sequencers are the backbone of the Starknet network, akin to Ethereum’s "
"validators. They usher transactions into the system."
msgstr ""
"序列器是 Starknet 网络的支柱，类似于以太坊的验证器。它们将交易引入系统。"

#: src/ch03-00-architecture.md:58
#, fuzzy
msgid ""
"Validity rollups excel at offloading some network chores, like bundling and "
"processing transactions, to specialized players. This setup is somewhat like "
"how Ethereum and Bitcoin delegate security to miners. Sequencing, like "
"mining, demands hefty resources."
msgstr ""
"有效性卷积擅长于将一些网络杂务（如捆绑和处理交易）卸载给专门的参与者。这种设置"
"有点像以太坊和比特币将安全性委托给矿工的方式。排序和挖矿一样，都需要大量资源。"

#: src/ch03-00-architecture.md:63
#, fuzzy
msgid ""
"For networks like Starknet and other platforms utilizing Validity rollups, a "
"similar parallel is drawn. These networks outsource transaction processing to "
"specialized entities and then verify their work. These specialized entities "
"in the context of Validity rollups are known as \"Sequencers.\""
msgstr ""
"对于像Starknet（Starknet）这样的网络和其他利用有效性卷积（Validity rollups）的"
"平台来说，也有类似的相似之处。这些网络将交易处理外包给专门的实体，然后对其工作"
"进行验证。在有效性滚动的背景下，这些专业实体被称为 \"序列器\"。"

#: src/ch03-00-architecture.md:69
#, fuzzy
msgid ""
"Instead of providing security, as miners do, Sequencers provide transaction "
"capacity. They order (sequence) multiple transactions into a single batch, "
"executes them, and produce a block that will later be proved by the Prover "
"and submmited to the Layer 1 network as a single, compact proof, known as a "
"\"rollup.\" In other words, just as validators in Ethereum and miners in "
"Bitcoin are specialized actors securing the network, Sequencers in Validity "
"rollup-based networks are specialized actors that provide transaction "
"capacity."
msgstr ""
"排序器并不像矿工那样提供安全性，而是提供交易能力。它们将多个交易排序（排序）成"
"一个单一的批次，执行这些交易并生成一个区块，该区块随后将由证明者证明，并作为一"
"个单一、紧凑的证明（称为 \"rollup\"）分发给第一层网络。换句话说，就像以太坊中"
"的验证者和比特币中的矿工是确保网络安全的专门角色一样，基于有效性卷积的网络中的"
"排序器也是提供交易能力的专门角色。"

#: src/ch03-00-architecture.md:78
#, fuzzy
msgid ""
"This mechanism allows Validity (or ZK) rollups to handle a higher volume of "
"transactions while maintaining the security of the underlying Ethereum "
"network. It enhances scalability without compromising on security."
msgstr ""
"这种机制允许有效性（或 ZK）卷积处理更大量的交易，同时维护底层以太坊网络的安全"
"性。它增强了可扩展性，同时又不影响安全性。"

#: src/ch03-00-architecture.md:83
#, fuzzy
msgid "Sequencers follow a systematic method for transaction processing:"
msgstr "排序器采用系统化方法进行事务处理："

#: src/ch03-00-architecture.md:85
#, fuzzy
msgid ""
"Sequencing: They collect transactions from users and order (sequence) them."
msgstr "排序：它们收集用户的交易并对其进行排序（排序）。"

#: src/ch03-00-architecture.md:88
#, fuzzy
msgid "Executing: Sequencers then process these transactions."
msgstr "执行：然后，序列器处理这些事务。"

#: src/ch03-00-architecture.md:90
#, fuzzy
msgid ""
"Batching: Transactions are grouped together in batches or blocks for "
"efficiency."
msgstr "批处理：交易以批次或区块的形式组合在一起，以提高效率。"

#: src/ch03-00-architecture.md:93
#, fuzzy
msgid ""
"Block Production: Sequencers produce blocks that contain batches of processed "
"transactions."
msgstr "区块生产：排序器生产包含已处理交易批次的区块。"

#: src/ch03-00-architecture.md:96
#, fuzzy
msgid ""
"Sequencers must be reliable and highly available, as their role is critical "
"to the network’s smooth functioning. They need powerful and well-connected "
"machines to perform their role effectively, as they must process transactions "
"rapidly and continuously."
msgstr ""
"排序器必须可靠且可用性高，因为它们的作用对网络的平稳运行至关重要。它们需要功能"
"强大、连接良好的机器才能有效发挥作用，因为它们必须快速、连续地处理交易。"

#: src/ch03-00-architecture.md:101
#, fuzzy
msgid ""
"The current roadmap for Starknet includes decentralizing the Sequencer role. "
"This shift towards decentralization will allow more participants to become "
"Sequencers, contributing to the robustness of the network."
msgstr ""
"Starknet当前的路线图包括分散序列员的角色。这种去中心化的转变将使更多的参与者成"
"为序列员，从而增强网络的稳健性。"

#: src/ch03-00-architecture.md:105
#, fuzzy
msgid ""
"For more details in the Sequencer role, refer to the dedicated subchapter in "
"this Chapter."
msgstr "有关序列器角色的更多详情，请参阅本章的专门子章节。"

#: src/ch03-00-architecture.md:108 src/ch03-03-provers.md:1
#, fuzzy
msgid "Provers"
msgstr "证明器 🚧"

#: src/ch03-00-architecture.md:110
#, fuzzy
msgid ""
"Provers serve as the second line of verification in the Starknet network. "
"Their main task is to validate the work of the Sequencers (when they receive "
"the block produced by the Sequencer) and to generate proofs that these "
"processes were correctly performed."
msgstr ""
"验证器是Starknet的第二道验证关卡。它们的主要任务是验证序列发生器的工作（当它们"
"接收到序列发生器生成的区块时），并生成这些过程正确执行的证明。"

#: src/ch03-00-architecture.md:115
#, fuzzy
msgid "The duties of a Prover include:"
msgstr "Prover 的职责包括"

#: src/ch03-00-architecture.md:117
#, fuzzy
msgid ""
"Receiving Blocks: Provers obtain blocks of processed transactions from "
"Sequencers."
msgstr "接收区块：证明者从序列器中获取已处理的交易块。"

#: src/ch03-00-architecture.md:120
#, fuzzy
msgid ""
"Processing: Provers process these blocks a second time, ensuring that all "
"transactions within the block have been correctly handled."
msgstr ""
"处理：验证者对这些区块进行第二次处理，确保区块内的所有交易都得到正确处理。"

#: src/ch03-00-architecture.md:123
#, fuzzy
msgid ""
"Proof Generation: After processing, Provers generate a proof of correct "
"transaction processing."
msgstr "生成证明：处理完成后，Provers 生成交易处理正确性的证明。"

#: src/ch03-00-architecture.md:126
#, fuzzy
msgid ""
"Sending Proof to Ethereum: Finally, the proof is sent to the Ethereum network "
"for validation. If the proof is correct, the Ethereum network accepts the "
"block of transactions."
msgstr ""
"向以太坊发送证明：最后，将证明发送到以太坊网络进行验证。如果证明正确，以太坊网"
"络就会接受该交易块。"

#: src/ch03-00-architecture.md:130
#, fuzzy
msgid ""
"Provers need even more computational power than Sequencers because they have "
"to calculate and generate proofs, a process that is computationally heavy. "
"However, the work of Provers can be split into multiple parts, allowing for "
"parallelism and efficient proof generation. The proof generation process is "
"asynchronous, meaning it doesn’t have to occur immediately or in real-time. "
"This flexibility allows for the workload to be distributed among multiple "
"Provers. Each Prover can work on a different block, allowing for parallelism "
"and efficient proof generation."
msgstr ""
"证明者所需的计算能力甚至比序列器更强，因为它们必须计算和生成证明，而这是一个计"
"算量很大的过程。不过，证明者的工作可以分成多个部分，从而实现并行和高效的证明生"
"成。证明生成过程是异步的，这意味着它不必立即或实时进行。这种灵活性允许将工作量"
"分配给多个证明者。每个证明者可以处理不同的区块，从而实现并行和高效的证明生成。"

#: src/ch03-00-architecture.md:140
#, fuzzy
msgid ""
"The design of Starknet relies on these two types of actors — Sequencers and "
"Provers — working in tandem to ensure efficient processing and secure "
"verification of transactions."
msgstr ""
"Starknet的设计依赖于这两类参与者--排序者和证明者--的协同工作，以确保交易的高效"
"处理和安全验证。"

#: src/ch03-00-architecture.md:144
#, fuzzy
msgid ""
"For more details in the Prover role, refer to the dedicated subchapter in "
"this Chapter."
msgstr "有关 Prover 角色的更多详情，请参阅本章的专门子章节。"

#: src/ch03-00-architecture.md:147
#, fuzzy
msgid "Optimizing Sequencers and Provers: Debunking Common Misconceptions"
msgstr "优化序列器和校验器：揭穿常见误解"

#: src/ch03-00-architecture.md:149
#, fuzzy
msgid ""
"The relationship between Sequencers and Provers in blockchain technology "
"often sparks debate. A common misunderstanding suggests that either the "
"Prover or the Sequencer is the main bottleneck. To set the record straight, "
"let’s discuss the optimization of both components."
msgstr ""
"区块链技术中的序列器和证明器之间的关系经常引发争论。一个常见的误解是，证明者或"
"序列器是主要瓶颈。为了澄清事实，让我们来讨论一下这两个组件的优化问题。"

#: src/ch03-00-architecture.md:154
#, fuzzy
msgid ""
"Starknet, utilizing the Cairo programming language, currently supports only "
"sequential transactions. Plans are in place to introduce parallel "
"transactions in the future. However, as of now, the Sequencer operates one "
"transaction at a time, making it the bottleneck in the system."
msgstr ""
"Starknet采用Cairo编程语言，目前只支持顺序事务。未来计划引入并行事务。不过，目"
"前序列发生器一次只能处理一个事务，成为系统的瓶颈。"

#: src/ch03-00-architecture.md:159
#, fuzzy
msgid ""
"In contrast, Provers operate asynchronously and can execute multiple tasks in "
"parallel. The use of proof recursion allows for task distribution across "
"multiple machines, making scalability less of an issue for Provers."
msgstr ""
"相比之下，Provers 采用异步方式运行，可以并行执行多个任务。使用证明递归可以将任"
"务分配到多台机器上，从而减少了证明者的可扩展性问题。"

#: src/ch03-00-architecture.md:164
#, fuzzy
msgid ""
"Given the asynchronous and scalable nature of Provers, focus in Starknet has "
"shifted to enhancing the Sequencer’s efficiency. This explains why current "
"development efforts are primarily aimed at the sequencing side of the "
"equation."
msgstr ""
"鉴于 Provers 的异步和可扩展特性，Starknet 的重点已转向提高排序器的效率。这也解"
"释了为什么目前的开发工作主要针对等式的排序方面。"

#: src/ch03-00-architecture.md:169 src/ch03-04-nodes.md:1
msgid "Nodes"
msgstr "节点"

#: src/ch03-00-architecture.md:171
#, fuzzy
msgid ""
"When it comes to defining what nodes do in Bitcoin or Ethereum, people often "
"misinterpret their role as keeping track of every transaction within the "
"network. This, however, is not entirely accurate."
msgstr ""
"说到节点在比特币或以太坊中的作用，人们往往会误解它们的作用是跟踪网络中的每一笔"
"交易。然而，这并不完全准确。"

#: src/ch03-00-architecture.md:175
#, fuzzy
msgid ""
"Nodes serve as auditors of the network, maintaining the state of the network, "
"such as how much Bitcoin each participant owns or the current state of a "
"specific smart contract. They accomplish this by processing transactions and "
"preserving a record of all transactions, but that’s a means to an end, not "
"the end itself."
msgstr ""
"节点是网络的审计员，负责维护网络的状态，比如每个参与者拥有多少比特币，或者某个"
"智能合约的当前状态。它们通过处理交易和保存所有交易记录来实现这一目的，但这只是"
"达到目的的手段，而不是目的本身。"

#: src/ch03-00-architecture.md:181
#, fuzzy
msgid ""
"In Validity rollups and specifically within Starknet, this concept is "
"somewhat reversed. Nodes don’t necessarily have to process transactions to "
"get the state. In contrast to Ethereum or Bitcoin, Starknet nodes aren’t "
"required to process all transactions to maintain the state of the network."
msgstr ""
"在 Validity rollups 中，特别是在 Starknet 中，这个概念在某种程度上是相反的。节"
"点不一定要处理交易才能获得状态。与以太坊或比特币相比，Starknet 节点不需要处理"
"所有交易来维持网络状态。"

#: src/ch03-00-architecture.md:187
#, fuzzy
msgid ""
"There are two main ways to access network state data: via an API gateway or "
"using the RPC protocol to communicate with a node. Operating your own node is "
"typically faster than using a shared architecture, like the gateway. Over "
"time, Starknet plans to deprecate APIs and replace them with a JSON RPC "
"standard, making it even more beneficial to operate your own node."
msgstr ""
"访问网络状态数据有两种主要方式：通过 API 网关或使用 RPC 协议与节点通信。操作自"
"己的节点通常比使用网关等共享架构要快。随着时间的推移，Starknet 计划淘汰 API，"
"代之以 JSON RPC 标准，从而使操作自己的节点更为有利。"

#: src/ch03-00-architecture.md:194
#, fuzzy
msgid ""
"It’s worth noting that encouraging more people to run nodes increases the "
"resilience of the network and prevents server flooding, which has been an "
"issue in networks in other L2s."
msgstr ""
"值得注意的是，鼓励更多的人运行节点可以提高网络的弹性，防止服务器泛洪，这在其他"
"二级网络中一直是个问题。"

#: src/ch03-00-architecture.md:198
#, fuzzy
msgid ""
"Currently, there are primarily three methods for a node to keep track of the "
"network’s state and we can have nodes implement any of these methods:"
msgstr ""
"目前，节点主要有三种方法来跟踪网络状态，我们可以让节点实现其中任何一种方法："

#: src/ch03-00-architecture.md:202
#, fuzzy
msgid ""
"**Replaying Old Transactions**: Like Ethereum or Bitcoin, a node can take all "
"the transactions and re-execute them. Although this approach is accurate, it "
"isn’t scalable unless you have a powerful machine that’s capable of handling "
"the load. If you can replay all transactions, you can become a Sequencer."
msgstr ""
"**Replaying Old Transactions**：与以太坊或比特币一样，节点可以获取所有交易并重"
"新执行。虽然这种方法很准确，但它不具有可扩展性，除非你有一台能够处理负载的强大"
"机器。如果你能重放所有交易，你就能成为序列器。"

#: src/ch03-00-architecture.md:208
#, fuzzy
msgid ""
"**Relying on L2 Consensus**: Nodes can trust the Sequencer(s) to execute the "
"network correctly. When the Sequencer updates the state and adds a new block, "
"nodes accept the update as accurate."
msgstr ""
"**依靠二级共识**：节点可以信赖序列器正确执行网络。当序列器更新状态并添加新区块"
"时，节点会认为更新是准确的。"

#: src/ch03-00-architecture.md:212
#, fuzzy
msgid ""
"**Checking Proof Validation on L1**: Nodes can monitor the state of the "
"network by observing L1 and ensuring that every time a proof is sent, they "
"receive the updated state. This way, they don’t have to trust anyone and only "
"need to keep track of the latest valid transaction for Starknet."
msgstr ""
"**在 L1 上检查证明验证**：节点可以通过观察 L1 来监控网络状态，并确保每次发送证"
"明时都能收到更新的状态。这样，它们就不必信任任何人，只需跟踪Starknet的最新有效"
"交易即可。"

#: src/ch03-00-architecture.md:218
#, fuzzy
msgid ""
"Each type of node setup comes with its own set of hardware requirements and "
"trust assumptions."
msgstr "每种节点设置都有自己的硬件要求和信任假设。"

#: src/ch03-00-architecture.md:221
#, fuzzy
msgid "Nodes That Replay Transactions"
msgstr "重播交易的节点"

#: src/ch03-00-architecture.md:223
#, fuzzy
msgid ""
"Nodes that replay transactions require powerful machines to track and execute "
"all transactions. These nodes don’t have trust assumptions; they rely solely "
"on the transactions they execute, guaranteeing that the state at any given "
"point is valid."
msgstr ""
"重放事务的节点需要强大的机器来跟踪和执行所有事务。这些节点没有信任假设；它们完"
"全依赖自己执行的事务，保证任何给定点的状态都是有效的。"

#: src/ch03-00-architecture.md:228
#, fuzzy
msgid "Nodes That Rely on L2 Consensus"
msgstr "依赖 L2 共识的节点"

#: src/ch03-00-architecture.md:230
#, fuzzy
msgid ""
"Nodes relying on L2 consensus require less computational power. They need "
"sufficient storage to keep the state but don’t need to process a lot of "
"transactions. The trade-off here is a trust assumption. Currently, Starknet "
"revolves around one Sequencer, so these nodes are trusting Starkware not to "
"disrupt the network. However, once a consensus mechanism and leader election "
"amongst Sequencers are in place, these nodes will only need to trust that a "
"Sequencer who staked their stake to produce a block is not willing to lose it."
msgstr ""
"依赖 L2 共识的节点所需的计算能力较低。它们需要足够的存储空间来保存状态，但不需"
"要处理大量的事务。这里需要权衡的是信任假设。目前，Starknet 围绕着一个序列器运"
"转，因此这些节点相信 Starkware 不会破坏网络。然而，一旦共识机制和序列发生器之"
"间的领导者选举到位，这些节点就只需要相信，押上自己的赌注来产生区块的序列发生器"
"是不愿意失去它的。"

#: src/ch03-00-architecture.md:239
#, fuzzy
msgid "Nodes That Check Proof Validation on L1"
msgstr "在 L1 上检查证明验证的节点"

#: src/ch03-00-architecture.md:241
#, fuzzy
msgid ""
"Nodes that only update their state based on proof validation on L1 require "
"the least hardware. They have the same requirements as an Ethereum node, and "
"once Ethereum light nodes become a reality, maintaining such a node could be "
"as simple as using a smartphone. The only trade-off is latency. Proofs are "
"not sent to Ethereum every block but intermittently, resulting in delayed "
"state updates. Plans are in place to produce proofs more frequently, even if "
"they are not sent to Ethereum immediately, allowing these nodes to reduce "
"their latency. However, this development is still a way off in the Starknet "
"roadmap."
msgstr ""
"只根据 L1 上的证明验证更新状态的节点所需的硬件最少。它们的要求与以太坊节点相"
"同，一旦以太坊轻节点成为现实，维护这样的节点就像使用智能手机一样简单。唯一的权"
"衡是延迟。证明并不是每个区块都发送到以太坊，而是断断续续地发送，这就导致了状态"
"更新的延迟。目前已计划更频繁地生成证明，即使不立即发送到以太坊，也能让这些节点"
"减少延迟。不过，在 Starknet 的路线图中，这一发展还遥遥无期。"

#: src/ch03-00-architecture.md:253
#, fuzzy
msgid ""
"Through this chapter, we delve into Starknet’s structure, uncovering the "
"importance of Sequencers, Provers, and nodes. Each plays a unique role, but "
"together, they create a highly scalable, efficient, and secure network that "
"marks a significant step forward in Layer 2 solutions. As Starknet evolves "
"towards decentralization, understanding these roles will provide valuable "
"insight into the inner workings of this network."
msgstr ""
"在本章中，我们将深入研究Starknet的结构，揭示序列器、证明器和节点的重要性。它们"
"各自扮演着独特的角色，但共同创建了一个高度可扩展、高效和安全的网络，标志着第 "
"2 层解决方案向前迈出了重要一步。随着 Starknet 向去中心化方向发展，了解这些角色"
"将为深入了解该网络的内部运作提供宝贵的信息。"

#: src/ch03-00-architecture.md:260
#, fuzzy
msgid ""
"As we venture further into the Starknet universe, our next stop will be an "
"exploration of the transaction lifecycle before we dive into the heart of "
"coding with Cairo."
msgstr ""
"在我们进一步探索Starknet世界的过程中，下一站将是探索事务生命周期，然后再进入使"
"用Cairo编码的核心。"

#: src/ch03-02-sequencers.md:3
#, fuzzy
msgid ""
"Before diving in, make sure to check out the [\"Understanding Starknet: "
"Sequencers, Provers, and Nodes\"](https://book.starknet.io/chapter_3/topology."
"html) chapter for a quick rundown of Starknet’s architecture."
msgstr ""
"在深入了解之前，请务必查看[\"了解Starknet：序列器、证明器和节点\"](https://"
"book.starknet.io/chapter_3/topology.html) 章节，快速了解Starknet的架构。"

#: src/ch03-02-sequencers.md:8
#, fuzzy
msgid ""
"Three main layers exist in blockchain: data availability, ordering, and "
"execution. Sequencers have evolved within this evolving modular landscape of "
"blockchain technology. Most L1 blockchains, like Ethereum, handle all these "
"tasks. Initially, blockchains served as distributed virtual machines focused "
"on organizing and executing transactions. Even roll-ups running on Ethereum "
"today often centralize sequencing (ordering) and execution while relying on "
"Ethereum for data availability. This is the current state of Starknet, which "
"uses Ethereum for data availability and a centralized Sequencer for ordering "
"and execution. However, it is possible to decentralize sequencing and "
"execution, as Starknet is doing."
msgstr ""
"区块链有三个主要层次：数据可用性、排序和执行。排序器就是在区块链技术不断发展的"
"模块化环境中演变而来的。大多数 L1 区块链（如以太坊）处理所有这些任务。最初，区"
"块链作为分布式虚拟机，专注于组织和执行交易。如今，即使是在以太坊上运行的卷积链"
"也经常集中排序（排序）和执行，同时依赖以太坊提供数据可用性。这就是 Starknet 的"
"现状，它使用以太坊提供数据可用性，使用集中式排序器进行排序和执行。然而，正如 "
"Starknet 正在做的那样，去中心化排序和执行也是可能的。"

#: src/ch03-02-sequencers.md:20
#, fuzzy
msgid ""
"Each of these layers plays a crucial role in achieving consensus. First, the "
"data must be available. Second, it needs to be put in a specific order. "
"That’s the main job of a Sequencer, whether run by a single computer or a "
"decentralized protocol. Lastly, you execute transactions in the order they’ve "
"been sequenced. This final step, done by the Sequencer too, determines the "
"system’s current state and keeps all connected clients on the same page."
msgstr ""
"在达成共识的过程中，每一层都起着至关重要的作用。首先，数据必须可用。其次，数据"
"必须按照特定顺序排列。这就是排序器的主要工作，无论是由单台计算机还是分散式协议"
"运行。最后，按顺序执行交易。这最后一步也由序列器完成，它决定了系统的当前状态，"
"并让所有连接的客户端保持一致。"

#: src/ch03-02-sequencers.md:28
#, fuzzy
msgid "Introduction to Sequencers"
msgstr "音序器简介"

#: src/ch03-02-sequencers.md:30
#, fuzzy
msgid ""
"The advent of Layer Two (L2) solutions like Roll-Ups has altered the "
"blockchain landscape, improving scalability and efficiency. But what about "
"transaction order? Is it still managed by the base layer (L1), or is an "
"external system involved? Enter Sequencers. They ensure transactions are in "
"the correct order, regardless of whether they’re managed by L1 or another "
"system."
msgstr ""
"Roll-Ups 等第二层（L2）解决方案的出现改变了区块链的格局，提高了可扩展性和效"
"率。但是，交易订单怎么办？是仍由基础层（L1）管理，还是需要外部系统参与？进入序"
"列器。无论交易是由 L1 还是其他系统管理，它们都能确保交易顺序正确。"

#: src/ch03-02-sequencers.md:37
#, fuzzy
msgid ""
"In essence, sequencing has two core tasks: sequencing (ordering) and "
"executing (validation). First, it orders transactions, determining the "
"canonical sequence of blocks for a given chain fork. It then appends new "
"blocks to this sequence. Second, it executes these transactions, updating the "
"system’s state based on a given function."
msgstr ""
"从本质上讲，排序有两个核心任务：排序（排序）和执行（验证）。首先，它对交易进行"
"排序，为给定的链分叉确定区块的规范序列。然后，它将新区块添加到该序列中。其次，"
"它执行这些事务，根据给定函数更新系统状态。"

#: src/ch03-02-sequencers.md:43
#, fuzzy
msgid ""
"To clarify, we see sequencing as the act of taking a group of unordered "
"transactions and producing an ordered block. Sequencers also confirm the "
"resulting state of the machine. However, the approach explained here "
"separates these tasks. While some systems handle both ordering and state "
"validation simultaneously, we advocate for treating them as distinct steps."
msgstr ""
"为了明确起见，我们将排序视为处理一组无序事务并生成一个有序区块的行为。排序器还"
"会确认机器的结果状态。不过，本文介绍的方法将这些任务分开。虽然有些系统会同时处"
"理排序和状态验证，但我们主张将它们视为不同的步骤。"

#: src/ch03-02-sequencers.md:52
#, fuzzy
msgid "Sequencer role in the Starknet network"
msgstr "Starknet中的测序器角色"

#: src/ch03-02-sequencers.md:54
#, fuzzy
msgid "Sequencers in Starknet"
msgstr "Starknet中的测序仪"

#: src/ch03-02-sequencers.md:56
#, fuzzy
msgid ""
"Let’s delve into Sequencers by focusing on [Madara](https://github.com/keep-"
"starknet-strange/madara) and [Kraken](https://github.com/lambdaclass/"
"starknet_stack/tree/main/sequencer), two high-performance Starknet "
"Sequencers. A Sequencer must, at least, do two things: order and execute "
"transactions."
msgstr ""
"让我们以 [Madara](https://github.com/keep-starknet-strange/madara) 和 [Kraken]"
"(https://github.com/lambdaclass/starknet_stack/tree/main/sequencer)这两个高性"
"能Starknet序列器为重点，深入了解序列器。序列器至少必须做两件事：订购和执行事"
"务。"

#: src/ch03-02-sequencers.md:62
#, fuzzy
msgid ""
"**Ordering**: Madara handles the sequencing process, supporting methods from "
"simple FCFS and PGA to complex ones like Narwhall & Bullshark. It also "
"manages the mempool, a critical data structure that holds unconfirmed "
"transactions. Developers can choose the consensus protocol through Madara’s "
"use of Substrate, which offers multiple built-in options."
msgstr ""
"**排序**：Madara 处理排序过程，支持从简单的 FCFS 和 PGA 到复杂的 Narwhall 和 "
"Bullshark 等方法。它还负责管理mempool，这是一个保存未确认交易的重要数据结构。"
"开发人员可以通过 Madara 使用的 Substrate（提供多种内置选项）选择共识协议。"

#: src/ch03-02-sequencers.md:69
#, fuzzy
msgid ""
"**Execution**: Madara lets you choose between two execution crates: "
"[Blockifier](https://github.com/starkware-libs/blockifier/tree/main) and "
"[Starknet_in_Rust](https://github.com/lambdaclass/starknet_in_rust). Both use "
"the [Cairo VM](https://github.com/lambdaclass/cairo-vm) for their framework."
msgstr ""
"**处决**：玛达拉让你在两个执行箱子中进行选择：[Blockifier](https://github.com/"
"starkware-libs/blockifier/tree/main)和[Starknet_in_Rust](https://github.com/"
"lambdaclass/starknet_in_rust)。两者都使用 [Cairo VM](https://github.com/"
"lambdaclass/cairo-vm) 作为框架。"

#: src/ch03-02-sequencers.md:76
#, fuzzy
msgid "We also have the Kraken Sequencer as another option."
msgstr "我们还有 Kraken Sequencer 作为另一种选择。"

#: src/ch03-02-sequencers.md:78
#, fuzzy
msgid ""
"**Ordering**: It employs Narwhall & Bullshark for mempool management. You can "
"choose from multiple consensus methods, like Bullshark, Tendermint, or "
"Hotstuff."
msgstr ""
"**订购**：它采用 Narwhall 和 Bullshark 进行内存池管理。你可以选择多种共识方"
"法，如 Bullshark、Tendermint 或 Hotstuff。"

#: src/ch03-02-sequencers.md:82
#, fuzzy
msgid ""
"**Execution**: Runs on Starknet_in_Rust. Execution can be deferred to either "
"[Cairo Native](https://github.com/lambdaclass/cairo_native) or [Cairo VM]"
"(https://github.com/lambdaclass/cairo-vm)."
msgstr ""
"**执行**：在Starknet（Starknet_in_Rust）上运行。可推迟到 [Cairo Native]"
"(https://github.com/lambdaclass/cairo_native) 或 [Cairo VM](https://github."
"com/lambdaclass/cairo-vm) 执行。"

#: src/ch03-02-sequencers.md:145
#, fuzzy
msgid "Understanding the Execution Layer"
msgstr "了解执行层"

#: src/ch03-02-sequencers.md:147
#, fuzzy
msgid ""
"[Blockifier](https://github.com/starkware-libs/blockifier/tree/main), a Rust "
"component in Starknet Sequencers, generates state diffs and blocks. It uses "
"[Cairo VM](https://github.com/lambdaclass/cairo-vm). Its goal is to become a "
"full Starknet Sequencer."
msgstr ""
"[Blockifier](https://github.com/starkware-libs/blockifier/tree/main)是 "
"Starknet Sequencers 中的一个 Rust 组件，用于生成状态差异和块。它使用 [Cairo "
"VM](https://github.com/lambdaclass/cairo-vm)。它的目标是成为一个完整的 "
"Starknet 序列器。"

#: src/ch03-02-sequencers.md:152
#, fuzzy
msgid ""
"Starknet_in_Rust is another Rust component for Starknet that also generates "
"state diffs and blocks. It uses [Cairo VM](https://github.com/lambdaclass/"
"cairo-vm)."
msgstr ""
"Starknet_in_Rust是Starknet的另一个Rust组件，也能生成状态差异和区块。它使用 "
"[Cairo VM](https://github.com/lambdaclass/cairo-vm)。"

#: src/ch03-02-sequencers.md:156
#, fuzzy
msgid ""
"[Cairo Native](https://github.com/lambdaclass/cairo_native) stands out by "
"converting Cairo’s Sierra code to MLIR. See an example [here](https://github."
"com/lambdaclass/cairo_native/blob/main/examples/erc20.rs)."
msgstr ""
"[Cairo Native](https://github.com/lambdaclass/cairo_native) 通过将 Cairo 的 "
"Sierra 代码转换为 MLIR 而脱颖而出。请参阅示例 [此处](https://github.com/"
"lambdaclass/cairo_native/blob/main/examples/erc20.rs)。"

#: src/ch03-02-sequencers.md:160
#, fuzzy
msgid "The Need for Decentralized Sequencers"
msgstr "需要分散式测序仪"

#: src/ch03-02-sequencers.md:162
#, fuzzy
msgid ""
"For more details on the Decentralization of Starknet, refer to the dedicated "
"subchapter in this Chapter."
msgstr "有关Starknet权力下放的更多详情，请参阅本章的专门分章。"

#: src/ch03-02-sequencers.md:165
#, fuzzy
msgid ""
"Proving transactions doesn’t required to be decentralized (although in the "
"near future Starknet will operate with decentralized provers). Once the order "
"is set, anyone can submit a proof; it’s either correct or not. However, the "
"process that determines this order should be decentralized to maintain a "
"blockchain’s original qualities."
msgstr ""
"证明交易并不需要去中心化（尽管在不久的将来，Starknet将使用去中心化的证明器）。"
"一旦顺序确定，任何人都可以提交证明；证明要么正确，要么不正确。不过，确定这一顺"
"序的过程应该是去中心化的，以保持区块链的原有特性。"

#: src/ch03-02-sequencers.md:171
#, fuzzy
msgid ""
"In the context of Ethereum’s Layer 1 (L1), Sequencers can be likened to "
"Ethereum validators. They are responsible for creating and broadcasting "
"blocks. This role is divided under the concept of \"Proposer-Builder "
"Separation\" (PBS) ([Hasu, 2023](https://www.youtube.com/watch?"
"v=6xS0xMzh9Tc)). Block builders form blocks (order the transactions), while "
"block proposers, unaware of the block’s content, choose the most profitable "
"one. This separation prevents transaction censorship at the protocol level. "
"Currently, most Layer 2 (L2) Sequencers, including Starknet, perform both "
"roles, which can create issues."
msgstr ""
"在以太坊第一层（L1）中，序列器可以比作以太坊验证器。它们负责创建和广播区块。这"
"一角色是根据 \"提议者-构建者分离\"（PBS）的概念划分的（[Hasu, 2023](https://"
"www.youtube.com/watch?v=6xS0xMzh9Tc)）。区块构建者形成区块（对交易排序），而区"
"块提议者在不了解区块内容的情况下选择最有利可图的区块。这种分离防止了协议层面的"
"交易审查。目前，包括 Starknet 在内的大多数第二层（L2）序列器都同时扮演这两种角"
"色，这可能会产生问题。"

#: src/ch03-02-sequencers.md:182
#, fuzzy
msgid ""
"The drive toward centralized Sequencers mainly stems from performance issues "
"like high costs and poor user experience on Ethereum for both data storage "
"and transaction ordering. The challenge is scalability: how to expand without "
"sacrificing decentralization. Opting for centralization risks turning the "
"blockchain monopolistic, negating its unique advantages like network-effect "
"services without monopoly."
msgstr ""
"推动集中式序列器发展的主要原因是以太坊在数据存储和交易排序方面存在成本高、用户"
"体验差等性能问题。挑战在于可扩展性：如何在不牺牲去中心化的前提下进行扩展。选择"
"中心化有可能使区块链变成垄断性的，从而抵消其独特的优势，如没有垄断的网络效应服"
"务。"

#: src/ch03-02-sequencers.md:189
#, fuzzy
msgid ""
"With centralization, blockchain loses its core principles: credible "
"neutrality and resistance to monopolization. What’s wrong with a centralized "
"system? It raises the risks of censorship (via transaction reordering)."
msgstr ""
"随着中心化的发展，区块链失去了其核心原则：可信的中立性和抵制垄断。中心化系统有"
"什么问题？它提高了审查的风险（通过交易重新排序）。"

#: src/ch03-02-sequencers.md:194
#, fuzzy
msgid "A centralized validity roll-up looks like this:"
msgstr "集中式有效性卷积看起来像这样："

#: src/ch03-02-sequencers.md:196
#, fuzzy
msgid ""
"User Interaction & Selection: Users send transactions to a centralized "
"Sequencer, which selects and orders them."
msgstr "用户交互与选择：用户向中央序列器发送交易，由序列器进行选择和排序。"

#: src/ch03-02-sequencers.md:199
#, fuzzy
msgid ""
"Block Formation: The Sequencer packages these ordered transactions into a "
"block."
msgstr "区块形成：序列器将这些有序的事务打包成一个程序块。"

#: src/ch03-02-sequencers.md:202
#, fuzzy
msgid ""
"Proof & Verification: The block is sent to a proving service, which generates "
"a proof and posts it to Layer 1 (L1) for verification."
msgstr ""
"证明与验证：区块被发送到证明服务，由其生成证明并发布到第一层（L1）进行验证。"

#: src/ch03-02-sequencers.md:205
#, fuzzy
msgid ""
"Verification: Once verified on L1, the transactions are considered finalized "
"and integrated into the L1 blockchain."
msgstr "验证：一旦在 L1 上通过验证，交易即被视为最终完成并纳入 L1 区块链。"

#: src/ch03-02-sequencers.md:210
#, fuzzy
msgid "Centralized rollup"
msgstr "集中滚动"

#: src/ch03-02-sequencers.md:212
#, fuzzy
msgid ""
"While centralized roll-ups can provide L1 security, they come with a "
"significant downside: the risk of censorship. Hence, the push for "
"decentralization in roll-ups."
msgstr ""
"虽然集中式卷积可以提供 L1 安全性，但也有很大的弊端：审查风险。因此，人们开始推"
"动分散式卷积。"

#: src/ch03-02-sequencers.md:218
#, fuzzy
msgid ""
"This chapter has dissected the role of Sequencers in the complex ecosystem of "
"blockchain technology, focusing on Starknet’s current state and future "
"directions. Sequencers essentially serve two main functions: ordering "
"transactions and executing them. While these tasks may seem straightforward, "
"they are pivotal in achieving network consensus and ensuring security."
msgstr ""
"本章剖析了序列器在复杂的区块链技术生态系统中的作用，重点介绍了 Starknet 的现状"
"和未来发展方向。序列器主要有两大功能：订购交易和执行交易。这些任务看似简单，但"
"在达成网络共识和确保安全方面却至关重要。"

#: src/ch03-02-sequencers.md:225
#, fuzzy
msgid ""
"Given the evolving modular architecture of blockchain—with distinct layers "
"for data availability, transaction ordering, and execution—Sequencers provide "
"a crucial link. Their role gains more significance in the context of Layer 2 "
"solutions, where achieving scalability without sacrificing decentralization "
"is a pressing concern."
msgstr ""
"鉴于区块链不断发展的模块化架构--在数据可用性、交易排序和执行方面具有不同的层"
"级--分隔符提供了一个关键环节。在第 2 层解决方案中，它们的作用变得更加重要，因"
"为在不牺牲去中心化的前提下实现可扩展性是一个迫切需要解决的问题。"

#: src/ch03-02-sequencers.md:231
#, fuzzy
msgid ""
"In Starknet, Sequencers like Madara and Kraken demonstrate the potential of "
"high-performance, customizable solutions. These Sequencers allow for a range "
"of ordering methods and execution frameworks, proving that there’s room for "
"innovation even within seemingly rigid structures."
msgstr ""
"在Starknet中，Madara 和 Kraken 等序列器展示了高性能、可定制解决方案的潜力。这"
"些序列器允许使用一系列排序方法和执行框架，证明即使在看似僵化的结构中也有创新的"
"空间。"

#: src/ch03-02-sequencers.md:236
#, fuzzy
msgid ""
"The discussion on \"Proposer-Builder Separation\" (PBS) highlights the need "
"for role specialization to maintain a system’s integrity and thwart "
"transaction censorship. This becomes especially crucial when we recognize "
"that the current model of many L2 Sequencers, Starknet included, performs "
"both proposing and building, potentially exposing the network to "
"vulnerabilities."
msgstr ""
"关于 \"提议者与构建者分离\"（PBS）的讨论强调了角色专业化对于维护系统完整性和挫"
"败交易审查的必要性。当我们认识到许多 L2 排序器（包括Starknet）的当前模式都同时"
"执行提议和构建功能时，这一点就变得尤为重要，因为这有可能使网络暴露于漏洞之中。"

#: src/ch03-02-sequencers.md:243
#, fuzzy
msgid ""
"To reiterate, Sequencers aren’t just a mechanism for transaction ordering and "
"execution; they are a linchpin in blockchain’s decentralized ethos. Whether "
"centralized or decentralized, Sequencers must strike a delicate balance "
"between scalability, efficiency, and the overarching principle of "
"decentralization."
msgstr ""
"重申一下，序列器不仅仅是交易排序和执行的机制，还是区块链去中心化精神的关键。无"
"论是中心化还是去中心化，序列器都必须在可扩展性、效率和去中心化的总体原则之间取"
"得微妙的平衡。"

#: src/ch03-02-sequencers.md:249
#, fuzzy
msgid ""
"As blockchain technology continues to mature, it’s worth keeping an eye on "
"how the role of Sequencers evolves. They hold the potential to either "
"strengthen or weaken the unique advantages that make blockchain technology so "
"revolutionary."
msgstr ""
"随着区块链技术的不断成熟，值得关注序列器的作用如何演变。它们有可能加强或削弱使"
"区块链技术如此具有革命性的独特优势。"

#: src/ch03-03-provers.md:3
#, fuzzy
msgid ""
"SHARP is like public transportation for proofs on Starknet, aggregating "
"multiple Cairo programs to save costs and boost efficiency. It uses recursive "
"proofs, allowing parallelization and optimization, making it more affordable "
"for all users. Critical services like the gateway, validator, and Prover work "
"together with a stateless design for flexibility. SHARP’s adoption by "
"StarkEx, Starknet, and external users (through the Cairo Playground) "
"highlights its significance and potential for future optimization."
msgstr ""
"SHARP就像Starknet上的证明公共交通，汇集了多个Cairo程序，以节约成本并提高效率。"
"它使用递归证明，允许并行化和优化，使所有用户都能负担得起。网关、验证器和证明器"
"等关键服务采用无状态设计，可以灵活地协同工作。SHARP已被StarkEx、Starknet和外部"
"用户（通过Cairo Playground）采用，这凸显了它的重要性和未来优化的潜力。"

#: src/ch03-03-provers.md:12
#, fuzzy
msgid ""
"This chapter will discuss SHARP, how it has evolved to incorporate recursive "
"proofs, and its role in reducing costs and improving efficiency within the "
"Starknet network."
msgstr ""
"本章将讨论 SHARP，它是如何发展到包含递归证明的，以及它在Starknet中降低成本和提"
"高效率的作用。"

#: src/ch03-03-provers.md:16
#, fuzzy
msgid "What is SHARP?"
msgstr "什么是夏普？"

#: src/ch03-03-provers.md:18
#, fuzzy
msgid ""
"SHARP, which stands for \"Shared Prover\", is a mechanism used in Starknet "
"that aggregates multiple Cairo programs from different users, each containing "
"different logic. These Cairo programs are then executed together, generating "
"a single proof common to all the programs. Rather than sending the proof "
"directly to the Solidity Verifier in Ethereum, it is initially sent to a "
"STARK Verifier program written in Cairo. The STARK Verifier generates a new "
"proof to confirm that the initial proofs were verified, which can be sent "
"back into SHARP and the STARK Verifier. This recursive proof process will be "
"discussed in more detail later in this chapter. Ultimately, the last proof in "
"the series is sent to the Solidity Verifier on Ethereum. In other words, "
"there are many proofs generated until we reach Ethereum and the Solidity "
"Verifier."
msgstr ""
"SHARP 是 \"共享证明器 \"的缩写，是Starknet中使用的一种机制，它将来自不同用户的"
"多个Cairo程序聚合在一起，每个程序都包含不同的逻辑。然后，这些Cairo程序一起执"
"行，生成一个所有程序通用的证明。证明最初不是直接发送给以太坊中的 Solidity 校验"
"器，而是发送给用Cairo编写的 STARK 校验器程序。STARK 校验器会生成一个新的证明，"
"以确认初始证明已通过验证，然后再发送回 SHARP 和 STARK 校验器。本章稍后将详细讨"
"论这个递归证明过程。最终，这一系列中的最后一个证明会被发送到以太坊上的 "
"Solidity 校验器。换句话说，在我们到达以太坊和 Solidity 校验器之前，会生成很多"
"证明。"

#: src/ch03-03-provers.md:31
#, fuzzy
msgid ""
"The primary benefit of SHARP system lies in its ability to decrease costs and "
"enhance efficiency within the Starknet network. It achieves this by "
"aggregating multiple Cairo jobs, which are individual sets of computations. "
"This aggregation allows the protocol to leverage the exponential amortization "
"offered by STARK proofs."
msgstr ""
"SHARP 系统的主要优势在于它能够降低成本并提高Starknet网络的效率。它通过聚合多个"
"Cairo工作（即单个计算集）来实现这一目标。这种聚合使协议能够利用 STARK 证明提供"
"的指数级摊销。"

#: src/ch03-03-provers.md:37
#, fuzzy
msgid ""
"Exponential amortization means that as the computational load of the proofs "
"increases, the cost of verifying those proofs rises at a slower logarithmic "
"rate than the computation increase. In other words, the computation itself "
"grows slower than the verification cost. As a result, the cost of each "
"transaction within the aggregated set is significantly reduced, making the "
"overall process more cost-effective and accessible for users."
msgstr ""
"指数摊销是指，随着证明的计算量增加，验证这些证明的成本会以比计算量增加更慢的对"
"数速度上升。换句话说，计算本身的增长慢于验证成本的增长。因此，聚合集内每笔交易"
"的成本大幅降低，使整个流程更具成本效益，也更便于用户使用。"

#: src/ch03-03-provers.md:45
#, fuzzy
msgid ""
"In SHARP and Cairo context, \"jobs\" refer to the individual Cairo programs "
"or tasks submitted by different users. These jobs contain specific logic or "
"computations that must be executed on the Starknet network."
msgstr ""
"在 SHARP 和Cairo的语境中，\"作业 \"是指不同用户提交的单个Cairo程序或任务。这些"
"作业包含必须在Starknet网络上执行的特定逻辑或计算。"

#: src/ch03-03-provers.md:50
#, fuzzy
msgid ""
"Additionally, SHARP allows smaller users with limited computation to benefit "
"from joining other jobs and share the cost of generating the proofs. This "
"collaborative approach is similar to using public transportation instead of a "
"private car, where the cost is distributed among all participants, making it "
"more affordable for everyone."
msgstr ""
"此外，SHARP 还允许计算能力有限的小用户加入其他工作，分担生成证明的成本。这种合"
"作方式类似于使用公共交通而不是私家车，成本由所有参与者分摊，使每个人都能负担得"
"起。"

#: src/ch03-03-provers.md:56
#, fuzzy
msgid "Recursive Proofs in SHARP"
msgstr "SHARP 中的递归证明"

#: src/ch03-03-provers.md:58
#, fuzzy
msgid ""
"One of the most powerful features of SHARP is its use of recursive proofs. "
"Rather than directly sending the generated proofs to the Solidity Verifier, "
"they are first sent to a STARK Verifier program written in Cairo. This "
"Verifier, which is also a Cairo Program, receives the proof and creates a new "
"Cairo job that is sent to the Prover. The Prover then generates a new proof "
"to confirm that the initial proofs were verified. These new proofs can be "
"sent back into SHARP and the STARK Verifier, restarting the process."
msgstr ""
"SHARP 最强大的功能之一是使用递归证明。生成的证明不是直接发送给Solidity验证器，"
"而是首先发送给一个用Cairo编写的STARK验证器程序。这个验证程序也是一个Cairo程"
"序，它接收证明并创建一个新的Cairo作业，然后发送给验证者。验证者随后生成新的证"
"明，以确认初始证明已通过验证。这些新的证明可以发回给 SHARP 和 STARK 校验器，重"
"新启动流程。"

#: src/ch03-03-provers.md:67
#, fuzzy
msgid ""
"This process continues recursively, with each new proof being sent to the "
"Cairo Verifier until a trigger is reached. At this point, the last proof in "
"the series is sent to the Solidity Verifier on Ethereum. This approach allows "
"for greater parallelization of the computation and reduces the time and cost "
"associated with generating and verifying proofs."
msgstr ""
"这个过程以递归方式继续，每个新的证明都会被发送到Cairo验证器，直到达到触发点。"
"此时，系列中的最后一个证明会被发送到以太坊上的 Solidity 校验器。这种方法可以提"
"高计算的并行化程度，减少生成和验证证明所需的时间和成本。"

#: src/ch03-03-provers.md:97
#, fuzzy
msgid ""
"At first glance, recursive proofs may seem more complex and time-consuming. "
"However, there are several benefits to this approach:"
msgstr "乍一看，递归证明似乎更复杂、更耗时。然而，这种方法有几个好处："

#: src/ch03-03-provers.md:100
#, fuzzy
msgid ""
"**Parallelization**: Recursive proofs allow for work parallelization, "
"reducing user latency and improving SHARP efficiency."
msgstr "**并行化**：递归证明允许工作并行化，减少用户延迟，提高 SHARP 效率。"

#: src/ch03-03-provers.md:104
#, fuzzy
msgid ""
"**Cheaper on-chain costs**: Parallelization enables SHARP to create larger "
"proofs, which would have previously been limited by the availability of large "
"cloud machines (which are rare and limited). As a result, on-chain costs are "
"reduced."
msgstr ""
"** 更低的链上成本**：并行化使 SHARP 能够创建更大的证明，而这在以前会受到大型云"
"计算机器可用性的限制（云计算机器稀少且有限）。因此，链上成本得以降低。"

#: src/ch03-03-provers.md:109
#, fuzzy
msgid ""
"**Lower cloud costs**: Since each job is shorter, the required memory for "
"processing is reduced, resulting in lower cloud costs."
msgstr ""
"**降低云成本**：由于每个作业的时间较短，处理所需的内存就会减少，从而降低云成"
"本。"

#: src/ch03-03-provers.md:112
#, fuzzy
msgid ""
"**Optimization**: Recursive proofs enable SHARP to optimize for various "
"factors, including latency, on-chain costs, and time to proof."
msgstr ""
"**优化**：递归证明使 SHARP 能够优化各种因素，包括延迟、链上成本和证明时间。"

#: src/ch03-03-provers.md:116
#, fuzzy
msgid ""
"**Cairo support**: Recursive proofs only require support in Cairo, without "
"the need to add support in the Solidity Verifier."
msgstr ""
"**支持Cairo**：递归证明只需Cairo支持，无需在 Solidity 验证器中添加支持。"

#: src/ch03-03-provers.md:119
#, fuzzy
msgid ""
"Latency in Starknet encompasses the time taken for processing, confirming, "
"and including transactions in a block. It is affected by factors like network "
"congestion, transaction fees, and system efficiency. Minimizing latency "
"ensures faster transaction processing and user feedback."
msgstr ""
"Starknet中的延迟包括处理、确认和将交易纳入区块所需的时间。它受到网络拥堵、交易"
"费用和系统效率等因素的影响。最大限度地减少延迟可确保更快的交易处理和用户反馈。"

#: src/ch03-03-provers.md:125
#, fuzzy
msgid ""
"Time to proof, however, specifically pertains to the duration required to "
"generate and verify cryptographic proofs for transactions or operations."
msgstr "不过，证明所需时间具体指生成和验证交易或操作的加密证明所需的时间。"

#: src/ch03-03-provers.md:129
#, fuzzy
msgid "SHARP Backend Architecture and Data Pipeline"
msgstr "SHARP 后端架构和数据管道"

#: src/ch03-03-provers.md:131
#, fuzzy
msgid ""
"SHARP back end architecture consists of several services that work together "
"to process Cairo jobs and generate proofs. These services include:"
msgstr "SHARP 后端架构由多个服务组成，共同处理Cairo作业并生成证明。这些服务包括"

#: src/ch03-03-provers.md:135
#, fuzzy
msgid "**Gateway**: Cairo jobs enter SHARP through the gateway."
msgstr "**网关**：Cairo作业通过网关进入夏普。"

#: src/ch03-03-provers.md:137
#, fuzzy
msgid ""
"**Job Creator**: It prevents job duplication and ensures that the system "
"operates consistently, regardless of multiple identical requests."
msgstr ""
"**Job Creator**：它可防止任务重复，并确保系统在有多个相同请求的情况下始终如一"
"地运行。"

#: src/ch03-03-provers.md:141
#, fuzzy
msgid ""
"**Validator**: This is the first important step. The validator service runs "
"validation checks on each job, ensuring they meet the requirements and can "
"fit within the prover machines. Invalid jobs are tagged as such and do not "
"proceed to the Prover."
msgstr ""
"**验证器**：这是重要的第一步。验证器服务会对每个作业进行验证检查，确保它们符合"
"要求，并能在证明器机器内运行。无效作业会被标记为无效，不会进入验证器。"

#: src/ch03-03-provers.md:146
#, fuzzy
msgid ""
"**Scheduler**: The scheduler service creates \"trains\" that aggregate jobs "
"and send them to the Prover. Recursive jobs are paired and sent to the Prover "
"together."
msgstr ""
"**调度程序**：调度器服务创建 \"列车\"，将作业汇总并发送给验证器。递归作业配对"
"后一起发送到验证器。"

#: src/ch03-03-provers.md:150
#, fuzzy
msgid ""
"**Cairo Runner**: This service runs Cairo for the Prover’s needs. The Cairo "
"Runner service runs Cairo programs, executing the necessary computations and "
"generating the execution trace as an intermediate result. The Prover then "
"uses this execution trace."
msgstr ""
"**Cairo Runner**：该服务根据验证者的需要运行Cairo。Cairo Runner 服务运行 "
"Cairo 程序，执行必要的计算，并生成作为中间结果的执行轨迹。验证者随后使用该执行"
"跟踪。"

#: src/ch03-03-provers.md:155
#, fuzzy
msgid ""
"**Prover**: The Prover computes the proofs for each train (that contains a "
"few jobs)."
msgstr "**证明者**：证明者**：证明者为每一列火车（包含几个作业）计算证明。"

#: src/ch03-03-provers.md:158
#, fuzzy
msgid "**Dispatcher**: The Dispatcher serves two functions in the SHARP system."
msgstr "**调度程序**：调度员在夏普系统中有两个功能。"

#: src/ch03-03-provers.md:161
#, fuzzy
msgid ""
"In the case of a recursive proof, the Dispatcher runs the Cairo Verifier "
"program on the proof it has received from the Prover, resulting in a new "
"Cairo job that goes back to the Validator."
msgstr ""
"在递归证明的情况下，调度器在从证明者处收到的证明上运行Cairo验证程序，产生一个"
"新的Cairo作业，并返回验证器。"

#: src/ch03-03-provers.md:165
#, fuzzy
msgid ""
"In the case of a proof that needs to go on chain (e.g., to Ethereum), the "
"Dispatcher creates \"packages\" from the proof, which can then be sent to the "
"Blockchain Writer."
msgstr ""
"如果证明需要上链（例如发送到以太坊），调度器会根据证明创建 \"包\"，然后发送给"
"区块链写入器。"

#: src/ch03-03-provers.md:169
#, fuzzy
msgid ""
"**Blockchain Writer**: Once the packages have been created by the Dispatcher, "
"they are sent to the Blockchain Writer. The Blockchain Writer is responsible "
"for sending the packages to the appropriate blockchain (e.g., Ethereum) for "
"verification. This is an important step in the SHARP system, as it ensures "
"that the proofs are properly verified and that the transactions are securely "
"recorded on the blockchain."
msgstr ""
"**区块链写入器**：一旦数据包由调度程序创建，它们就会被发送到区块链写入器。区块"
"链写入器负责将数据包发送到相应的区块链（如以太坊）进行验证。这是 SHARP 系统的"
"一个重要步骤，因为它能确保证明得到正确验证，并确保交易安全地记录在区块链上。"

#: src/ch03-03-provers.md:177
#, fuzzy
msgid ""
"**Catcher**: The Catcher monitors blockchain (e.g., Ethereum) transactions to "
"ensure that they have been accepted. While the Catcher is relevant for "
"internal monitoring purposes, it is important to note that if a transaction "
"fails, the fact won’t be registered on-chain in the fact registry. As a "
"result, the soundness of the system is still preserved even without the "
"catcher."
msgstr ""
"**Catcher**：捕获器监控区块链（如以太坊）交易，确保交易已被接受。虽然 \"捕获"
"器 \"与内部监控目的相关，但需要注意的是，如果交易失败，事实将不会在链上的事实"
"注册表中注册。因此，即使没有 \"捕获器\"，系统的稳健性仍然可以保持。"

#: src/ch03-03-provers.md:184
#, fuzzy
msgid ""
"SHARP is designed to be stateless (each Cairo job is executed in its own "
"context and has no dependency on other jobs), allowing for greater "
"flexibility in processing jobs."
msgstr ""
"SHARP 的设计是无状态的（每个Cairo作业都在自己的上下文中执行，不依赖于其他作"
"业），因此可以更灵活地处理作业。"

#: src/ch03-03-provers.md:188
#, fuzzy
msgid "Current SHARP Users"
msgstr "现有夏普用户"

#: src/ch03-03-provers.md:190
#, fuzzy
msgid "Currently, the primary users of SHARP include:"
msgstr "目前，SHARP 的主要用户包括"

#: src/ch03-03-provers.md:192
#, fuzzy
msgid "StarkEx"
msgstr "StarkEx"

#: src/ch03-03-provers.md:194
#, fuzzy
msgid "Starknet"
msgstr "## Starknet合约的属性"

#: src/ch03-03-provers.md:196
#, fuzzy
msgid "External users who use the Cairo Playground"
msgstr "使用Cairo游乐场的外部用户"

#: src/ch03-03-provers.md:198
#, fuzzy
msgid "Challenges and Optimization"
msgstr "挑战与优化"

#: src/ch03-03-provers.md:200
#, fuzzy
msgid ""
"Optimizing the Prover involves numerous challenges and potential projects on "
"which the Starkware team and the community are currently working:"
msgstr ""
"优化 Prover 涉及许多挑战和潜在项目，Starkware 团队和社区目前正在努力解决这些问"
"题："

#: src/ch03-03-provers.md:204
#, fuzzy
msgid ""
"Exploring more efficient hash functions: SHARP is constantly exploring more "
"efficient hash functions for Cairo, the Prover, and Solidity."
msgstr ""
"探索更高效的散列函数SHARP 一直在为 Cairo、Prover 和 Solidity 探索更高效的散列"
"函数。"

#: src/ch03-03-provers.md:208
#, fuzzy
msgid ""
"Investigating smaller fields: Investigating smaller fields for recursive "
"proof steps could lead to more efficient computations."
msgstr "研究更小的领域：为递归证明步骤研究更小的字段可以提高计算效率。"

#: src/ch03-03-provers.md:211
#, fuzzy
msgid ""
"Adjusting various parameters: SHARP is continually adjusting various "
"parameters of the STARK protocol, such as FRI parameters and block factors."
msgstr ""
"调整各种参数：夏普正在不断调整 STARK 协议的各种参数，如 FRI 参数和块系数。"

#: src/ch03-03-provers.md:215
#, fuzzy
msgid ""
"Optimizing the Cairo code: SHARP is optimizing the Cairo code to make it "
"faster, resulting in a faster recursive prover."
msgstr ""
"优化Cairo代码夏普正在优化Cairo代码，使其更快，从而加快递归证明器的速度。"

#: src/ch03-03-provers.md:218
#, fuzzy
msgid ""
"Developing dynamic layouts: This will allow Cairo programs to scale resources "
"depending on their needs."
msgstr "开发动态布局：这将使Cairo计划能够根据自身需要扩展资源。"

#: src/ch03-03-provers.md:221
#, fuzzy
msgid ""
"Improving scheduling algorithm: This is another optimization path that can be "
"taken. It is not within the Prover itself."
msgstr "改进调度算法：这是另一条优化途径。它不属于 Prover 本身。"

#: src/ch03-03-provers.md:224
#, fuzzy
msgid ""
"In particular, dynamic layouts (you can learn more about layouts here (TODO)) "
"will allow Cairo programs to scale resources depending on their needs. This "
"can lead to more efficient computation and better utilization of resources. "
"Dynamic layouts allow SHARP to determine the required resources for a "
"specific job and adjust the layout accordingly instead of relying on "
"predefined layouts with fixed resources. This approach can provide tailored "
"solutions for each job, improving overall efficiency."
msgstr ""
"特别是，动态布局（你可以在这里（TODO）了解更多关于布局的信息）将允许Cairo程序"
"根据自己的需求来扩展资源。这将提高计算效率，更好地利用资源。动态布局允许 "
"SHARP 确定特定作业所需的资源，并相应调整布局，而不是依赖预定义的固定资源布局。"
"这种方法可为每项工作提供量身定制的解决方案，从而提高整体效率。"

#: src/ch03-03-provers.md:245
#, fuzzy
msgid ""
"In conclusion, SHARP is a critical component of Starknet’s architecture, "
"providing a more efficient and cost-effective solution for processing Cairo "
"programs and verifying their proofs. By leveraging the power of STARK "
"technology and incorporating recursive proofs, SHARP plays a vital role in "
"improving the overall performance and scalability of the Starknet network. "
"The stateless nature of SHARP and the reliance on the cryptographic soundness "
"of the STARK proving system make it an innovative and valuable addition to "
"the blockchain ecosystem."
msgstr ""
"总之，SHARP 是Starknet架构的重要组成部分，为处理Cairo程序和验证其证明提供了更"
"高效、更经济的解决方案。通过利用 STARK 技术的强大功能并结合递归证明，SHARP 在"
"提高Starknet的整体性能和可扩展性方面发挥了至关重要的作用。SHARP 的无状态特性以"
"及对 STARK 证明系统的加密完整性的依赖，使其成为区块链生态系统中一个创新而有价"
"值的补充。"

#: src/ch03-04-nodes.md:3
#, fuzzy
msgid ""
"This chapter will guide you through setting up and running a Starknet node, "
"illustrating the layered tech stack concept, and explaining how to operate "
"these protocols locally. Starknet, as a Layer 2 Validity Rollup, operates on "
"top of Ethereum Layer 1, creating a protocol stack that each addresses "
"different functionalities, similar to the OSI model for internet connections. "
"This chapter is an edit of [drspacemn](https://medium.com/starknet-edu/the-"
"starknet-stack-7b0d70a7e1d4)'s blog."
msgstr ""
"本章将指导你设置和运行一个 Starknet 节点，说明分层技术栈的概念，并解释如何在本"
"地操作这些协议。Starknet 作为第二层有效性卷积（Layer 2 Validity Rollup），在以"
"太坊第一层之上运行，创建了一个协议栈，各自解决不同的功能，类似于互联网连接的 "
"OSI 模型。本章由 [drspacemn](https://medium.com/starknet-edu/the-starknet-"
"stack-7b0d70a7e1d4) 的博客编辑。"

#: src/ch03-04-nodes.md:12
#, fuzzy
msgid ""
"CONTRIBUTE: This guide shows how to run a Starknet node locally with a "
"particular setup. You can contribute to this guide by adding more options for "
"hardware and software, as well as other ways to run a Starknet nod (for "
"example using [Beerus](https://github.com/keep-starknet-strange/beerus)). You "
"can also contribute by adding more information about the Starknet stack and "
"the different layers. Feel free to [open a PR](https://github.com/starknet-"
"edu/starknetbook)."
msgstr ""
"贡献： 本指南介绍了如何在本地以特定设置运行Starknet节点。你可以为本指南添加更"
"多硬件和软件选项，以及运行Starknet节点的其他方法（例如使用 [Beerus](https://"
"github.com/keep-starknet-strange/beerus)）。您还可以为本指南添加更多有关"
"Starknet堆栈和不同层的信息。请随时 [open a PR](https://github.com/starknet-"
"edu/starknetbook)。"

#: src/ch03-04-nodes.md:21
#, fuzzy
msgid "What is a Node in the Context of Ethereum and Blockchain?"
msgstr "什么是以太坊和区块链中的节点？"

#: src/ch03-04-nodes.md:23
#, fuzzy
msgid ""
"In the context of Ethereum and blockchain, a node is an integral part of the "
"network that validates and relays transactions. Nodes download a copy of the "
"entire blockchain and are interconnected with other nodes to maintain and "
"update the blockchain state. There are different types of nodes, such as full "
"nodes, light nodes, and mining nodes, each having different roles and "
"responsibilities within the network."
msgstr ""
"就以太坊和区块链而言，节点是网络的组成部分，负责验证和转发交易。节点下载整个区"
"块链的副本，并与其他节点相互连接，以维护和更新区块链状态。节点有多种类型，如全"
"节点、轻节点和挖矿节点，每种节点在网络中都有不同的作用和职责。"

#: src/ch03-04-nodes.md:30
#, fuzzy
msgid "Overview of Starknet Technology"
msgstr "Starknet技术概述"

#: src/ch03-04-nodes.md:32
#, fuzzy
msgid ""
"Starknet is a permissionless, zk-STARK-based Layer-2 network, aiming for full "
"decentralization. It enables developers to build scalable decentralized "
"applications (dApps) and utilizes Ethereum’s Layer 1 for proof verification "
"and data availability. Key aspects of Starknet include:"
msgstr ""
"Starknet 是一个无权限、基于 zk-STARK 的第 2 层网络，旨在实现完全去中心化。它使"
"开发者能够构建可扩展的去中心化应用程序（dApps），并利用以太坊的第 1 层进行证明"
"验证和数据可用性。Starknet的主要方面包括"

#: src/ch03-04-nodes.md:38
#, fuzzy
msgid ""
"**Cairo execution environment**: Cairo, the execution environment of "
"Starknet, facilitates writing and execution of complex smart contracts."
msgstr ""
"**Cairo执行环境**：Cairo是Starknet的执行环境，有助于编写和执行复杂的智能合约。"

#: src/ch03-04-nodes.md:42
#, fuzzy
msgid ""
"**Scalability**: Starknet achieves scalability through zk-STARK proofs, "
"minimizing the data needed to be posted on-chain."
msgstr ""
"**可扩展性**：Starknet通过zk-STARK证明实现了可扩展性，最大限度地减少了需要在链"
"上发布的数据。"

#: src/ch03-04-nodes.md:45
#, fuzzy
msgid ""
"**Node network**: The Starknet network comprises nodes that synchronize and "
"process transactions, contributing to the network’s overall security and "
"decentralization."
msgstr ""
"**节点网络**：Starknet由同步和处理交易的节点组成，有助于网络的整体安全性和去中"
"心化。"

#: src/ch03-04-nodes.md:49
#, fuzzy
msgid "Starknet Stack"
msgstr "Starknet堆栈"

#: src/ch03-04-nodes.md:51
#, fuzzy
msgid ""
"The Starknet stack can be divided into various layers, similar to OSI or TCP/"
"IP models. The most appropriate model depends on your understanding and "
"requirements. A simplified version of the modular blockchain stack might look "
"like this:"
msgstr ""
"Starknet堆栈可分为不同的层，类似于 OSI 或 TCP/IP 模型。最合适的模型取决于您的"
"理解和要求。模块化区块链堆栈的简化版本可能如下所示："

#: src/ch03-04-nodes.md:56 src/ch03-04-nodes.md:118
#, fuzzy
msgid "Layer 1: Data Layer"
msgstr "第 1 层：数据层"

#: src/ch03-04-nodes.md:58 src/ch03-04-nodes.md:203
#, fuzzy
msgid "Layer 2: Execution Layer"
msgstr "第 2 层：执行层"

#: src/ch03-04-nodes.md:60 src/ch03-04-nodes.md:270
#, fuzzy
msgid "Layer 3: Application Layer"
msgstr "第 3 层：应用层"

#: src/ch03-04-nodes.md:62 src/ch03-04-nodes.md:296
#, fuzzy
msgid "Layer 4: Transport Layer"
msgstr "第 4 层：传输层"

#: src/ch03-04-nodes.md:66
#, fuzzy
msgid "Modular blockchain layers"
msgstr "模块化区块链层"

#: src/ch03-04-nodes.md:68
msgid "Setup"
msgstr "设置"

#: src/ch03-04-nodes.md:70
#, fuzzy
msgid ""
"There are various hardware specifications, including packaged options, that "
"will enable you to run an Ethereum node from home. The goal here is to build "
"the most cost-efficient Starknet stack possible ([see here more options]"
"(https://github.com/rocket-pool/docs.rocketpool.net/blob/main/src/guides/node/"
"local/hardware.md))."
msgstr ""
"有各种硬件规格，包括打包选项，可以让你在家里运行以太坊节点。我们的目标是尽可能"
"构建最具成本效益的Starknet堆栈（[查看更多选项](https://github.com/rocket-pool/"
"docs.rocketpool.net/blob/main/src/guides/node/local/hardware.md)）。"

#: src/ch03-04-nodes.md:75
#, fuzzy
msgid "**Minimum Requirements:**"
msgstr "**最低要求：**"

#: src/ch03-04-nodes.md:77
#, fuzzy
msgid "CPU: 2+ cores"
msgstr "CPU: 2+ 核心"

#: src/ch03-04-nodes.md:79
msgid "RAM: 4 GB"
msgstr "内存: 4 GB"

#: src/ch03-04-nodes.md:81
#, fuzzy
msgid "Disk: 600 GB"
msgstr "磁盘： 600 GB"

#: src/ch03-04-nodes.md:83
#, fuzzy
msgid "Connection Speed: 8 mbps/sec"
msgstr "连接速度： 8 mbps/秒"

#: src/ch03-04-nodes.md:85
#, fuzzy
msgid "**Recommended Specifications:**"
msgstr "**建议规格：**"

#: src/ch03-04-nodes.md:87
#, fuzzy
msgid "CPU: 4+ cores"
msgstr "CPU：4+ 内核"

#: src/ch03-04-nodes.md:89
#, fuzzy
msgid "RAM: 16 GB+"
msgstr "内存： 16 GB+"

#: src/ch03-04-nodes.md:91
#, fuzzy
msgid "Disk 2 TB"
msgstr "磁盘 2 TB"

#: src/ch03-04-nodes.md:93
#, fuzzy
msgid "Connection Speed: 25+ mbps/sec"
msgstr "连接速度： 25+ mbps/秒"

#: src/ch03-04-nodes.md:95
#, fuzzy
msgid "**You can refer to these links for the hardware:**"
msgstr "**您可以参考这些硬件链接：**"

#: src/ch03-04-nodes.md:97
#, fuzzy
msgid "[CPU](https://a.co/d/iAWpTzQ) — $193"
msgstr "[CPU](https://a.co/d/iAWpTzQ) - 193 美元"

#: src/ch03-04-nodes.md:99
#, fuzzy
msgid "[Board](https://a.co/d/cTUk9Kd) (can attempt w/ Raspberry Pi) — $110"
msgstr "[Board](https://a.co/d/cTUk9Kd)（可尝试使用 Raspberry Pi） - $110"

#: src/ch03-04-nodes.md:101
#, fuzzy
msgid "[Disk](https://a.co/d/0US61Y5) — $100"
msgstr "[磁盘](https://a.co/d/0US61Y5) - $100"

#: src/ch03-04-nodes.md:103
#, fuzzy
msgid "[RAM](https://a.co/d/br867sk) — $60"
msgstr "[RAM](https://a.co/d/br867sk) - $60"

#: src/ch03-04-nodes.md:105
#, fuzzy
msgid "[PSU](https://a.co/d/2k3Gn40) — $40"
msgstr "[PSU](https://a.co/d/2k3Gn40) - $40"

#: src/ch03-04-nodes.md:107
#, fuzzy
msgid "[Case](https://a.co/d/apCBGwF) — $50"
msgstr "[Case](https://a.co/d/apCBGwF) - $50"

#: src/ch03-04-nodes.md:109
#, fuzzy
msgid "Total — $553"
msgstr "共计 - 553 美元"

#: src/ch03-04-nodes.md:111
#, fuzzy
msgid ""
"Recommended operating system and software: Ubuntu LTS, [Docker](https://docs."
"docker.com/engine/install/ubuntu), and [Docker Compose](https://docs.docker."
"com/compose/install/linux). Ensure you have the necessary tools installed "
"with:"
msgstr ""
"推荐操作系统和软件：Ubuntu LTS、[Docker](https://docs.docker.com/engine/"
"install/ubuntu) 和 [Docker Compose](https://docs.docker.com/compose/install/"
"linux)。确保安装了必要的工具："

#: src/ch03-04-nodes.md:120
#, fuzzy
msgid ""
"The bottom-most layer of the stack is the data layer. Here, Starknet’s L2 "
"leverages Ethereum’s L1 for proof verification and data availability. "
"Starknet utilizes Ethereum as its L1, so the first step is setting up an "
"Ethereum Full Node. As this is the data layer, the hardware bottleneck is "
"usually the disk storage. It’s crucial to have a high capacity I/O SSD over "
"an HDD because Ethereum Nodes require both an Execution Client and a "
"Consensus Client for communication."
msgstr ""
"堆栈的最底层是数据层。在这里，Starknet 的 L2 利用以太坊的 L1 进行证明验证和数"
"据可用性。Starknet 利用以太坊作为其 L1，因此第一步是建立一个以太坊全节点。由于"
"这是数据层，硬件瓶颈通常是磁盘存储。与硬盘相比，大容量 I/O SSD 至关重要，因为"
"以太坊节点需要执行客户端（Execution Client）和共识客户端（Consensus Client）进"
"行通信。"

#: src/ch03-04-nodes.md:128
#, fuzzy
msgid ""
"Ethereum provides several options for Execution and Consensus clients. "
"Execution clients include Geth, Erigon, Besu (used here), Nethermind, and "
"Akula. Consensus clients include Prysm, Lighthouse (used here), Lodestar, "
"Nimbus, and Teku."
msgstr ""
"以太坊为执行和共识客户端提供了多种选择。执行客户端包括 Geth、Erigon、Besu（此"
"处使用）、Nethermind 和 Akula。共识客户端包括 Prysm、Lighthouse（此处使用）、"
"Lodestar、Nimbus 和 Teku。"

#: src/ch03-04-nodes.md:133
#, fuzzy
msgid ""
"Your Besu/Lighthouse node will take approximately 600 GB of disk space. "
"Navigate to a partition on your machine with sufficient capacity and run the "
"following commands:"
msgstr ""
"Besu/Lighthouse 节点将占用大约 600 GB 的磁盘空间。导航到计算机上容量足够大的分"
"区，运行以下命令："

#: src/ch03-04-nodes.md:137
#, fuzzy
msgid ""
"```\n"
"git clone https://github.com/starknet-edu/starknet-stack.git\n"
"cd starknet-stack\n"
"docker-compose -f dc-l1.yaml up -d\n"
"```"
msgstr ""
"```\n"
"git clone https://github.com/starknet-edu/starknet-stack.git\n"
"cd starknet-stack\n"
"docker-compose -f dc-l1.yaml up -d\n"
"```"

#: src/ch03-04-nodes.md:141
#, fuzzy
msgid ""
"This will begin the fairly long process of spinning up our Consensus Client, "
"Execution Client, and syncing them to the current state of the Goerli "
"Testnet. If you would like to see the logs from either process you can run:"
msgstr ""
"这将开始一个相当漫长的过程，即启动我们的共识客户端和执行客户端，并将它们同步"
"到 Goerli Testnet 的当前状态。如果您想查看这两个过程的日志，可以运行"

#: src/ch03-04-nodes.md:152
#, fuzzy
msgid "Lets make sure that everything that should be listening is listening:"
msgstr "让我们确保所有应该倾听的东西都在倾听："

#: src/ch03-04-nodes.md:162
#, fuzzy
msgid ""
"We’ve used docker to abstract a lot of the nuance of running an Eth L1 node, "
"but the important things to note are how the two processes EL/CL point to "
"each other and communicate via JSON-RPC:"
msgstr ""
"我们使用 docker 对运行 Eth L1 节点的许多细微差别进行了抽象，但需要注意的是，"
"EL/CL 这两个进程是如何相互指向并通过 JSON-RPC 进行通信的："

#: src/ch03-04-nodes.md:166
#, fuzzy
msgid ""
"```\n"
"services:\n"
"  lighthouse:\n"
"      image: sigp/lighthouse:latest\n"
"      container_name: lighthouse\n"
"      volumes:\n"
"        - ./l1_consensus/data:/root/.lighthouse\n"
"        - ./secret:/root/secret\n"
"      network_mode: \"host\"\n"
"      command:\n"
"        - lighthouse\n"
"        - beacon\n"
"        - --network=goerli\n"
"        - --metrics\n"
"        - --checkpoint-sync-url=https://goerli.beaconstate.info\n"
"        - --execution-endpoint=http://127.0.0.1:8551\n"
"        - --execution-jwt=/root/secret/jwt.hex\n"
"\n"
"  besu:\n"
"    image: hyperledger/besu:latest\n"
"    container_name: besu\n"
"    volumes:\n"
"      - ./l1_execution/data:/var/lib/besu\n"
"      - ./secret:/var/lib/besu/secret\n"
"    network_mode: \"host\"\n"
"    command:\n"
"      - --network=goerli\n"
"      - --rpc-http-enabled=true\n"
"      - --data-path=/var/lib/besu\n"
"      - --data-storage-format=BONSAI\n"
"      - --sync-mode=X_SNAP\n"
"      - --engine-rpc-enabled=true\n"
"      - --engine-jwt-enabled=true\n"
"      - --engine-jwt-secret=/var/lib/besu/secret/jwt.hex\n"
"```"
msgstr ""
"```\n"
"服务：\n"
"  lighthouse：\n"
"      image: sigp/lighthouse:latest\n"
"      container_name: 灯塔\n"
"      卷\n"
"        - ./l1_consensus/data:/root/.lighthouse\n"
"        - ./secret:/root/secret\n"
"      network_mode：主机\n"
"      command：\n"
"        - 灯塔\n"
"        - 信标\n"
"        - --网络=goerli\n"
"        - --参数\n"
"        - --检查点同步url=https://goerli.beaconstate.info\n"
"        - --execution-endpoint=http://127.0.0.1:8551\n"
"        - --执行-jwt=/root/secret/jwt.hex\n"
"\n"
"  besu：\n"
"    镜像： hyperledger/besu:latest\n"
"    container_name: besu\n"
"    volumes：\n"
"      - ./l1_execution/data:/var/lib/besu\n"
"      - ./secret:/var/lib/besu/secret\n"
"    network_mode：主机\n"
"    command：\n"
"      - --network=goerli\n"
"      - --rpc-http-enabled=true\n"
"      - --数据路径=/var/lib/besu\n"
"      - --数据存储格式=BONSAI\n"
"      - --同步模式=X_SNAP\n"
"      - --engine-rpc-enabled=true\n"
"      - --engine-jwt-enabled=true\n"
"      - --engine-jwt-secret=/var/lib/besu/secret/jwt.hex\n"
"```"

#: src/ch03-04-nodes.md:200
#, fuzzy
msgid ""
"Once this is done, your Ethereum node should be up and running, and it will "
"start syncing with the Ethereum network."
msgstr "完成上述操作后，您的以太坊节点就可以开始运行，并开始与以太坊网络同步。"

#: src/ch03-04-nodes.md:205
#, fuzzy
msgid ""
"The next layer in our Starknet stack is the Execution Layer. This layer is "
"responsible for running the Cairo VM, which executes Starknet smart "
"contracts. The Cairo VM is a deterministic virtual machine that allows "
"developers to write complex smart contracts in the Cairo language. Starknet "
"uses a similar [JSON-RPC spec](https://github.com/starkware-libs/starknet-"
"specs) as [Ethereum](https://ethereum.org/en/developers/docs/apis/json-rpc) "
"in order to interact with the execution layer."
msgstr ""
"Starknet 堆栈的下一层是执行层。该层负责运行Cairo虚拟机（Cairo VM），执行 "
"Starknet 智能合约。Cairo虚拟机是一个确定性虚拟机，允许开发人员用Cairo语言编写"
"复杂的智能合约。Starknet 使用与[以太坊](https://ethereum.org/en/developers/"
"docs/apis/json-rpc) 类似的[JSON-RPC 规范](https://github.com/starkware-libs/"
"starknet-specs)来与执行层交互。"

#: src/ch03-04-nodes.md:214
#, fuzzy
msgid ""
"In order to stay current with the propagation of the Starknet blockchain we "
"need a client similar to Besu that we are using for L1. The efforts to "
"provide full nodes for the Starknet ecosystem are: [Pathfinder](https://"
"github.com/eqlabs/pathfinder) (used here), [Papyrus](https://github.com/"
"starkware-libs/papyrus), and [Juno](https://github.com/NethermindEth/juno). "
"However, different implementations are still in development and not yet ready "
"for production."
msgstr ""
"为了与Starknet区块链的传播保持同步，我们需要一个与L1使用的Besu类似的客户端。"
"为 Starknet 生态系统提供完整节点的有[Pathfinder](https://github.com/eqlabs/"
"pathfinder) （此处使用）、[Papyrus](https://github.com/starkware-libs/"
"papyrus) 和 [Juno](https://github.com/NethermindEth/juno)。不过，不同的实施方"
"案仍在开发中，尚未准备好投入生产。"

#: src/ch03-04-nodes.md:223
#, fuzzy
msgid "Check that your L1 has completed its sync:"
msgstr "检查 L1 是否已完成同步："

#: src/ch03-04-nodes.md:225
#, fuzzy
msgid ""
"```\n"
"# check goerli etherscan to make sure you have the latest block https://"
"goerli.etherscan.io\n"
"\n"
"curl --location --request POST 'http://localhost:8545' \\\n"
"--header 'Content-Type: application/json' \\\n"
"--data-raw '{\n"
"    \"jsonrpc\":\"2.0\",\n"
"    \"method\":\"eth_blockNumber\",\n"
"    \"params\":[],\n"
"    \"id\":83\n"
"}'\n"
"\n"
"# Convert the result, which is hex (remove 0x) to decimal. Example:\n"
"echo $(( 16#246918 ))\n"
"```"
msgstr ""
"```\n"
"# 检查 goerli etherscan，确保有最新的区块 https://goerli.etherscan.io\n"
"\n"
"curl --location --request POST 'http://localhost:8545'\\\n"
"--header 'Content-Type: application/json' （内容类型：应用程序/json\n"
"--data-raw '{\n"
"    \"jsonrpc\": \"2.0\"、\n"
"    \"method\": \"eth_blockNumber\"、\n"
"    \"params\":[]、\n"
"    \"id\":83\n"
"}'\n"
"\n"
"# 将结果（十六进制，去掉 0x）转换为十进制。例如\n"
"echo $(( 16#246918 ))\n"
"```"

#: src/ch03-04-nodes.md:239
#, fuzzy
msgid ""
"Start your L2 Execution Client and note that we are syncing Starknet’s state "
"from our LOCAL ETH L1 NODE!"
msgstr "启动 L2 执行客户端，注意我们是从本地 ETH L1 节点同步 Starknet 的状态！"

#: src/ch03-04-nodes.md:242
#, fuzzy
msgid "PATHFINDER_ETHEREUM_API_URL=http://127.0.0.1:8545"
msgstr "pathfinder_ethereum_api_url=http://127.0.0.1:8545"

#: src/ch03-04-nodes.md:247
#, fuzzy
msgid "To follow the sync:"
msgstr "跟随同步："

#: src/ch03-04-nodes.md:251
#, fuzzy
msgid ""
"Starknet [Testnet_1](https://testnet.starkscan.co) currently comprises "
"800,000+ blocks so this will take some time (days) to sync fully. To check L2 "
"sync:"
msgstr ""
"Starknet [Testnet_1](https://testnet.starkscan.co)目前有 800,000 多个区块，因"
"此需要一些时间（几天）才能完全同步。检查 L2 同步："

#: src/ch03-04-nodes.md:255
#, fuzzy
msgid ""
"```\n"
"# compare `current_block_num` with `highest_block_num`\n"
"\n"
"curl --location --request POST 'http://localhost:9545' \\\n"
"--header 'Content-Type: application/json' \\\n"
"--data-raw '{\n"
" \"jsonrpc\":\"2.0\",\n"
" \"method\":\"starknet_syncing\",\n"
" \"params\":[],\n"
" \"id\":1\n"
"}'\n"
"```"
msgstr ""
"```\n"
"# 将 `current_block_num` 与 `highest_block_num` 进行比较\n"
"\n"
"curl --location --request POST 'http://localhost:9545'\\\n"
"--header 'Content-Type: application/json' \\\n"
"--data-raw '{\n"
" \"jsonrpc\": \"2.0\"、\n"
" \"method\": \"starknet_syncing\"、\n"
" \"params\":[]、\n"
" \"id\":1\n"
"}'\n"
"```"

#: src/ch03-04-nodes.md:266
#, fuzzy
msgid "To check data sizes:"
msgstr "检查数据大小："

#: src/ch03-04-nodes.md:272
#, fuzzy
msgid ""
"We see the same need for data refinement as we did in the OSI model. On L1 "
"packets come over the wire in a raw stream of bytes and are then processed "
"and filtered by higher-level protocols. When designing a decentralized "
"application Bob will need to be cognizant of interactions with his contract "
"on chain, but doesn’t need to be aware of all the information occurring on "
"Starknet."
msgstr ""
"与 OSI 模型一样，我们也需要对数据进行细化。在 L1 模式下，数据包以原始字节流的"
"形式通过网络传输，然后由更高级别的协议进行处理和过滤。在设计去中心化应用时，鲍"
"勃需要了解与链上合约的交互情况，但不需要了解Starknet上的所有信息。"

#: src/ch03-04-nodes.md:279
#, fuzzy
msgid ""
"This is the role of an indexer. To process and filter useful information for "
"an application. Information that an application MUST be opinionated about and "
"the underlying layer MUST NOT be opinionated about."
msgstr ""
"这就是索引器的作用。为应用程序处理和过滤有用信息。应用程序必须对这些信息有自己"
"的看法，而底层不得对这些信息有自己的看法。"

#: src/ch03-04-nodes.md:283
#, fuzzy
msgid ""
"Indexers provide applications flexibility as they can be written in any "
"programming language and have any data layout that suits the application."
msgstr ""
"索引器为应用程序提供了灵活性，因为它们可以用任何编程语言编写，并拥有适合应用程"
"序的任何数据布局。"

#: src/ch03-04-nodes.md:287
#, fuzzy
msgid ""
"To start our toy [indexer](https://github.com/starknet-edu/starknet-stack/"
"blob/main/indexer/indexer.sh) run:"
msgstr ""
"启动我们的玩具 [indexer](https://github.com/starknet-edu/starknet-stack/blob/"
"main/indexer/indexer.sh) 运行："

#: src/ch03-04-nodes.md:293
#, fuzzy
msgid ""
"Again notice that we don’t need to leave our local setup for these "
"interactions (<http://localhost:9545>)."
msgstr ""
"请再次注意，我们不需要离开本地设置来进行这些交互 (<http://localhost:9545>)。"

#: src/ch03-04-nodes.md:298
#, fuzzy
msgid ""
"The transport layer comes into play when the application has parsed and "
"indexed critical information, often leading to some state change based on "
"this information. This is where the application communicates the desired "
"state change to the Layer 2 sequencer to get that change into a block. This "
"is achieved using the same full-node/RPC spec implementation, in our case, "
"Pathfinder."
msgstr ""
"当应用程序对关键信息进行解析和索引时，传输层就开始发挥作用，这通常会导致一些基"
"于这些信息的状态变化。这时，应用程序会将所需的状态变化传达给第二层定序器，以便"
"将该变化转化为数据块。这是通过相同的全节点/RPC 规范实现的，在我们的例子中就是"
"通过 Pathfinder 实现的。"

#: src/ch03-04-nodes.md:305
#, fuzzy
msgid ""
"When working with our local Starknet stack, invoking a transaction locally "
"might look like this:"
msgstr "使用本地 Starknet 协议栈时，在本地调用事务的过程可能如下："

#: src/ch03-04-nodes.md:308
#, fuzzy
msgid ""
"```\n"
"curl --location --request POST 'http://localhost:9545' \\\n"
"--header 'Content-Type: application/json' \\\n"
"--data-raw '{\n"
"    \"jsonrpc\": \"2.0\",\n"
"    \"method\": \"starknet_addInvokeTransaction\",\n"
"    \"params\": {\n"
"        \"invoke_transaction\": {\n"
"            \"type\": \"INVOKE\",\n"
"            \"max_fee\": \"0x4f388496839\",\n"
"            \"version\": \"0x0\",\n"
"            \"signature\": [\n"
"                \"0x7dd3a55d94a0de6f3d6c104d7e6c88ec719a82f4e2bbc12587c8c187584d3d5\",\n"
"                \"0x71456dded17015d1234779889d78f3e7c763ddcfd2662b19e7843c7542614f8\"\n"
"            ],\n"
"            \"contract_address\": "
"\"0x23371b227eaecd8e8920cd429d2cd0f3fee6abaacca08d3ab82a7cdd\",\n"
"            \"calldata\": [\n"
"                \"0x1\",\n"
"                \"0x677bb1cdc050e8d63855e8743ab6e09179138def390676cc03c484daf112ba1\",\n"
"                \"0x362398bec32bc0ebb411203221a35a0301193a96f317ebe5e40be9f60d15320\",\n"
"                \"0x0\",\n"
"                \"0x1\",\n"
"                \"0x1\",\n"
"                \"0x2b\",\n"
"                \"0x0\"\n"
"            ],\n"
"            \"entry_point_selector\": "
"\"0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad\"\n"
"        }\n"
"    },\n"
"    \"id\": 0\n"
"}'\n"
"```"
msgstr ""
"```\n"
"curl --location --request POST 'http://localhost:9545'\\\n"
"--header 'Content-Type: application/json' （内容类型：应用程序/json\n"
"--data-raw '{\n"
"    \"jsonrpc\"：\"2.0\",\n"
"    \"method\"：\"starknet_addInvokeTransaction\"、\n"
"    参数{\n"
"        \"invoke_transaction\"：{\n"
"            \"类型\"：\"INVOKE\"、\n"
"            \"max_fee\"：\"0x4f388496839\"、\n"
"            \"版本\"：\"0x0\",\n"
"            \"签名\"：[\n"
"                \"0x7dd3a55d94a0de6f3d6c104d7e6c88ec719a82f4e2bbc12587c8c187584d3d5\",\n"
"                \"0x71456dded17015d1234779889d78f3e7c763ddcfd2662b19e7843c7542614f8\"\n"
"            ],\n"
"            \"合约地址\"："
"\"0x23371b227eaecd8e8920cd429d2cd0f3fee6abaacca08d3ab82a7cdd\",\n"
"            \"calldata\"：[\n"
"                \"0x1\",\n"
"                \"0x677bb1cdc050e8d63855e8743ab6e09179138def390676cc03c484daf112ba1\",\n"
"                \"0x362398bec32bc0ebb411203221a35a0301193a96f317ebe5e40be9f60d15320\",\n"
"                \"0x0\",\n"
"                \"0x1\",\n"
"                \"0x1\",\n"
"                \"0x2b\"、\"0x0\n"
"                \"0x0\"\n"
"            ],\n"
"            \"entry_point_selector\"（输入点选择器）："
"\"0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad\"\n"
"        }\n"
"    },\n"
"    \"id\"：0\n"
"}'\n"
"```"

#: src/ch03-04-nodes.md:339
#, fuzzy
msgid ""
"However, this process involves setting up a local wallet and signing the "
"transaction. For simplicity, we will use a browser wallet and StarkScan."
msgstr ""
"不过，这个过程涉及设置本地钱包和签署交易。为简单起见，我们将使用浏览器钱包和 "
"StarkScan。"

#: src/ch03-04-nodes.md:342
msgid "Steps:"
msgstr "步骤:"

#: src/ch03-04-nodes.md:344
#, fuzzy
msgid "Navigate to the contract on StarkScan and connect to your wallet."
msgstr "导航到 StarkScan 上的合约并连接到您的钱包。"

#: src/ch03-04-nodes.md:346
#, fuzzy
msgid "Enter a new value and write the transaction:"
msgstr "输入新值并写入交易："

#: src/ch03-04-nodes.md:350
#, fuzzy
msgid "Starkscan block explorer"
msgstr "斯塔克斯坎区块探测仪"

#: src/ch03-04-nodes.md:352
#, fuzzy
msgid ""
"Once the transaction is accepted on the Layer 2 execution layer, the event "
"data should come through our application layer indexer."
msgstr "一旦第二层执行层接受了事务，事件数据就会通过我们的应用层索引器传送。"

#: src/ch03-04-nodes.md:355
#, fuzzy
msgid "Example Indexer Output:"
msgstr "索引器输出示例："

#: src/ch03-04-nodes.md:357
#, fuzzy
msgid ""
"```\n"
"Pulled Block #: 638703\n"
"Found transaction: "
"0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\n"
"Events to Index:\n"
"[\n"
"  {\n"
"    \"from_address\": "
"\"0x806778f9b06746fffd6ca567e0cfea9b3515432d9ba39928201d18c8dc9fdf\",\n"
"    \"keys\": [\n"
"      \"0x1fee98324df9b8703ae8de6de3068b8a8dce40c18752c3b550c933d6ac06765\"\n"
"    ],\n"
"    \"data\": [\n"
"      \"0xa\"\n"
"    ]\n"
"  },\n"
"  {\n"
"    \"from_address\": "
"\"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
"    \"keys\": [\n"
"      \"0x5ad857f66a5b55f1301ff1ed7e098ac6d4433148f0b72ebc4a2945ab85ad53\"\n"
"    ],\n"
"    \"data\": [\n"
"      \"0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\",\n"
"      \"0x0\"\n"
"    ]\n"
"  },\n"
"  {\n"
"    \"from_address\": "
"\"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n"
"    \"keys\": [\n"
"      \"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\"\n"
"    ],\n"
"    \"data\": [\n"
"      \"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
"      \"0x46a89ae102987331d369645031b49c27738ed096f2789c24449966da4c6de6b\",\n"
"      \"0x17c1e31c270\",\n"
"      \"0x0\"\n"
"    ]\n"
"  }\n"
"]\n"
"```"
msgstr ""
"```\n"
"提取区块 #: 638703\n"
"找到交易：0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\n"
"事件索引：\n"
"[\n"
"  {\n"
"    \"from_address\"："
"\"0x806778f9b06746fffd6ca567e0cfea9b3515432d9ba39928201d18c8dc9fdf\",\n"
"    \"键\"：[\n"
"      \"0x1fee98324df9b8703ae8de6de3068b8a8dce40c18752c3b550c933d6ac06765\"\n"
"    ],\n"
"    \"数据\"：[\n"
"      \"0xa\n"
"    ]\n"
"  },\n"
"  {\n"
"    \"来自地址\"："
"\"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
"    \"键\"：[\n"
"      \"0x5ad857f66a5b55f1301ff1ed7e098ac6d4433148f0b72ebc4a2945ab85ad53\"\n"
"    ],\n"
"    \"数据\"：[\n"
"      \"0x2053ae75adfb4a28bf3a01009f36c38396c904012c5fc38419f4a7f3b7d75a5\",\n"
"      \"0x0\"\n"
"    ]\n"
"  },\n"
"  {\n"
"    \"from_address\"："
"\"0x49d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7\",\n"
"    \"键\"：[\n"
"      \"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\"\n"
"    ],\n"
"    \"数据\"：[\n"
"      \"0x126dd900b82c7fc95e8851f9c64d0600992e82657388a48d3c466553d4d9246\",\n"
"      \"0x46a89ae102987331d369645031b49c27738ed096f2789c24449966da4c6de6b\",\n"
"      \"0x17c1e31c270\"、\n"
"      \"0x0\"\n"
"    ]\n"
"  }\n"
"]\n"
"```"

#: src/ch03-04-nodes.md:394
#, fuzzy
msgid ""
"Once the transaction is accepted on Layer 1, we can query the Starknet Core "
"Contracts from our Layer 1 node to see the storage keys that have been "
"updated on our data layer!"
msgstr ""
"一旦第一层接受了交易，我们就可以从第一层节点查询Starknet核心合约，查看数据层更"
"新的存储密钥！"

#: src/ch03-04-nodes.md:398
#, fuzzy
msgid ""
"You have successfully navigated through the entire Starknet stack, from "
"setting up your node, through executing and monitoring a transaction, to "
"inspecting its effects on the data layer. This journey has equipped you with "
"the understanding and the skills to interact with Starknet on a deeper level."
msgstr ""
"您已成功浏览了整个 Starknet 堆栈，从设置您的节点，到执行和监控事务，再到检查其"
"对数据层的影响。通过这次学习，您已经掌握了与 Starknet 进行更深层次交互的知识和"
"技能。"

#: src/ch03-04-nodes.md:404
#, fuzzy
msgid "Conclusion: Understanding the Modular Nature of Starknet"
msgstr "结论：了解Starknet的模块性质"

#: src/ch03-04-nodes.md:406
#, fuzzy
msgid ""
"Conceptual models, such as the ones used in this guide, are incredibly useful "
"in helping us understand complex systems. They can be refactored, reformed, "
"and nested to provide a clear and comprehensive view of how a platform like "
"Starknet operates. For instance, the OSI Model, a foundational model for "
"understanding network interactions, underpins our modular stack."
msgstr ""
"概念模型（如本指南中使用的模型）在帮助我们理解复杂系统方面非常有用。它们可以被"
"重构、改造和嵌套，从而为像Starknet这样的平台如何运行提供一个清晰而全面的视图。"
"例如，OSI 模型是理解网络交互的基础模型，是我们模块化堆栈的基础。"

#: src/ch03-04-nodes.md:413
#, fuzzy
msgid ""
"A key concept to grasp is _Fractal Scaling._ This concept allows us to extend "
"our model to include additional layers beyond Layer 2, such as Layer 3. In "
"this extended model, the entire stack recurs above our existing stack, as "
"shown in the following diagram:"
msgstr ""
"我们需要掌握的一个关键概念是_分形扩展_。这个概念允许我们扩展我们的模型，以包括"
"第 2 层以外的其他层，如第 3 层。在这个扩展模型中，整个堆栈会在现有堆栈之上重复"
"出现，如下图所示："

#: src/ch03-04-nodes.md:420
#, fuzzy
msgid "Fractal scaling in a modular blockchain environment"
msgstr "模块化区块链环境中的分形扩展"

#: src/ch03-04-nodes.md:422
#, fuzzy
msgid ""
"Just as Layer 2 compresses its transaction throughput into a proof and state "
"change that is written to Layer 1, we can apply the same compression "
"principle at Layer 3, proving and writing to Layer 2. This not only gives us "
"more control over the protocol rules but also allows us to achieve higher "
"compression ratios, enhancing the scalability of our applications."
msgstr ""
"正如第 2 层将其事务吞吐量压缩为写入第 1 层的证明和状态变化一样，我们可以在第 "
"3 层应用相同的压缩原理，证明并写入第 2 层。这不仅能让我们对协议规则有更多控"
"制，还能让我们实现更高的压缩率，增强应用的可扩展性。"

#: src/ch03-04-nodes.md:429
#, fuzzy
msgid ""
"In essence, Starknet’s modular and layered design, combined with the power of "
"Fractal Scaling, offers a robust and scalable framework for building "
"decentralized applications. Understanding this structure is fundamental to "
"effectively leveraging Starknet’s capabilities and contributing to its "
"ecosystem."
msgstr ""
"从本质上讲，Starknet 的模块化分层设计与 Fractal Scaling 的强大功能相结合，为构"
"建去中心化应用提供了一个强大的可扩展框架。要有效利用Starknet的功能并为其生态系"
"统做出贡献，了解这种结构是基础。"

#: src/ch03-04-nodes.md:435
#, fuzzy
msgid ""
"This concludes our journey into running a Starknet node and traversing its "
"layered architecture. We hope that you now feel equipped to explore, "
"experiment with, and innovate within the Starknet ecosystem."
msgstr ""
"至此，我们的Starknet节点运行和分层架构之旅就结束了。我们希望您现在已经具备了"
"在 Starknet 生态系统中进行探索、实验和创新的能力。"

#: src/ch03-05-layer-3.md:1
#, fuzzy
msgid "Layer 3 (App Chains)"
msgstr "第 3 层（应用程序链）"

#: src/ch03-05-layer-3.md:3
#, fuzzy
msgid ""
"Appchains let you create a blockchain designed precisely for your "
"application’s needs. These specialized blockchains allow customization in "
"various aspects, such as hash functions and consensus algorithms. Moreover, "
"they inherit the security features of the Layer 1 or Layer 2 blockchains they "
"are built upon."
msgstr ""
"Appchains 可让您创建专为满足应用需求而设计的区块链。这些专用区块链允许在哈希函"
"数和共识算法等各个方面进行定制。此外，它们还继承了建立在其基础上的第 1 层或第 "
"2 层区块链的安全功能。"

#: src/ch03-05-layer-3.md:9
msgid "Example:"
msgstr "例子:"

#: src/ch03-05-layer-3.md:11
#, fuzzy
msgid ""
"Layer 3 blockchains can exist on top of Layer 2 blockchains. You can even "
"build additional layers (Layer 4 and so on) on top of Layer 3 for more "
"complex solutions. A sample layout is shown in the following diagram."
msgstr ""
"第 3 层区块链可以存在于第 2 层区块链之上。您甚至可以在第 3 层的基础上建立更多"
"层（第 4 层等等），以实现更复杂的解决方案。下图是一个布局示例。"

#: src/ch03-05-layer-3.md:18
#, fuzzy
msgid "Example of an environment with a Layers 3 and 4"
msgstr "第 3 层和第 4 层环境示例"

#: src/ch03-05-layer-3.md:20
#, fuzzy
msgid "In this example ecosystem, Layer 3 options include:"
msgstr "在此示例生态系统中，第 3 层选项包括"

#: src/ch03-05-layer-3.md:22
#, fuzzy
msgid ""
"The Public Starknet (L2), which is a general-purpose blockchain for "
"decentralized applications."
msgstr "公共Starknet（L2），这是一个用于去中心化应用的通用区块链。"

#: src/ch03-05-layer-3.md:25
#, fuzzy
msgid "A L3 Starknet optimized for cost-sensitive applications."
msgstr "针对成本敏感型应用进行了优化的 L3 Starknet。"

#: src/ch03-05-layer-3.md:27
#, fuzzy
msgid ""
"Customized L3 Starknet systems designed for enhanced performance, using "
"specific storage structures or data compression techniques."
msgstr ""
"定制的 L3 Starknet系统，采用特定的存储结构或数据压缩技术，旨在提高性能。"

#: src/ch03-05-layer-3.md:30
#, fuzzy
msgid ""
"StarkEx systems used by platforms like dYdX and Sorare, offering proven "
"scalability through data availability solutions like Validium or Rollup."
msgstr ""
"dYdX 和 Sorare 等平台使用的 StarkEx 系统，通过 Validium 或 Rollup 等数据可用性"
"解决方案提供久经考验的可扩展性。"

#: src/ch03-05-layer-3.md:34
#, fuzzy
msgid ""
"Privacy-focused Starknet instances, which could also function as a Layer 4, "
"for conducting transactions without including them in public Starknets."
msgstr ""
"注重隐私的Starknet实例，也可作为第 4 层，用于进行交易，而无需将其纳入公共"
"Starknet。"

#: src/ch03-05-layer-3.md:38
#, fuzzy
msgid "Benefits of Layer 3"
msgstr "第 3 层的优势"

#: src/ch03-05-layer-3.md:40
#, fuzzy
msgid ""
"Layer 3 app chains (with [Madara](https://github.com/keep-starknet-strange/"
"madara) as an apt sequencer or other option), offer a variety of advantages "
"due to its modularity and flexibility. Here’s an overview of the key benefits:"
msgstr ""
"第 3 层应用链（[Madara](https://github.com/keep-starknet-strange/madara) 可作"
"为适当的音序器或其他选项）具有模块化和灵活性等多种优势。以下是主要优势概述："

#: src/ch03-05-layer-3.md:45
#, fuzzy
msgid ""
"**Quick Iteration**: App chains enable rapid protocol changes, freeing you "
"from the constraints of the public Layer 2 roadmap. For example, you could "
"rapidly deploy new DeFi algorithms tailored to your user base."
msgstr ""
"**快速迭代**：应用链可实现协议的快速变更，使您摆脱公共第 2 层路线图的限制。例"
"如，您可以针对用户群快速部署新的 DeFi 算法。"

#: src/ch03-05-layer-3.md:50
#, fuzzy
msgid ""
"**Governance Independence**: You maintain complete control over feature "
"development and improvements, avoiding the need for decentralized governance "
"consensus. This enables, for example, quick implementation of user-suggested "
"features."
msgstr ""
"**治理独立**：您可以保持对功能开发和改进的完全控制，避免分散治理共识的需要。例"
"如，这样就能快速实施用户建议的功能。"

#: src/ch03-05-layer-3.md:55
#, fuzzy
msgid ""
"**Cost Efficiency**: Layer 3 offers substantial cost reductions, potentially "
"up to 1 million times compared to Layer 1, making it economically feasible to "
"run more complex applications."
msgstr ""
"**成本效益**：与第 1 层相比，第 3 层可大幅降低成本，最高可达 100 万倍，因此运"
"行更复杂的应用在经济上是可行的。"

#: src/ch03-05-layer-3.md:59
#, fuzzy
msgid ""
"**Security**: While there may be some trade-offs, such as reduced censorship "
"resistance, the core security mechanisms remain strong."
msgstr ""
"**安全**：虽然可能会有一些权衡，如降低抗审查能力，但核心安全机制依然强大。"

#: src/ch03-05-layer-3.md:62
#, fuzzy
msgid ""
"**Congestion Avoidance**: App chains are shielded from network congestion, "
"providing a more stable transaction environment, crucial for real-time "
"applications like gaming."
msgstr ""
"**避免拥堵**：应用链可避免网络拥塞，提供更稳定的交易环境，这对游戏等实时应用至"
"关重要。"

#: src/ch03-05-layer-3.md:66
#, fuzzy
msgid ""
"**Privacy Enhancements**: Layer 3 can serve as a testing ground for privacy-"
"centric features, which could include anonymous transactions or encrypted "
"messaging services."
msgstr ""
"**隐私增强**：第 3 层可作为以隐私为中心的功能的试验场，其中可包括匿名交易或加"
"密信息服务。"

#: src/ch03-05-layer-3.md:70
#, fuzzy
msgid ""
"**Innovation Platform**: App chains act as experimental fields where novel "
"features can be developed and tested. For instance, they could serve as a "
"testbed for new consensus algorithms before these are considered for Layer 2."
msgstr ""
"**创新平台**：应用链可作为开发和测试新功能的实验场。例如，在考虑将新的共识算法"
"用于第二层之前，它们可以作为这些算法的试验平台。"

#: src/ch03-05-layer-3.md:75
#, fuzzy
msgid ""
"In summary, Layer 3 provides the flexibility, cost-efficiency, and "
"environment conducive for innovation, without significant compromise on "
"security."
msgstr ""
"总之，第 3 层提供了灵活性、成本效益和有利于创新的环境，同时又不会严重影响安全"
"性。"

#: src/ch03-05-layer-3.md:79
#, fuzzy
msgid "Madara as a Sequencer for Layer 3 App Chains"
msgstr "玛达拉作为第 3 层应用链的序列器"

#: src/ch03-05-layer-3.md:81
#, fuzzy
msgid ""
"[Madara](https://github.com/keep-starknet-strange/madara) is a specialized "
"sequencer developed to execute transactions and group them into batches. "
"Created by the StarkWare Exploration Team, it functions as a starting point "
"for building Layer 3 Starknet appchains. This expands the possibilities for "
"innovation within the Starknet ecosystem."
msgstr ""
"[Madara](https://github.com/keep-starknet-strange/madara)是一个专门的排序器，"
"用于执行交易并将其分组成批。它由 StarkWare 探索团队开发，是构建第 3 层Starknet"
"应用链的起点。这为Starknet生态系统内的创新提供了更多可能性。"

#: src/ch03-05-layer-3.md:87
#, fuzzy
msgid ""
"Madara’s flexibility allows for the creation of Layer 3 appchains optimized "
"for various needs, foe example:"
msgstr "Madara 的灵活性允许创建针对各种需求进行优化的第 3 层应用链，例如："

#: src/ch03-05-layer-3.md:90
#, fuzzy
msgid ""
"Cost-Efficiency: Create an appchain for running a decentralized exchange "
"(DEX) with lower fees compared to the public Starknet."
msgstr ""
"成本效益：创建一个用于运行去中心化交易所（DEX）的应用链，与公共Starknet相比，"
"费用更低。"

#: src/ch03-05-layer-3.md:93
#, fuzzy
msgid ""
"Performance: Build an appchain to operate a DEX with faster transaction times."
msgstr "性能：构建应用链，以更快的交易时间运行 DEX。"

#: src/ch03-05-layer-3.md:96
#, fuzzy
msgid ""
"Privacy: Design an appchain to facilitate anonymous transactions or encrypted "
"messaging services."
msgstr "隐私保护设计一个应用链，为匿名交易或加密信息服务提供便利。"

#: src/ch03-05-layer-3.md:99
#, fuzzy
msgid ""
"For more information on Madara, refer to the subchapter with the same title."
msgstr "有关马达拉的更多信息，请参阅同名分章。"

#: src/ch04-00-account-abstraction.md:3
#, fuzzy
msgid ""
"Account Abstraction (AA) is a paradigm shift in how accounts and transactions "
"are managed in blockchain networks. To break it down, AA refers to two "
"intertwined notions:"
msgstr ""
"账户抽象（AA）是区块链网络中账户和交易管理模式的转变。细分起来，AA 指的是两个"
"相互交织的概念："

#: src/ch04-00-account-abstraction.md:7
#, fuzzy
msgid ""
"Transaction Flexibility: This gives the power to each smart contract to "
"validate its transactions, rather than enforcing a one-size-fits-all "
"validation process. This can lead to a variety of potential benefits such as "
"enabling smart contracts to pay for gas fees, allowing multiple signers for a "
"single account, and even introducing advanced cryptographic signatures."
msgstr ""
"交易灵活性：这赋予了每个智能合约验证其交易的权力，而不是强制执行一个放之四海而"
"皆准的验证流程。这可以带来各种潜在的好处，比如让智能合约支付燃气费，允许一个账"
"户有多个签名者，甚至引入高级加密签名。"

#: src/ch04-00-account-abstraction.md:14
#, fuzzy
msgid ""
"User Experience Optimization: AA provides a more intuitive experience for end-"
"users. It allows developers to create a more flexible security model, for "
"instance, allowing different keys for everyday use and high-value "
"transactions. Additionally, it eliminates, if wished, the need for seed "
"phrases, instead opting for easier recovery methods."
msgstr ""
"用户体验优化：AA 为终端用户提供了更直观的体验。它允许开发人员创建更灵活的安全"
"模型，例如，允许日常使用和高价值交易使用不同的密钥。此外，如果愿意，它还能消除"
"对种子短语的需求，而选择更简单的恢复方法。"

#: src/ch04-00-account-abstraction.md:21
#, fuzzy
msgid ""
"At a technical level, AA replaces Externally Owned Accounts (EOA) with a "
"generalized concept of accounts. Under this model, accounts can be "
"represented by a smart contract that dictates their specific rules and "
"behaviors. This means the user or contract account could dictate rules about "
"transaction ordering, signatures, access controls, and more, providing a high "
"level of customization."
msgstr ""
"在技术层面，AA 以账户的通用概念取代了外部拥有账户（EOA）。在这种模式下，账户可"
"以用智能合约来表示，智能合约规定了账户的具体规则和行为。这意味着用户或合约账户"
"可以决定交易排序、签名、访问控制等方面的规则，从而提供高度定制化的服务。"

#: src/ch04-00-account-abstraction.md:28
#, fuzzy
msgid "Here are two commonly cited definitions of AA:"
msgstr "以下是两种常见的 AA 定义："

#: src/ch04-00-account-abstraction.md:30
#, fuzzy
msgid ""
"Definition 1: Account Abstraction (AA) is when a **smart contract can pay for "
"its own transactions** (Martin Triay, Devcon 6)\\[1\\]. In other words, "
"abstract contracts (or account smart contracts) can pay for transactions. "
"This is a departure from the traditional Externally Owned Accounts or Smart "
"Wallets."
msgstr ""
"定义 1：账户抽象（AA）是指**智能合约可以为自己的交易支付**（Martin Triay，"
"Devcon 6）\\[1\\]。换句话说，抽象合约（或账户智能合约）可以为交易买单。这与传"
"统的外部拥有账户或智能钱包不同。"

#: src/ch04-00-account-abstraction.md:36
#, fuzzy
msgid ""
"Definition 2: AA is **validation abstraction**. Instead of relying on a "
"single method of transaction validation, as with Ethereum’s Layer 1, AA "
"enables an abstraction of the validation process. This implies the "
"possibility of using different types of signatures, cryptographic primitives, "
"execution processes, etc. (lightclient, Devcon 6)\\[3\\]."
msgstr ""
"定义 2：AA 是**验证抽象**。AA 实现了验证过程的抽象化，而不是像以太坊第一层那样"
"依赖于单一的交易验证方法。这意味着可以使用不同类型的签名、加密原语、执行过程等"
"（lightclient, Devcon 6）\\[3\\]。"

#: src/ch04-00-account-abstraction.md:42
#, fuzzy
msgid ""
"AA is positioned as the cornerstone of the next generation blockchain "
"technologies, with significant improvements in scalability, user experience, "
"and security. It is currently being pioneered by Layer 2 solutions, including "
"Starknet, as they aim to revolutionize the way we approach security, user "
"experience, and self-custody in the crypto space."
msgstr ""
"AA 被定位为下一代区块链技术的基石，在可扩展性、用户体验和安全性方面都有显著改"
"善。目前，包括Starknet（Starknet）在内的第 2 层解决方案正在率先使用 AA，他们的"
"目标是彻底改变加密货币领域的安全、用户体验和自我托管方式。"

#: src/ch04-00-account-abstraction.md:49
#, fuzzy
msgid "Applications of Account Abstraction"
msgstr "账户抽象的应用"

#: src/ch04-00-account-abstraction.md:51
#, fuzzy
msgid ""
"Having defined Account Abstraction, let’s delve into its practical "
"applications. Account Abstraction aims to improve both the accessibility and "
"security of self-custody. Here are a few of the key features that AA enables:"
msgstr ""
"在定义了账户抽象之后，让我们深入探讨其实际应用。账户抽象旨在提高自我保管的可访"
"问性和安全性。以下是 AA 实现的一些关键功能："

#: src/ch04-00-account-abstraction.md:56
#, fuzzy
msgid ""
"**Hardware Signer:** With AA, you could sign transactions using a key "
"generated and safeguarded by your smartphone’s secure enclave. This use of "
"biometric identity makes the process more secure and user-friendly "
"(Starkware)\\[4\\], (Braavos)\\[7\\]."
msgstr ""
"**硬件签名者：** 通过 AA，您可以使用智能手机安全飞地生成并保护的密钥来签署交"
"易。这种生物识别身份的使用使交易过程更加安全和用户友好（斯塔克软件）\\[4\\]，"
"（Braavos）\\[7\\]。"

#: src/ch04-00-account-abstraction.md:61
#, fuzzy
msgid ""
"**Social recovery:** With the integration of AA, if you lose or compromise "
"your key, you could securely replace it, thus eliminating the need for seed "
"phrases. This change not only enhances security but also simplifies the user "
"experience (Julien Niset, 2022)\\[5\\]."
msgstr ""
"**社交恢复：** 集成 AA 后，如果您丢失或损坏了密钥，您可以安全地更换密钥，从而"
"不再需要种子短语。这一改变不仅增强了安全性，还简化了用户体验（朱利安-尼塞特，"
"2022 年）\\[5\\]。"

#: src/ch04-00-account-abstraction.md:66
#, fuzzy
msgid ""
"**Key rotation:** If a key controlling your account is compromised, you can "
"easily replace it, negating the need to transfer your assets."
msgstr "**密钥轮换：** 如果控制账户的密钥被盗，您可以轻松更换，无需转移资产。"

#: src/ch04-00-account-abstraction.md:70
#, fuzzy
msgid ""
"**Session keys:** AA can enhance the usability of web3 applications by "
"allowing a _sign in once_ feature. This would enable websites to execute "
"transactions on your behalf, reducing the need for continuous approvals."
msgstr ""
"**会话密钥：** AA 允许使用 \"一次登录 \"功能，从而提高 web3 应用程序的可用性。"
"这将使网站能够代表您执行交易，从而减少持续审批的需要。"

#: src/ch04-00-account-abstraction.md:75
#, fuzzy
msgid ""
"**Custom transaction validation schemes:** AA enables the use of various "
"signature schemes, multisignatures, and other security rules. This "
"flexibility allows for customizable security measures to meet individual "
"user’s needs (Martin Triay, Devcon 6)\\[1\\], (Julien Niset, 2022)\\[5\\], "
"(Motty Lavie)\\[7\\]."
msgstr ""
"**自定义交易验证方案：** AA 允许使用各种签名方案、多重签名和其他安全规则。这种"
"灵活性允许定制安全措施，以满足个人用户的需求（Martin Triay, Devcon "
"6）\\[1\\], (Julien Niset, 2022)\\[5\\], (Motty Lavie)\\[7\\]。"

#: src/ch04-00-account-abstraction.md:81
#, fuzzy
msgid "Moreover, AA provides enhanced security in several ways:"
msgstr "此外，AA 还在多个方面增强了安全性："

#: src/ch04-00-account-abstraction.md:83
#, fuzzy
msgid ""
"**Improved key management:** With AA, you can associate multiple devices with "
"your wallet, so if one device is lost, you still have access to your account."
msgstr ""
"**改进密钥管理：** 使用 AA，您可以将多个设备与钱包关联，因此即使一个设备丢失，"
"您仍然可以访问自己的账户。"

#: src/ch04-00-account-abstraction.md:87
#, fuzzy
msgid ""
"**Various signature and validation schemes:** AA supports additional security "
"measures, like two-factor authentication for large transactions, providing a "
"more secure environment that adapts to individual user’s needs."
msgstr ""
"**各种签名和验证方案：** AA 支持额外的安全措施，如针对大型交易的双因素验证，提"
"供一个更安全的环境，以适应用户的不同需求。"

#: src/ch04-00-account-abstraction.md:92
#, fuzzy
msgid ""
"**Custom security policies:** Tailor security schemes to suit different types "
"of users or devices and adapt good practices from the banking and web2 "
"sectors."
msgstr ""
"**定制安全策略：** 定制安全方案，以适应不同类型的用户或设备，并借鉴银行和 "
"Web2 行业的良好做法。"

#: src/ch04-00-account-abstraction.md:96
#, fuzzy
msgid ""
"AA opens up new possibilities for both developers and users in the Ethereum "
"ecosystem. It offers a promising pathway for a more secure, user-friendly "
"experience and lays the groundwork for widespread adoption."
msgstr ""
"AA 为以太坊生态系统中的开发者和用户开辟了新的可能性。它为更安全、更友好的用户"
"体验提供了一条充满希望的途径，并为广泛采用奠定了基础。"

#: src/ch04-00-account-abstraction.md:101
#, fuzzy
msgid "Ethereum Account System"
msgstr "以太坊账户系统"

#: src/ch04-00-account-abstraction.md:103
#, fuzzy
msgid ""
"To fully understand the benefits of Account Abstraction (AA), let’s delve "
"into Ethereum’s current account system. The system is split into two types of "
"accounts:"
msgstr ""
"为了充分了解账户抽象（AA）的好处，让我们深入了解一下以太坊当前的账户系统。该系"
"统分为两类账户："

#: src/ch04-00-account-abstraction.md:107
#, fuzzy
msgid "**Externally Owned Accounts** (EOAs)"
msgstr "**外部拥有账户**（EOA）"

#: src/ch04-00-account-abstraction.md:109
#, fuzzy
msgid "**Contract Accounts** (CAs)."
msgstr "**合约账户**（CA）。"

#: src/ch04-00-account-abstraction.md:111
#, fuzzy
msgid ""
"EOAs are the accounts used by individuals, wallets, or any entity external to "
"the Ethereum network. These accounts are identified by their address, which "
"is derived from the public key of an associated cryptographic object called a "
"signer. This signer, or keypair, consists of a private key and a public key."
msgstr ""
"EOA 是个人、钱包或以太坊网络外部任何实体使用的账户。这些账户通过地址来识别，地"
"址来自于相关加密对象（称为签名者）的公钥。签名者或密钥对由私钥和公钥组成。"

#: src/ch04-00-account-abstraction.md:117
#, fuzzy
msgid ""
"The private key, also known as the secret key, is used to digitally sign "
"transactions or messages, establishing proof of ownership. The corresponding "
"public key is used to verify this signature, ensuring it was indeed signed by "
"the respective private key."
msgstr ""
"私钥又称秘钥，用于对交易或信息进行数字签名，以证明所有权。相应的公开密钥用于验"
"证该签名，确保其确实由相应的私人密钥签名。"

#: src/ch04-00-account-abstraction.md:122
#, fuzzy
msgid ""
"This means, in order to modify the state of an account, a transaction must be "
"initiated and signed by the corresponding private key of the account’s EOA. "
"This design choice ensures security by associating each account with a unique "
"cryptographic identity."
msgstr ""
"这意味着，要修改一个账户的状态，必须由该账户 EOA 的相应私钥启动和签署交易。这"
"种设计选择将每个账户与唯一的加密身份关联起来，从而确保了安全性。"

#: src/ch04-00-account-abstraction.md:127
#, fuzzy
msgid ""
"On the other hand, CAs are smart contracts living on the Ethereum blockchain. "
"Unlike EOAs, they do not have a private key. They are triggered through "
"transactions or messages initiated by EOAs, and their behavior is determined "
"by their associated code."
msgstr ""
"另一方面，CA 是生活在以太坊区块链上的智能合约。与 EOA 不同，它们没有私钥。它们"
"通过 EOA 发起的交易或消息触发，其行为由相关代码决定。"

#: src/ch04-00-account-abstraction.md:132
#, fuzzy
msgid "However, the current account model presents some challenges:"
msgstr "然而，经常账户模式也带来了一些挑战："

#: src/ch04-00-account-abstraction.md:134
#, fuzzy
msgid ""
"**Key Management:** The loss of a private key is catastrophic. Given that the "
"private key represents the ownership of the account, if it is lost, all the "
"assets within the account are lost too. Similarly, if it gets stolen, the "
"perpetrator gains full control over the account and its assets."
msgstr ""
"**密钥管理：** 私人密钥的丢失是灾难性的。由于私人密钥代表账户的所有权，如果丢"
"失，账户内的所有资产也会丢失。同样，如果私人密钥被盗，犯罪者就能完全控制账户及"
"其资产。"

#: src/ch04-00-account-abstraction.md:140
#, fuzzy
msgid ""
"**User Experience:** Currently, the Ethereum account model lacks user-"
"friendly methods for key recovery or account recovery, which can discourage "
"non-technical users. Additionally, user interfaces, such as crypto wallets, "
"can be overwhelming and difficult to use, presenting barriers for wider "
"adoption."
msgstr ""
"**用户体验：** 目前，以太坊账户模式缺乏用户友好的密钥恢复或账户恢复方法，这可"
"能会让非技术用户望而却步。此外，用户界面（如加密货币钱包）可能会让人不知所措，"
"难以使用，从而阻碍了更广泛的应用。"

#: src/ch04-00-account-abstraction.md:146
#, fuzzy
msgid ""
"**Lack of Flexibility:** The traditional model doesn’t allow for custom "
"transaction validation schemes, limiting the possible security and access "
"control improvements."
msgstr ""
"**缺乏灵活性：** 传统模式不允许自定义交易验证方案，从而限制了可能的安全和访问"
"控制改进。"

#: src/ch04-00-account-abstraction.md:150
#, fuzzy
msgid ""
"Account Abstraction proposes to improve upon these limitations, offering new "
"possibilities in terms of security, scalability, and user experience."
msgstr ""
"账户抽象建议改进这些局限性，在安全性、可扩展性和用户体验方面提供新的可能性。"

#: src/ch04-00-account-abstraction.md:154
#, fuzzy
msgid "The Need for Account Abstraction"
msgstr "账户抽象化的必要性"

#: src/ch04-00-account-abstraction.md:156
#, fuzzy
msgid ""
"As the crypto ecosystem matures and attracts a broader user base, it faces "
"pivotal challenges that demand innovative solutions. Among these, the "
"question of Account Abstraction (AA) has taken center stage. Ethereum, one of "
"the leading platforms for smart contracts and Decentralized Applications "
"(dApps), is in a precarious position: it must embrace Account Abstraction or "
"risk its position in the crypto world."
msgstr ""
"随着加密生态系统日趋成熟并吸引了更广泛的用户群，它也面临着需要创新解决方案的关"
"键挑战。其中，账户抽象（AA）问题已成为焦点。以太坊作为智能合约和去中心化应用程"
"序（dApps）的领先平台之一，正处于岌岌可危的境地：它必须接受账户抽象，否则就会"
"危及其在加密世界中的地位。"

#: src/ch04-00-account-abstraction.md:163
#, fuzzy
msgid ""
"Without AA, Ethereum’s ability to provide a seamless, empowering, and secure "
"experience for its users is hampered. This could lead to users abandoning the "
"platform for centralized exchanges and wallets, a trend that would undermine "
"the very ethos of decentralization that cryptocurrency and blockchain "
"technology espouse."
msgstr ""
"没有 AA，以太坊为用户提供无缝、授权和安全体验的能力就会受到影响。这可能会导致"
"用户放弃该平台，转而使用中心化的交易所和钱包，这一趋势将破坏加密货币和区块链技"
"术所倡导的去中心化理念。"

#: src/ch04-00-account-abstraction.md:169
#, fuzzy
msgid ""
"There are several compelling reasons why Ethereum, and the larger crypto "
"ecosystem, need Account Abstraction:"
msgstr "以太坊和更大的加密货币生态系统需要账户抽象有几个令人信服的原因："

#: src/ch04-00-account-abstraction.md:172
#, fuzzy
msgid ""
"**Risk of Centralization:** The inefficiencies and limitations of the current "
"account model may push users towards centralized exchanges and wallets. These "
"entities defy the principles of decentralization, presenting familiar risks "
"such as censorship, discrimination, and potential abuse of power. Account "
"Abstraction, by enabling easier and more secure account management, can help "
"uphold the principles of decentralization."
msgstr ""
"**中心化风险：** 当前账户模式的低效率和局限性可能会将用户推向中心化的交易所和"
"钱包。这些实体违背了去中心化的原则，带来了我们熟悉的风险，如审查、歧视和潜在的"
"滥用权力。账户抽象通过实现更简单、更安全的账户管理，有助于维护去中心化原则。"

#: src/ch04-00-account-abstraction.md:180
#, fuzzy
msgid ""
"**Quantum Threat:** Quantum computing poses a potential threat to "
"cryptographic systems, with its ability to break traditional security "
"measures. Account Abstraction can address this by enabling the use of "
"different signature schemes, including quantum-resistant ones, enhancing the "
"security of assets on the blockchain."
msgstr ""
"**量子威胁：** 量子计算能够打破传统的安全措施，对加密系统构成潜在威胁。账户抽"
"象可以通过使用不同的签名方案（包括抗量子方案）来解决这一问题，从而增强区块链上"
"资产的安全性。"

#: src/ch04-00-account-abstraction.md:186
#, fuzzy
msgid ""
"**Scaling Self-Custody:** As the next billion users approach the crypto "
"ecosystem, the importance of scaling self-custody becomes paramount. AA can "
"improve the scalability of self-custody, which is essential for onboarding "
"these new users."
msgstr ""
"**扩展自托管：** 随着下一个十亿级用户接近加密生态系统，扩展自托管变得至关重"
"要。AA 可以提高自托管的可扩展性，这对于接纳这些新用户至关重要。"

#: src/ch04-00-account-abstraction.md:191
#, fuzzy
msgid ""
"**User Experience:** Simplifying the onboarding process and user experience "
"is essential for widespread adoption. The complexity associated with current "
"wallets and key management systems can be daunting for newcomers. Account "
"Abstraction promises to simplify these aspects, paving the way for a more "
"intuitive user experience."
msgstr ""
"**用户体验：** 简化入职流程和用户体验对于广泛采用至关重要。当前钱包和密钥管理"
"系统的复杂性会让新用户望而生畏。账户抽象有望简化这些方面，为更直观的用户体验铺"
"平道路。"

#: src/ch04-00-account-abstraction.md:197
#, fuzzy
msgid ""
"Starknet is currently leading the efforts to implement Account Abstraction at "
"the protocol level. Many consider it to be the \"proving ground\" for the "
"future of AA. With numerous experts from different organizations "
"collaborating, Starknet aims to redefine the approach to security, user "
"experience, and self-custody in the crypto space."
msgstr ""
"Starknet公司目前正在牵头实施协议层面的账户抽象。许多人认为它是未来 AA 的 \"试"
"验场\"。通过与来自不同组织的众多专家合作，Starknet旨在重新定义加密领域的安全、"
"用户体验和自我保管方法。"

#: src/ch04-00-account-abstraction.md:203
#, fuzzy
msgid ""
"The stakes are high. The future of Ethereum, and by extension, the crypto "
"ecosystem, is deeply intertwined with the success of Account Abstraction. If "
"Ethereum cannot adapt, it risks losing its prominence to other, more "
"adaptable platforms."
msgstr ""
"利害关系重大。以太坊以及加密货币生态系统的未来与账户抽象的成功息息相关。如果以"
"太坊不能适应，就有可能被其他适应性更强的平台取代。"

#: src/ch04-00-account-abstraction.md:208
#, fuzzy
msgid "Why Isn’t Account Abstraction Implemented in Ethereum’s Layer 1 Yet?"
msgstr "为什么以太坊第一层还没有实现账户抽象？"

#: src/ch04-00-account-abstraction.md:210
#, fuzzy
msgid ""
"Ethereum’s Layer 1 (L1) doesn’t yet support Account Abstraction (AA) at a "
"protocol level, not due to lack of desire or understanding of its importance, "
"but rather due to the complexity of its implementation."
msgstr ""
"以太坊的第一层（L1）尚未在协议层面支持账户抽象（AA），这并不是因为缺乏意愿或不"
"了解其重要性，而是因为其实现的复杂性。"

#: src/ch04-00-account-abstraction.md:214
#, fuzzy
msgid ""
"The most prominent roadblock in integrating AA is the entrenched nature of "
"Externally Owned Accounts (EOAs) in Ethereum’s architecture. These accounts, "
"as fundamental elements of the Ethereum core protocol, would need significant "
"alteration to support AA, an undertaking that becomes more daunting as the "
"value secured by Ethereum continues to rise."
msgstr ""
"整合 AA 的最突出障碍是以太坊架构中根深蒂固的外部自有账户（EOA）。这些账户作为"
"以太坊核心协议的基本要素，需要进行重大改动才能支持 AA，而随着以太坊担保价值的"
"不断上升，这项工作也变得更加艰巨。"

#: src/ch04-00-account-abstraction.md:220
#, fuzzy
msgid ""
"One key aspect that complicates the integration of AA into Ethereum’s L1 is "
"the Ethereum Virtual Machine (EVM). The EVM, as the runtime environment for "
"smart contracts in Ethereum, has limitations that hinder the implementation "
"of AA. While there have been several proposals for AA since Ethereum’s "
"inception, they have been consistently delayed due to other pressing updates "
"and improvements to the Ethereum network."
msgstr ""
"使 AA 与以太坊 L1 集成复杂化的一个关键方面是以太坊虚拟机（EVM）。EVM 作为以太"
"坊智能合约的运行环境，其局限性阻碍了 AA 的实施。尽管自以太坊诞生以来，已有多个"
"关于 AA 的提案，但由于以太坊网络急需更新和改进，这些提案一直被推迟。"

#: src/ch04-00-account-abstraction.md:227
#, fuzzy
msgid ""
"However, the emergence of Layer 2 (L2) solutions provides a new pathway for "
"the implementation of AA. With their focus on scalability and performance "
"enhancements, these new virtual machines can better accommodate AA. Starknet "
"and ZKSync are examples of platforms that have native AA inspired by EIP4337 "
"– a proposal deemed superior by industry experts like Argent’s Julien Niset."
msgstr ""
"然而，第 2 层（L2）解决方案的出现为 AA 的实施提供了新的途径。这些新的虚拟机注"
"重可扩展性和性能提升，可以更好地适应 AA。Starknet 和 ZKSync 就是在 EIP4337 的"
"启发下实现本地 AA 的平台范例，Argent 的 Julien Niset 等业内专家认为该方案更胜"
"一筹。"

#: src/ch04-00-account-abstraction.md:234
#, fuzzy
msgid ""
"The repeated postponements and challenges in implementing AA on Ethereum’s L1 "
"have led many proponents, including Niset, to shift their focus. Instead of "
"hoping for EOAs to be phased out and AA integrated at Ethereum’s core, they "
"are now advocating for the broad adoption of AA through L2 solutions like "
"Starknet. This strategy could bring the benefits of AA to users sooner and "
"help the Ethereum network remain competitive in the rapidly evolving crypto "
"landscape."
msgstr ""
"在以太坊 L1 上实施 AA 的一再推迟和挑战导致包括 Niset 在内的许多支持者转移了他"
"们的关注点。他们不再寄希望于 EOA 被逐步淘汰并将 AA 集成到以太坊的核心中，而是"
"主张通过像 Starknet 这样的 L2 解决方案来广泛采用 AA。这一策略可以让用户更快地"
"享受到 AA 带来的好处，并帮助以太坊网络在快速发展的加密货币领域保持竞争力。"

#: src/ch04-00-account-abstraction.md:244
#, fuzzy
msgid ""
"To bring it all home, imagine the Ethereum account system as a kind of "
"multifunctional Swiss Army knife, currently under renovation. What we’re "
"doing with Account Abstraction is swapping out a few tools - while it was "
"once a knife and a corkscrew, we’re making it into a magnifying glass and a "
"set of tweezers."
msgstr ""
"把这一切都归纳起来，可以把以太坊账户系统想象成一把多功能瑞士军刀，目前正在翻"
"新。我们通过账户抽象所做的就是更换一些工具--它曾经是一把小刀和一把开瓶器，而现"
"在我们要把它变成一个放大镜和一套镊子。"

#: src/ch04-00-account-abstraction.md:250
#, fuzzy
msgid ""
"Why the change? The original tools served us well, but they didn’t fit every "
"task we found ourselves up against. Some jobs required precision; others "
"needed a broader lens. That’s where Account Abstraction shines. It expands "
"Ethereum’s capabilities, adjusting and adapting to our ever-evolving "
"requirements."
msgstr ""
"为什么要改变？原来的工具为我们提供了很好的服务，但它们并不适合我们所面临的每项"
"任务。有些工作要求精确，有些则需要更广阔的视角。这正是账户抽象的优势所在。它扩"
"展了 Ethereum 的功能，根据我们不断变化的要求进行调整和适应。"

#: src/ch04-00-account-abstraction.md:256
#, fuzzy
msgid ""
"Remember the complications of Ethereum’s current account system? Account "
"Abstraction seeks to transform those by offering more flexible, personalized, "
"and safer solutions. It’s like tailoring the tools of your Swiss Army knife "
"to your unique needs."
msgstr ""
"还记得以太坊当前账户系统的复杂性吗？账户抽象旨在通过提供更灵活、更个性化、更安"
"全的解决方案来改变这些问题。这就像根据你的独特需求定制你的瑞士军刀工具一样。"

#: src/ch04-00-account-abstraction.md:261
#, fuzzy
msgid ""
"However, it’s not yet implemented into Ethereum’s Layer 1. And why? The "
"kitchen is bustling, and the chefs are wary of spilling the soup. The "
"implementation process has its challenges, it’s true. But the cook who never "
"dropped a pan never learned to make an omelette. That’s why research and "
"development continue relentlessly."
msgstr ""
"然而，以太坊的第一层还没有实现这一点。原因何在？厨房里熙熙攘攘，厨师们生怕汤洒"
"了。实施过程确实存在挑战。但是，从未掉过锅的厨师永远也学不会做煎蛋。这就是为什"
"么研发工作要坚持不懈地进行下去。"

#: src/ch04-00-account-abstraction.md:267
#, fuzzy
msgid ""
"Through the lens of Account Abstraction, we see Ethereum’s future—secure, "
"accessible, flexible. It’s an exciting, transformative prospect that’s "
"redefining what we thought possible. And though the path may be fraught with "
"complexities and risks, it’s a journey well worth taking."
msgstr ""
"通过账户抽象的视角，我们看到了以太坊的未来--安全、易用、灵活。这是一个令人兴奋"
"的变革性前景，它正在重新定义我们所认为的可能。尽管这条道路可能充满复杂性和风"
"险，但这是一段非常值得一走的旅程。"

#: src/ch04-00-account-abstraction.md:273
#, fuzzy
msgid ""
"After all, the Swiss Army knife was once just a knife. Imagine what it could "
"become next."
msgstr "毕竟，瑞士军刀曾经只是一把刀。想象一下它下一步会变成什么。"

#: src/ch04-00-account-abstraction.md:276
msgid "References:"
msgstr "引用："

#: src/ch04-00-account-abstraction.md:278
#, fuzzy
msgid ""
"\\[1\\] Martin Triay, Devcon 6: <https://www.youtube.com/watch?v=Osc_gwNW3Fw>"
msgstr "\\Martin Triay, Devcon 6: <https://www.youtube.com/watch?v=Osc_gwNW3Fw>"

#: src/ch04-00-account-abstraction.md:281
#, fuzzy
msgid "\\[2\\] Julien Niset: <https://www.youtube.com/watch?v=OwppworJGzs>"
msgstr "\\[2\\] Julien Niset：<https://www.youtube.com/watch?v=OwppworJGzs>"

#: src/ch04-00-account-abstraction.md:283
#, fuzzy
msgid "\\[3\\] lightclient, Devcon 6: <https://app.devcon.org/schedule/9mvqce>"
msgstr "\\lightclient, Devcon 6: <https://app.devcon.org/schedule/9mvqce>"

#: src/ch04-00-account-abstraction.md:286
#, fuzzy
msgid ""
"\\[4\\] Starkware: <https://medium.com/@starkware/how-starknet-is-"
"revolutionizing-crypto-signing-ba3724077a79>"
msgstr ""
"\\[4\\] Starkware：<https://medium.com/@starkware/how-starknet-is-"
"revolutionizing-crypto-signing-ba3724077a79>"

#: src/ch04-00-account-abstraction.md:289
#, fuzzy
msgid ""
"\\[5\\] Julien Niset, 2022: <https://www.argent.xyz/blog/part-2-wtf-is-"
"account-abstraction/>"
msgstr ""
"\\Julien Niset, 2022: <https://www.argent.xyz/blog/part-2-wtf-is-account-"
"abstraction/>"

#: src/ch04-00-account-abstraction.md:292
#, fuzzy
msgid "\\[6\\] Yoav, Devcon 6: <https://app.devcon.org/schedule/9mvqce>"
msgstr "\\Yoav, Devcon 6: <https://app.devcon.org/schedule/9mvqce>"

#: src/ch04-00-account-abstraction.md:294
#, fuzzy
msgid "\\[7\\] Motty Lavie, 2023: <https://www.youtube.com/watch?v=FrxAdJYhSY8>"
msgstr "\\Motty Lavie, 2023：<https://www.youtube.com/watch?v=FrxAdJYhSY8>"

#: src/ch04-01-accounts.md:1
#, fuzzy
msgid "Account Contracts"
msgstr "账户合约"

#: src/ch04-01-accounts.md:3
#, fuzzy
msgid ""
"Now that we know better the concept of AA, let’s actually code it in Starknet."
msgstr ""
"既然我们已经对 AA 的概念有了更深入的了解，那么就让我们在Starknet中对它进行实际"
"编码吧。"

#: src/ch04-01-accounts.md:6
#, fuzzy
msgid "Account Contract Interface"
msgstr "账户合约界面"

#: src/ch04-01-accounts.md:8
#, fuzzy
msgid ""
"Account contracts, while essentially being smart contracts, differentiate "
"themselves through unique methods. A smart contract gains the status of an "
"account contract when it implements the interface as described by SNIP-6 "
"([StarkNet IMprovement Proposa-6: Standar Account Interface](https://github."
"com/ericnordelo/SNIPs/blob/feat/standard-account/SNIPS/snip-6.md)). This "
"standard borrows from SRC-6 and SRC-5, which are akin to Ethereum’s ERCs, "
"setting application-level conventions and contract standards."
msgstr ""
"账户合约本质上也是智能合约，但通过独特的方法来区分自己。当智能合约实现了 "
"SNIP-6 所描述的接口（[StarkNet IMprovement Proposa-6: Standar Account "
"Interface](https://github.com/ericnordelo/SNIPs/blob/feat/standard-account/"
"SNIPS/snip-6.md)）时，它就获得了账户合约的地位。该标准借鉴了 SRC-6 和 SRC-5，"
"它们类似于以太坊的ERC，设定了应用层面的约定和合约标准。"

#: src/ch04-01-accounts.md:16
#, fuzzy
msgid ""
"To initiate, let’s formulate the `ISRC6` (SNIP-6: Standard Account Interface) "
"trait, which outlines the requisite functions for an account contract:"
msgstr ""
"首先，我们来制定 \"ISRC6\"（SNIP-6：标准账户接口）特征，它概述了账户合约的必要"
"功能："

#: src/ch04-01-accounts.md:28
#, fuzzy
msgid "The functions represented above serve the following purposes:"
msgstr "上述功能的作用如下"

#: src/ch04-01-accounts.md:30
#, fuzzy
msgid ""
"`__validate__`: This function takes in the list of calls scheduled for "
"execution and validates them in line with the rules specified in the "
"contract. It returns a short string (e.g., VALID) encapsulated within a "
"`felt252` that signifies the validation outcome."
msgstr ""
"__validate__`：该函数接收预定执行的调用列表，并根据合约中指定的规则对其进行验"
"证。它返回一个封装在 `felt252` 中的短字符串（如 VALID），表示验证结果。"

#: src/ch04-01-accounts.md:35
#, fuzzy
msgid ""
"`is_valid_signature`: This function is tasked with validating the signature "
"of a transaction. It receives a hash of the transaction data and a signature, "
"which may be validated against a public key or through any other method as "
"specified by the contract creator. It returns a short string (e.g., VALID) "
"encapsulated within a `felt252` that signifies the validation outcome."
msgstr ""
"is_valid_signature`：该函数的任务是验证交易的签名。它接收交易数据的哈希值和签"
"名，签名可通过公钥或合约创建者指定的其他方法进行验证。它返回一个封装在 "
"\"felt252 \"中的短字符串（如 VALID），表示验证结果。"

#: src/ch04-01-accounts.md:42
#, fuzzy
msgid ""
"`__execute__`: Post-validation, the `__execute__` function is responsible for "
"executing an array of contract calls (as `Call` structs). It returns an array "
"of `Span<felt252>` structs representing the return values of the executed "
"calls."
msgstr ""
"__execute__`：验证后，`__execute__` 函数负责执行合约调用数组（作为 `Call` 结"
"构）。它返回一个 `Span<felt252>` 结构数组，代表已执行调用的返回值。"

#: src/ch04-01-accounts.md:47
#, fuzzy
msgid ""
"Moreover, the `SNIP-5` (Standard Interface Detection) trait needs to be "
"defined with a function called `supports_interface`. This function verifies "
"whether a contract supports a specific interface, receiving an interface ID "
"and returning a boolean."
msgstr ""
"此外，\"SNIP-5\"（标准接口检测）特性需要定义一个名为 \"supports_interface \"的"
"函数。该函数接收一个接口 ID 并返回一个布尔值，以验证合约是否支持特定接口。"

#: src/ch04-01-accounts.md:58
#, fuzzy
msgid ""
"Until now, we’ve mentioned contract calls without explicitly defining them. "
"Let’s remedy that."
msgstr ""
"到目前为止，我们只提到了合约调用，却没有明确定义它们。让我们来弥补这个缺陷。"

#: src/ch04-01-accounts.md:61
#, fuzzy
msgid "The `Call` struct represents a single contract call:"
msgstr "Call\" 结构表示单个合约调用："

#: src/ch04-01-accounts.md:71
#, fuzzy
msgid "Here’s what each field signifies:"
msgstr "以下是每个字段的含义："

#: src/ch04-01-accounts.md:73
#, fuzzy
msgid "`to`: The address of the target contract."
msgstr "`to`：目标合约的地址。"

#: src/ch04-01-accounts.md:75
#, fuzzy
msgid ""
"`selector`: The function’s selector to be invoked on the target contract."
msgstr "选择器：要在目标合约上调用的函数选择器。"

#: src/ch04-01-accounts.md:78
#, fuzzy
msgid "`calldata`: An array that encapsulates the function parameters."
msgstr "calldata`：封装函数参数的数组。"

#: src/ch04-01-accounts.md:80
#, fuzzy
msgid ""
"The elements described above are foundational to defining an account contract "
"and sufficient to implement the SNIP-6 standard. Nevertheless, there are "
"additional components that can be incorporated to bolster the account "
"contract’s functionality. For instance, the `__validate_declare__` function "
"might be added if the contract is used to declare other contracts, providing "
"a mechanism to validate the contract declaration. Additionally, to "
"counterfactually deploy a smart contract (i.e., have it pay for its own "
"deployment), one can include the `__validate_deploy__` function. Detailed "
"implementations of these functions will be covered in the subsequent chapters."
msgstr ""
"上述要素是定义账户合约的基础，足以实施 SNIP-6 标准。尽管如此，还可以加入其他元"
"素来增强账户合约的功能。例如，如果合约被用来声明其他合约，就可以添加 "
"`__validate_declare___'函数，以提供验证合约声明的机制。此外，为了反事实地部署"
"智能合约（即让它为自己的部署付费），可以加入 `___validate_deploy__`函数。这些"
"函数的详细实现将在后续章节中介绍。"

#: src/ch04-01-accounts.md:91 src/ch04-02-hello-account.md:183
#: src/ch04-03-standard-account.md:363
msgid "Summary"
msgstr "摘要"

#: src/ch04-01-accounts.md:93
#, fuzzy
msgid ""
"We elucidated the unique aspects of account contracts and their derivation "
"from basic smart contracts by adhering to specific methods outlined in SNIP-6."
msgstr ""
"我们按照 SNIP-6 中概述的具体方法，阐明了账户合约的独特之处及其从基本智能合约衍"
"生而来的过程。"

#: src/ch04-01-accounts.md:97
#, fuzzy
msgid ""
"We defined the `ISRC6` trait, detailing the critical functions, namely, "
"`__validate__`, `is_valid_signature`, and `__execute__`. These functions "
"carry out tasks such as transaction validation, signature verification, and "
"contract call execution, respectively. We further introduced the `ISRC5` "
"trait, emphasizing the `supports_interface` function for verifying interface "
"support in contracts."
msgstr ""
"我们定义了 \"ISRC6 \"特性，详细说明了关键函数，即"
"\"__validate__\"、\"is_valid_signature \"和\"__execute__\"。这些函数分别执行交"
"易验证、签名验证和合约调用执行等任务。我们进一步引入了 `ISRC5` 特质，强调 "
"`supports_interface` 函数用于验证合约中的接口支持。"

#: src/ch04-01-accounts.md:104
#, fuzzy
msgid ""
"Furthermore, we defined a single contract call using the `Call` struct, "
"explaining its fields— `to`, `selector`, and `calldata`. We also discussed "
"potential enhancements to account contracts using `__validate_declare__` and "
"`__validate_deploy__` functions. These additional features, along with "
"detailed function implementations, will be explored in the chapters ahead."
msgstr ""
"此外，我们使用 `Call` 结构定义了单个合约调用，并解释了其字段--`to`、"
"`selector` 和 `calldata`。我们还讨论了使用 `__validate_declare__`和 "
"`__validate_deploy__`函数对账户合约进行增强的可能性。我们将在后面的章节中探讨"
"这些附加功能以及详细的函数实现。"

#: src/ch04-01-accounts.md:111
#, fuzzy
msgid ""
"In the next subchapter, we will implement a simple account contract and learn "
"how to deploy it on Starknet. This will provide a practical understanding of "
"how account contracts work and how to interact with them."
msgstr ""
"在下一小节中，我们将实现一个简单的账户合约，并学习如何在Starknet进行部署。这将"
"使我们切实了解账户合约的工作原理以及如何与之交互。"

#: src/ch04-02-hello-account.md:1
#, fuzzy
msgid "Hello World Account Contract"
msgstr "你好，世界账户合约"

#: src/ch04-02-hello-account.md:3 src/ch04-03-standard-account.md:3
#: src/ch04-04-01-multicaller.md:3 src/ch04-04-02-multisig.md:3
#, fuzzy
msgid ""
"**NOTE:** **THIS CHAPTER NEEDS TO BE UPDATED TO REFLECT THE NEW SYNTAX FOR "
"ACCOUNT CONTRACTS. PLEASE DO NOT USE THIS CHAPTER AS A REFERENCE UNTIL THIS "
"NOTE IS REMOVED.**"
msgstr ""
"**注：** **本章需要更新，以反映账户合约的新语法。在删除本注释之前，请勿将本章"
"用作参考。"

#: src/ch04-02-hello-account.md:6 src/ch04-03-standard-account.md:6
#: src/ch04-04-01-multicaller.md:6 src/ch04-04-02-multisig.md:6
#, fuzzy
msgid ""
"**CONTRIBUTE: This subchapter is missing an example of declaration, "
"deployment and interaction with the contract. We would love to see your "
"contribution! Please submit a PR.**"
msgstr ""
"**贡献：本小节缺少一个关于声明、部署和与合约交互的示例。我们希望看到您的贡献！"
"请提交 PR.**"

#: src/ch04-02-hello-account.md:8
#, fuzzy
msgid ""
"In this chapter, we will explore the fundamentals of account contracts in "
"Starknet using an example \"Hello World\" account contract written in Cairo "
"language. You can find it in the contracts directory of this chapter in the "
"Book’s repository (TODO: add link)."
msgstr ""
"在本章中，我们将使用一个用Cairo语言编写的 \"Hello World \"账户合约示例来探讨"
"Starknet账户合约的基本原理。你可以在本书资源库中本章的合约目录下找到它（TODO："
"添加链接）。"

#: src/ch04-02-hello-account.md:13
#, fuzzy
msgid ""
"```rust\n"
"    // Import necessary modules\n"
"    #[account_contract]\n"
"    mod HelloAccount {\n"
"        use starknet::ContractAddress;\n"
"        use core::felt252;\n"
"        use array::ArrayTrait;\n"
"        use array::SpanTrait;\n"
"\n"
"        // Validate deployment of the contract.\n"
"        // Returns starknet::VALIDATED to confirm successful validation.\n"
"        #[external]\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, public_key_: "
"felt252\n"
"        ) -> felt252 {\n"
"            starknet::VALIDATED\n"
"        }\n"
"\n"
"        // Validate declaration of transactions using this Account.\n"
"        // This function enforces that transactions now require accounts to "
"pay fees.\n"
"        // Returns starknet::VALIDATED to confirm successful validation.\n"
"        #[external]\n"
"        fn __validate_declare__(class_hash: felt252) -> felt252 {\n"
"            starknet::VALIDATED\n"
"        }\n"
"\n"
"        // Validate transaction before execution.\n"
"        // This function is called by the account contract upon receiving a "
"transaction.\n"
"        // If the validation is successful, it returns starknet::VALIDATED.\n"
"        #[external]\n"
"        fn __validate__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, "
"calldata: Array::<felt252>\n"
"        ) -> felt252 {\n"
"            starknet::VALIDATED\n"
"        }\n"
"\n"
"        // Execute transaction.\n"
"        // If the '__validate__' function is successful, this '__execute__' "
"function will be called.\n"
"        // It forwards the call to the target contract using starknet::"
"call_contract_syscall.\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, "
"calldata: Array::<felt252>\n"
"        ) -> Span::<felt252> {\n"
"            starknet::call_contract_syscall(\n"
"                address: contract_address,\n"
"                entry_point_selector: entry_point_selector,\n"
"                calldata: calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    // 导入必要的模块\n"
"    #[account_contract]\n"
"    mod HelloAccount {\n"
"        使用 starknet::ContractAddress；\n"
"        使用 core::felt252；\n"
"        使用 array::ArrayTrait；\n"
"        使用 array::SpanTrait；\n"
"\n"
"        // 验证合约的部署。\n"
"        // 返回 starknet::VALIDATED 以确认验证成功。\n"
"        #[外部］\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, public_key_: "
"felt252\n"
"        ) -&gt; felt252 {\n"
"            Starknet::验证\n"
"        }\n"
"\n"
"        // 验证使用此账户进行交易的声明。\n"
"        // 该函数强制执行现在需要账户支付费用的交易。\n"
"        // 返回 starknet::VALIDATED 以确认验证成功。\n"
"        #[外部］\n"
"        fn __validate_declare__(class_hash: felt252) -&gt; felt252 {\n"
"            starknet::VALIDATED\n"
"        }\n"
"\n"
"        // 执行前验证交易。\n"
"        // 账户合约在收到交易时会调用该函数。\n"
"        // 如果验证成功，则返回 starknet::VALIDATED。\n"
"        #[外部］\n"
"        fn __validate__(\n"
"            contract_address：ContractAddress, entry_point_selector: felt252, "
"calldata：Array:：<felt252>\n"
"        ) -&gt; felt252 {\n"
"            Starknet::验证\n"
"        }\n"
"\n"
"        // 执行事务。\n"
"        // 如果\"__validate__\"函数成功执行，将调用此\"__execute__\"函数。\n"
"        // 它会使用 starknet::call_contract_syscall 将调用转发到目标合约。\n"
"        #[外部］\n"
"        #[原始输出］\n"
"        fn __execute__(\n"
"            contract_address：ContractAddress, entry_point_selector: felt252, "
"calldata：Array:：<felt252>\n"
"        ) -&gt; Span:：<felt252> {\n"
"            starknet::call_contract_syscall(\n"
"                address: contract_address、\n"
"                entry_point_selector: entry_point_selector、\n"
"                calldata: calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"```"

#: src/ch04-02-hello-account.md:66
#, fuzzy
msgid "External Functions"
msgstr "### 外部函数"

#: src/ch04-02-hello-account.md:68
#, fuzzy
msgid ""
"The account contract includes several external functions to handle the "
"validation and execution of transactions. These functions are:"
msgstr "账户合约包括几个外部函数，用于处理交易的验证和执行。这些功能包括"

#: src/ch04-02-hello-account.md:71
#, fuzzy
msgid "`__validate_deploy__`: Validates the deployment of the contract."
msgstr "__validate_deploy__`：验证合约的部署。"

#: src/ch04-02-hello-account.md:73
#, fuzzy
msgid ""
"`__validate_declare__`: Validates the declaration of transactions using the "
"account."
msgstr "__validate_declare__`：验证使用账户进行的交易声明。"

#: src/ch04-02-hello-account.md:76
#, fuzzy
msgid "`__validate__`: Validates a transaction before execution."
msgstr "__validate__`：在执行前验证事务。"

#: src/ch04-02-hello-account.md:78
#, fuzzy
msgid "`__execute__`: Executes a transaction after successful validation."
msgstr "__execute__`：验证成功后执行事务。"

#: src/ch04-02-hello-account.md:80
#, fuzzy
msgid "_validate_deploy_"
msgstr "验证部署"

#: src/ch04-02-hello-account.md:82
#, fuzzy
msgid ""
"This function is responsible for validating the deployment of the account "
"contract. It returns `starknet::VALIDATED` to confirm successful validation."
msgstr ""
"该函数负责验证账户合约的部署。它返回 `starknet::VALIDATED` 以确认验证成功。"

#: src/ch04-02-hello-account.md:95
#, fuzzy
msgid "_validate_declare_"
msgstr "验证声明"

#: src/ch04-02-hello-account.md:97
#, fuzzy
msgid ""
"This function enforces that transactions now require accounts to pay fees. It "
"returns `starknet::VALIDATED` to confirm successful validation."
msgstr ""
"该函数强制执行现在需要账户支付费用的交易。它返回 `starknet::VALIDATED` 以确认"
"验证成功。"

#: src/ch04-02-hello-account.md:107
#, fuzzy
msgid "_validate_"
msgstr "验证"

#: src/ch04-02-hello-account.md:109
#, fuzzy
msgid ""
"This function is called by the account contract upon receiving a transaction. "
"If the validation is successful, it returns `starknet::VALIDATED`."
msgstr ""
"账户合约在收到交易时会调用该函数。如果验证成功，则返回 `starknet::VALIDATED`。"

#: src/ch04-02-hello-account.md:122
#, fuzzy
msgid "_execute_"
msgstr "执行"

#: src/ch04-02-hello-account.md:124
#, fuzzy
msgid ""
"If the `__validate__` function is successful, this `__execute__` function "
"will be called. It forwards the call to the target contract using `starknet::"
"call_contract_syscall`."
msgstr ""
"如果 `__validate__`函数成功执行，这个 `__execute__`函数将被调用。它使用 "
"`starknet::call_contract_syscall` 将调用转发到目标合约。"

#: src/ch04-02-hello-account.md:142 src/ch04-03-standard-account.md:295
#, fuzzy
msgid "Declaring and Deploying the Hello World Account Contract"
msgstr "声明和部署 Hello World 账户合约"

#: src/ch04-02-hello-account.md:144
#, fuzzy
msgid ""
"The declaring and deploying process is the same as with other contracts. "
"Before declaring and deploying the Hello World account contract, you must "
"first have an account contract set up to manage the deployment process. To "
"learn more about deploying an account contract, refer to the subchapter on "
"deploying in Chapter 2 of the Book."
msgstr ""
"声明和部署流程与其他合约相同。在声明和部署 Hello World 帐户合约之前，必须先设"
"置一个帐户合约来管理部署过程。要了解有关部署账户合约的更多信息，请参阅本书第 "
"2 章中有关部署的分章。"

#: src/ch04-02-hello-account.md:150
#, fuzzy
msgid ""
"Remember to compile using `scarb build` (refer to the Scarb subchapter in "
"Chapter 2 of the Book). Then follow the steps below to declare and deploy the "
"Hello World account contract:"
msgstr ""
"请记住使用 `scarb build` 进行编译（请参阅本书第 2 章中的 Scarb 子章节）。然后"
"按照以下步骤声明并部署 Hello World 账户合约："

#: src/ch04-02-hello-account.md:154 src/ch04-03-standard-account.md:303
#, fuzzy
msgid "Export the required environment variables:"
msgstr "导出所需的环境变量："

#: src/ch04-02-hello-account.md:161 src/ch04-03-standard-account.md:310
#, fuzzy
msgid ""
"Declare the contract (since the contract is already declared, you can skip "
"this step. If you want to declare it anyway, run the following command but "
"you will receive an error):"
msgstr ""
"声明合约（因为合约已经声明，所以可以跳过这一步。如果想声明，请运行以下命令，但"
"会出现错误）："

#: src/ch04-02-hello-account.md:169
#, fuzzy
msgid ""
"The class hash is: "
"0x07e813097812d58afbb4fb015e683f2b84e4f008cbecc60fa6dece7734a2cdfe"
msgstr ""
"类散列值为： "
"0x07e813097812d58afbb4fb015e683f2b84e4f008cbecc60fa6dece7734a2cdfe"

#: src/ch04-02-hello-account.md:172 src/ch04-03-standard-account.md:321
#, fuzzy
msgid "Deploy the contract:"
msgstr ""
"智能合约拥有几个独特的特点。它们是**无权限的**，意味着任何人都可以在网络上部署"
"智能合约（当然该网络必须是去中心化区块链）。智能合约也是**透明的**；任何人都可"
"以访问智能合约所存储的数据。构成合约的代码也可以是透明的，实现了**可组合性**。"
"这使得开发者可以编写使用其他智能合约的智能合约。智能合约只能访问它们所部署的区"
"块链上的数据并与之互动。他们需要第三方工具或软件（称为 \"oracles\"）来访问外部"
"数据（例如，代币的价格）。"

#: src/ch04-02-hello-account.md:178
#, fuzzy
msgid ""
"After completing these steps, you will have successfully declared and "
"deployed the Hello World account contract on Starknet. [Here is a deployed "
"version](https://testnet.starkscan.co/"
"contract/0x01e6d7698ca76788c8f9c1091ec3d6d3f7167a9effe520402d832ca9894eba4a#overview)."
msgstr ""
"完成这些步骤后，您就成功地在Starknet声明并部署了 Hello World 账户合约。[Here "
"is a deployed version](https://testnet.starkscan.co/"
"contract/0x01e6d7698ca76788c8f9c1091ec3d6d3f7167a9effe520402d832ca9894eba4a#overview)."

#: src/ch04-02-hello-account.md:185
#, fuzzy
msgid ""
"In this subchapter, we delved into the details of a basic account contract in "
"Starknet using a \"Hello World\" example."
msgstr ""
"在本小节中，我们以 \"Hello World \"为例，详细介绍了Starknet的基本账户合约。"

#: src/ch04-02-hello-account.md:188
#, fuzzy
msgid ""
"We also outlined the steps to declare and deploy the Hello World account "
"contract on the Starknet network. The deployment process involves exporting "
"the required environment variables, declaring the contract, and deploying it "
"using the class hash."
msgstr ""
"我们还概述了在Starknet上声明和部署 Hello World 账户合约的步骤。部署过程包括导"
"出所需的环境变量、声明合约和使用类散列进行部署。"

#: src/ch04-02-hello-account.md:193
#, fuzzy
msgid ""
"As we progress in our exploration of Starknet account contracts, the next "
"subchapter will introduce a standard account contract, drawing parallels with "
"the standard account contract defined by Open Zeppelin and Starkware. This "
"will further strengthen our understanding of how account contracts operate "
"within the Starknet ecosystem."
msgstr ""
"随着我们对 Starknet 帐户合约探索的深入，下一章将介绍标准帐户合约，并与 Open "
"Zeppelin 和 Starkware 定义的标准帐户合约进行比较。这将进一步加深我们对账户合约"
"如何在Starknet生态系统中运作的理解。"

#: src/ch04-03-standard-account.md:1
#, fuzzy
msgid "Standard Account Contract"
msgstr "标准账户合约"

#: src/ch04-03-standard-account.md:8
#, fuzzy
msgid ""
"In this chapter, we build upon our exploration of account contracts in "
"Starknet by introducing a more complex account contract. This Standard "
"Account Contract includes additional features such as signature validation, "
"providing a more robust example of an account contract in Cairo language. You "
"can find the full code for this contract in the Book repository (todo: add "
"link). You can interact and compile the contract using Scarb (review the "
"Scarb subchapter in Chapter 2 of the Book for more information)."
msgstr ""
"在本章中，我们将在探索Starknet账户合约的基础上，介绍一种更复杂的账户合约。该标"
"准账户合约包含签名验证等附加功能，为Cairo语言中的账户合约提供了一个更强大的示"
"例。你可以在书库中找到该合约的完整代码（待办事项：添加链接）。您可以使用 "
"Scarb 进行交互并编译该合约（查看本书第 2 章中的 Scarb 子章节，了解更多信息）。"

#: src/ch04-03-standard-account.md:17
#, fuzzy
msgid ""
"```rust\n"
"    // Import necessary modules and traits\n"
"    use serde::Serde;\n"
"    use starknet::ContractAddress;\n"
"    use array::ArrayTrait;\n"
"    use array::SpanTrait;\n"
"    use option::OptionTrait;\n"
"\n"
"    // Define the Account contract\n"
"    #[account_contract]\n"
"    mod Account {\n"
"        use array::ArrayTrait;\n"
"        use array::SpanTrait;\n"
"        use box::BoxTrait;\n"
"        use ecdsa::check_ecdsa_signature;\n"
"        use option::OptionTrait;\n"
"        use super::Call;\n"
"        use starknet::ContractAddress;\n"
"        use zeroable::Zeroable;\n"
"        use serde::ArraySerde;\n"
"\n"
"        // Define the contract's storage variables\n"
"        struct Storage {\n"
"            public_key: felt252\n"
"        }\n"
"\n"
"        // Constructor function for initializing the contract\n"
"        #[constructor]\n"
"        fn constructor(public_key_: felt252) {\n"
"            public_key::write(public_key_);\n"
"        }\n"
"\n"
"        // Internal function to validate the transaction signature\n"
"        fn validate_transaction() -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox "
"transaction info\n"
"            let signature = tx_info.signature; // Extract signature\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // "
"Check signature length\n"
"\n"
"            // Verify ECDSA signature\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key::read(),\n"
"                    signature_r: *signature[0_u32],\n"
"                    signature_s: *signature[1_u32],\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED // Return validation status\n"
"        }\n"
"\n"
"        // Validate contract deployment\n"
"        #[external]\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, public_key_: "
"felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Validate contract declaration\n"
"        #[external]\n"
"        fn __validate_declare__(class_hash: felt252) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Validate contract execution\n"
"        #[external]\n"
"        fn __validate__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, "
"calldata: Array<felt252>\n"
"        ) -> felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // Execute a contract call\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
"            // Validate caller\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER');\n"
"\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox "
"transaction info\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only "
"single calls are supported\n"
"            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
"\n"
"            // Call the target contract\n"
"            starknet::call_contract_syscall(\n"
"                address: to, entry_point_selector: selector, calldata: "
"calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"\n"
"    // Define the Call struct\n"
"    #[derive(Drop, Serde)]\n"
"    struct Call {\n"
"        to: ContractAddress,\n"
"        selector: felt252,\n"
"        calldata: Array<felt252>\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    // 导入必要的模块和特性\n"
"    使用 serde::Serde；\n"
"    使用 starknet::ContractAddress；\n"
"    使用 array::ArrayTrait；\n"
"    使用 array::SpanTrait；\n"
"    使用 option::OptionTrait；\n"
"\n"
"    // 定义账户合约\n"
"    #[account_contract］\n"
"    mod Account {\n"
"        使用 array::ArrayTrait；\n"
"        使用 array::SpanTrait；\n"
"        使用 box::BoxTrait；\n"
"        使用 ecdsa::check_ecdsa_signature；\n"
"        使用 option::OptionTrait；\n"
"        使用 super::Call；\n"
"        使用 starknet::ContractAddress；\n"
"        使用 zeroable::Zeroable；\n"
"        使用 serde::ArraySerde；\n"
"\n"
"        // 定义合约的存储变量\n"
"        struct Storage {\n"
"            public_key: felt252\n"
"        }\n"
"\n"
"        // 用于初始化合约的构造函数\n"
"        #[构造函数］\n"
"        fn constructor(public_key_: felt252) {\n"
"            public_key::write(public_key_)；\n"
"        }\n"
"\n"
"        // 验证交易签名的内部函数\n"
"        fn validate_transaction() -&gt; felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox(); // 开箱交易信息\n"
"            let signature = tx_info.signature; // 提取签名\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // "
"检查签名长度\n"
"\n"
"            // 验证 ECDSA 签名\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash、\n"
"                    public_key: public_key::read()、\n"
"                    signature_r： *signature[0_u32]、\n"
"                    signature_s： *签名[1_u32]、\n"
"                ),\n"
"                无效签名'、\n"
"            );\n"
"\n"
"            starknet::VALIDATED // 返回验证状态\n"
"        }\n"
"\n"
"        // 验证合约部署\n"
"        #[外部］\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, public_key_: "
"felt252\n"
"        ) -&gt; felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // 验证合约声明\n"
"        #[外部］\n"
"        fn __validate_declare__(class_hash: felt252) -&gt; felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // 验证合约执行\n"
"        #[外部］\n"
"        fn __validate__(\n"
"            contract_address：contract_address: ContractAddress, "
"entry_point_selector: felt252, calldata：数组<felt252>\n"
"        ) -&gt; felt252 {\n"
"            validate_transaction()\n"
"        }\n"
"\n"
"        // 执行合约调用\n"
"        #[外部］\n"
"        #[raw_output］\n"
"        fn __execute__(mut calls: Array<Call>) -&gt; Span<felt252> {\n"
"            // 验证调用者\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER')；\n"
"\n"
"            let tx_info = starknet::get_tx_info().unbox(); // 解压缩交易信息\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION')；\n"
"\n"
"            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // 只支"
"持单次调用\n"
"            let Call{to, selector, calldata } = calls.pop_front().unwrap()；\n"
"\n"
"            // 调用目标合约\n"
"            starknet::call_contract_syscall(\n"
"                address: to, entry_point_selector: selector, calldata: "
"calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"\n"
"    // 定义调用结构\n"
"    #[派生（Drop、Serde）]\n"
"    struct Call {\n"
"        to：ContractAddress、\n"
"        selector: felt252、\n"
"        calldata：数组<felt252>\n"
"    }\n"
"```"

#: src/ch04-03-standard-account.md:120
#, fuzzy
msgid "Grasping ECDSA Signature"
msgstr "掌握 ECDSA 签名"

#: src/ch04-03-standard-account.md:122
#, fuzzy
msgid ""
"Elliptic Curve Digital Signature Algorithm (ECDSA) is a cryptographic "
"protocol extensively utilized across various blockchains to ensure data "
"integrity and verify the sender’s authenticity. As a variant of the Digital "
"Signature Algorithm (DSA), ECDSA leverages elliptic curve cryptography, "
"offering superior security with shorter keys than the traditional DSA."
msgstr ""
"椭圆曲线数字签名算法（ECDSA）是一种广泛应用于各种区块链的加密协议，可确保数据"
"完整性并验证发送者的真实性。作为数字签名算法（DSA）的一种变体，ECDSA 利用椭圆"
"曲线加密技术，与传统的 DSA 相比，能以更短的密钥提供更高的安全性。"

#: src/ch04-03-standard-account.md:129
#, fuzzy
msgid ""
"An ECDSA signature comprises two components, commonly referred to as _r_ and "
"_s_. These two values, generated using the signer’s private key and the hash "
"of the message (or transaction) being signed, collectively form the signature "
"for a given input."
msgstr ""
"ECDSA 签名由两个部分组成，通常称为 _r_ 和 _s_。这两个值使用签名者的私人密钥和"
"被签名信息（或交易）的哈希值生成，共同构成给定输入的签名。"

#: src/ch04-03-standard-account.md:134
#, fuzzy
msgid "Deciphering signature_r and signature_s"
msgstr "破译签名_r和签名_s"

#: src/ch04-03-standard-account.md:136
#, fuzzy
msgid ""
"Within the context of the Standard Account Contract, _signature_r_ and "
"_signature_s_ represent the two constituents of the ECDSA signature. These "
"are utilized in the _check_ecdsa_signature_ function to authenticate the "
"transaction’s legitimacy."
msgstr ""
"在标准账户合约中，_signature_r_ 和 _signature_s_ 代表 ECDSA 签名的两个组成部"
"分。它们在_check_ecdsa_signature_函数中用于验证交易的合法性。"

#: src/ch04-03-standard-account.md:141
#, fuzzy
msgid ""
"`signature_r (r)`: A random number generated during the signing process, "
"unique for each signature. Reusing _r_ across different messages may lead to "
"private key exposure."
msgstr ""
"`signature_r (r)`：签名过程中生成的随机数，每个签名都是唯一的。在不同信息中重"
"复使用 _r_ 可能会导致私钥泄露。"

#: src/ch04-03-standard-account.md:145
#, fuzzy
msgid ""
"`signature_s (s)`: This is computed using _r_, the private key, and the hash "
"of the message. Like _r_, _s_ is also unique for each signature."
msgstr ""
"signature_s (s)`：使用 _r_、私钥和信息的哈希值计算得出。与 _r_ 一样，每个签名"
"的 _s_ 也是唯一的。"

#: src/ch04-03-standard-account.md:149
#, fuzzy
msgid ""
"The function _check_ecdsa_signature_ takes these two values, the public key "
"of the signer, and the hash of the message to authenticate the signature. A "
"valid signature indicates that the message was indeed signed by the private "
"key owner and remains unaltered."
msgstr ""
"函数 _check_ecdsa_signature_ 使用这两个值、签名者的公钥和信息的哈希值来验证签"
"名。有效的签名表示信息确实由私钥所有者签署，且未被篡改。"

#: src/ch04-03-standard-account.md:166
#, fuzzy
msgid ""
"The above code snippet employs _check_ecdsa_signature_ function to assert the "
"legitimacy of the transaction signature. If the signature is not valid, the "
"assertion fails, returning _INVALID_SIGNATURE_."
msgstr ""
"上述代码段使用 _check_ecdsa_signature_ 函数断言交易签名的合法性。如果签名无"
"效，则断言失败，返回 _INVALID_SIGNATURE_。"

#: src/ch04-03-standard-account.md:170
#, fuzzy
msgid "Contract Anatomy"
msgstr "合约剖析"

#: src/ch04-03-standard-account.md:172
msgid "Storage"
msgstr "存储"

#: src/ch04-03-standard-account.md:174
#, fuzzy
msgid ""
"In the standard account contract, we declare a single storage variable: "
"_public_key_. This assists in transaction signature validation. The public "
"key, stored as a _felt252_ (a 252-bit unsigned integer), is written to the "
"storage in the constructor function and is accessed from the storage in the "
"_validate_transaction_ function."
msgstr ""
"在标准账户合约中，我们声明了一个存储变量：_public_key_。这有助于交易签名验证。"
"公钥存储为 _felt252_（252 位无符号整数），在构造函数中写入存储区，在"
"_validate_transaction_函数中从存储区访问。"

#: src/ch04-03-standard-account.md:186
#, fuzzy
msgid "Constructor"
msgstr "构造函数"

#: src/ch04-03-standard-account.md:188
#, fuzzy
msgid ""
"The constructor function serves to initialize the contract, storing the "
"supplied public key in the contract’s storage."
msgstr "构造函数用于初始化合约，将提供的公钥存储在合约的存储空间中。"

#: src/ch04-03-standard-account.md:198
#, fuzzy
msgid "`validate_transaction`"
msgstr "验证交易"

#: src/ch04-03-standard-account.md:200
#, fuzzy
msgid ""
"This internal function validates the transaction signature. It retrieves the "
"signature from the transaction info, checks its length, and verifies the "
"ECDSA signature. If the signature is legitimate, it returns starknet::"
"VALIDATED, otherwise an error. This function is invoked by "
"**validate_deploy**, **validate_declare**, and **validate** functions."
msgstr ""
"该内部函数用于验证交易签名。它从事务信息中获取签名，检查其长度并验证 ECDSA 签"
"名。如果签名合法，则返回 starknet::VALIDATED，否则返回错误信息。该函数由 "
"**validate_deploy**、**validate_declare** 和 **validate**函数调用。"

#: src/ch04-03-standard-account.md:206
#, fuzzy
msgid ""
"The inclusion of this function is optional. If transaction signature "
"validation is not required, it can be omitted. However, its inclusion in your "
"account contract is advised to ensure transaction validity and to facilitate "
"its reuse in all three validation functions."
msgstr ""
"是否包含该功能是可选的。如果不需要交易签名验证，则可以省略。不过，建议在账户合"
"约中加入该功能，以确保交易的有效性，并便于在所有三个验证功能中重复使用。"

#: src/ch04-03-standard-account.md:211
#, fuzzy
msgid ""
"```rust\n"
"    fn validate_transaction() -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox "
"transaction info\n"
"            let signature = tx_info.signature; // Extract signature\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // "
"Check signature length\n"
"\n"
"            // Verify ECDSA signature\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key::read(),\n"
"                    signature_r: *signature[0_u32],\n"
"                    signature_s: *signature[1_u32],\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED // Return validation status\n"
"        }\n"
"```"
msgstr ""
"信任\n"
"    fn validate_transaction() -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox(); // 解压缩交易信息\n"
"            let signature = tx_info.signature; // 提取签名\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH'); // "
"检查签名长度\n"
"\n"
"            // 验证 ECDSA 签名\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash、\n"
"                    public_key: public_key::read()、\n"
"                    signature_r： *signature[0_u32]、\n"
"                    signature_s： *签名[1_u32]、\n"
"                ),\n"
"                无效签名'、\n"
"            );\n"
"\n"
"            starknet::VALIDATED // 返回验证状态\n"
"        }\n"
"```"

#: src/ch04-03-standard-account.md:232
#, fuzzy
msgid "Call Struct"
msgstr "呼叫结构"

#: src/ch04-03-standard-account.md:234
#, fuzzy
msgid ""
"The Call struct outlines the parameters required for a contract call. These "
"parameters comprise the target contract address (to), the function to be "
"called (selector), and the function’s arguments (calldata). The Call struct "
"is utilized in the _execute_ function."
msgstr ""
"调用结构概述了合约调用所需的参数。这些参数包括目标合约地址（to）、要调用的函数"
"（selector）和函数参数（calldata）。Call 结构在 _execute_ 函数中使用。"

#: src/ch04-03-standard-account.md:248
msgid "execute"
msgstr "执行"

#: src/ch04-03-standard-account.md:250
#, fuzzy
msgid ""
"This external function triggers a transaction post successful validation. It "
"ensures the caller’s validity, checks for a non-zero transaction version, and "
"supports only single calls. Post validation, it forwards the call to the "
"target contract. The contract creator can incorporate multiple calls to "
"different contracts or the same contract (multicall) within this function. "
"The function returns the output from the target contract."
msgstr ""
"此外部函数在验证成功后触发事务。它确保调用者的有效性，检查事务版本是否为零，并"
"且只支持单次调用。验证后，它会将调用转发到目标合约。合约创建者可以在此函数中包"
"含对不同合约或同一合约的多次调用（多调用）。该函数返回目标合约的输出。"

#: src/ch04-03-standard-account.md:258
#, fuzzy
msgid ""
"```rust\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(mut calls: Array<Call>) -> Span<felt252> {\n"
"            // Validate caller\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER');\n"
"\n"
"            let tx_info = starknet::get_tx_info().unbox(); // Unbox "
"transaction info\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // Only "
"single calls are supported\n"
"            let Call{to, selector, calldata } = calls.pop_front().unwrap();\n"
"\n"
"            // Call the target contract\n"
"            starknet::call_contract_syscall(\n"
"                address: to, entry_point_selector: selector, calldata: "
"calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"```"
msgstr ""
"```信任\n"
"        #[外部]\n"
"        #[raw_output]\n"
"        fn __execute__(mut calls: Array<Call>) -&gt; Span<felt252> {\n"
"            // 验证调用者\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER')；\n"
"\n"
"            let tx_info = starknet::get_tx_info().unbox(); // 解压缩交易信息\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION')；\n"
"\n"
"            assert(calls.len() == 1_u32, 'MULTI_CALL_NOT_SUPPORTED'); // 只支"
"持单次调用\n"
"            let Call{to, selector, calldata } = calls.pop_front().unwrap()；\n"
"\n"
"            // 调用目标合约\n"
"            starknet::call_contract_syscall(\n"
"                address: to, entry_point_selector: selector, calldata: "
"calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"```"

#: src/ch04-03-standard-account.md:278
#, fuzzy
msgid "Improvements to the Standard Account Contract"
msgstr "改进标准账户合约"

#: src/ch04-03-standard-account.md:280
#, fuzzy
msgid ""
"The implementation of the Standard Account Contract has a few limitations:"
msgstr "标准账户合约的实施有一些局限性："

#: src/ch04-03-standard-account.md:283
#, fuzzy
msgid ""
"It currently supports only single calls. We could support multicalls to "
"improve the flexibility and utility of the contract."
msgstr "它目前只支持单次呼叫。我们可以支持多调用，以提高合约的灵活性和实用性。"

#: src/ch04-03-standard-account.md:286
#, fuzzy
msgid ""
"The ECDSA signature algorithm, while secure, can be computationally "
"intensive. Future versions could explore using more efficient signature "
"algorithms, such as Schnorr or BLS. Or quantum-resistant signature "
"algorithms, such as the STARKs."
msgstr ""
"ECDSA 签名算法虽然安全，但计算量很大。未来版本可以探索使用更高效的签名算法，"
"如 Schnorr 或 BLS。或者抗量子的签名算法，如 STARKs。"

#: src/ch04-03-standard-account.md:291
#, fuzzy
msgid ""
"Despite these limitations, the Standard Account Contract provides a robust "
"and secure foundation for creating and interacting with smart contracts on "
"Starknet."
msgstr ""
"尽管存在这些限制，但标准账户合约为在Starknet创建智能合约并与之交互提供了一个强"
"大而安全的基础。"

#: src/ch04-03-standard-account.md:297
#, fuzzy
msgid ""
"This time we have a constructor function that takes the public key as an "
"argument. We need to generate a private key with the corresponding public key."
msgstr ""
"这一次，我们有了一个以公钥为参数的构造函数。我们需要用相应的公钥生成私钥。"

#: src/ch04-03-standard-account.md:301
#, fuzzy
msgid "TODO: add section on how to generate a private key and public key."
msgstr "TODO: 添加关于如何生成私钥和公钥的部分。"

#: src/ch04-03-standard-account.md:318
#, fuzzy
msgid ""
"The class hash is: "
"0x05501f7806d3d11cab101e19001e409dd4760200c2da2fe03761750f66e4a5e1"
msgstr ""
"类散列值为： "
"0x05501f7806d3d11cab101e19001e409dd4760200c2da2fe03761750f66e4a5e1"

#: src/ch04-03-standard-account.md:323
#, fuzzy
msgid "TODO: add section on how to deploy the contract."
msgstr "待办事项：添加有关如何部署合约的部分。"

#: src/ch04-03-standard-account.md:325
#, fuzzy
msgid ""
"Elliptic Curve Digital Signature Algorithm (ECDSA) is a popular choice for "
"ensuring data integrity and sender authenticity in blockchain networks, but "
"it’s not the only option. Other alternatives include:"
msgstr ""
"椭圆曲线数字签名算法（ECDSA）是确保区块链网络中数据完整性和发送者真实性的常用"
"选择，但它并不是唯一的选择。其他替代方案包括"

#: src/ch04-03-standard-account.md:329
#, fuzzy
msgid ""
"EdDSA (Edwards-curve Digital Signature Algorithm): EdDSA is another form of "
"elliptic curve cryptography that is designed to be faster and more secure "
"than ECDSA. EdDSA uses twisted Edwards curves, which have strong security "
"properties and allow for more efficient computations. An example of EdDSA in "
"use is Monero."
msgstr ""
"EdDSA（爱德华兹曲线数字签名算法）：EdDSA 是椭圆曲线加密算法的另一种形式，其设"
"计比 ECDSA 更快、更安全。EdDSA 使用扭曲的爱德华曲线，这种曲线具有很强的安全性"
"能，而且计算效率更高。使用 EdDSA 的一个例子是 Monero。"

#: src/ch04-03-standard-account.md:335
#, fuzzy
msgid ""
"Schnorr Signatures: Schnorr signatures offer a level of security similar to "
"ECDSA but with shorter signatures. They have the additional property of being "
"linear, which allows for signature aggregation and multi-signatures. This can "
"lead to increased efficiency and privacy. Bitcoin developers have proposed "
"adding Schnorr signatures to the Bitcoin protocol with the Taproot upgrade."
msgstr ""
"Schnorr 签名Schnorr 签名的安全级别类似于 ECDSA，但签名更短。它们还具有线性特"
"性，可以进行签名聚合和多重签名。这可以提高效率和隐私保护。比特币开发者已提议"
"在 Taproot 升级版中将 Schnorr 签名添加到比特币协议中。"

#: src/ch04-03-standard-account.md:342
#, fuzzy
msgid ""
"RSA (Rivest–Shamir–Adleman): RSA is an older cryptographic algorithm that is "
"widely used for secure data transmission. However, RSA requires larger key "
"sizes for equivalent security levels, making it less efficient than elliptic "
"curve techniques. RSA is not commonly used in modern blockchain systems, but "
"it is still used in many traditional secure communication protocols."
msgstr ""
"RSA（Rivest-Shamir-Adleman）：RSA 是一种古老的加密算法，广泛用于安全数据传输。"
"不过，RSA 需要更大的密钥大小才能达到同等的安全级别，因此其效率低于椭圆曲线技"
"术。RSA 在现代区块链系统中并不常用，但在许多传统安全通信协议中仍有使用。"

#: src/ch04-03-standard-account.md:349
#, fuzzy
msgid ""
"BLS (Boneh-Lynn-Shacham) Signatures: BLS signatures, like Schnorr, allow for "
"signature aggregation, making them useful in systems that require a large "
"number of signatures. This property makes BLS signatures particularly useful "
"for consensus algorithms in distributed systems and blockchains, such as "
"Ethereum 2.0."
msgstr ""
"BLS（Boneh-Lynn-Shacham）签名：BLS 签名与 Schnorr 签名一样，允许签名聚合，因此"
"在需要大量签名的系统中非常有用。这一特性使得 BLS 签名特别适用于分布式系统和区"
"块链（如以太坊 2.0）中的共识算法。"

#: src/ch04-03-standard-account.md:355
#, fuzzy
msgid ""
"Post-Quantum Cryptography: With the advent of quantum computing, researchers "
"are developing new cryptographic algorithms that are resistant to quantum "
"attacks. One example are the STARKs used in Starknet."
msgstr ""
"后量子密码学：随着量子计算的出现，研究人员正在开发能够抵御量子攻击的新型加密算"
"法。Starknet中使用的 STARK 就是一个例子。"

#: src/ch04-03-standard-account.md:360
#, fuzzy
msgid ""
"Each of these alternatives has its strengths and weaknesses in terms of "
"security, efficiency, complexity, and mathematical properties."
msgstr "这些替代方案在安全性、效率、复杂性和数学特性方面各有优缺点。"

#: src/ch04-03-standard-account.md:365
#, fuzzy
msgid ""
"In this chapter, we expanded on our understanding of account contracts in "
"Starknet by examining a more complex \"Standard Account Contract\". We dove "
"into the various components of the contract and learned how they work "
"together to validate and execute transactions."
msgstr ""
"在本章中，我们通过研究更复杂的 \"标准账户合约\"，加深了对Starknet账户合约的理"
"解。我们深入研究了合约的各个组成部分，并了解了它们如何共同验证和执行交易。"

#: src/ch04-04-examples.md:3
#, fuzzy
msgid ""
"Here, we will explore numerous examples, elucidating the principles and "
"techniques to effectively design and implement Account contracts."
msgstr "在此，我们将探讨大量实例，阐明有效设计和实施账户合约的原则和技巧。"

#: src/ch04-04-examples.md:6
#, fuzzy
msgid ""
"Before delving into the examples, we would like to issue a disclaimer: the "
"contracts discussed in this chapter are for illustrative and educational "
"purposes, and they have not undergone formal auditing. This signifies that, "
"while we strive to provide accurate and informative content, the "
"implementation of these contracts in a live environment should be approached "
"with due diligence. We encourage users to thoroughly test and validate these "
"contracts before their deployment on the mainnet."
msgstr ""
"在深入探讨示例之前，我们想先声明：本章讨论的合约仅用于说明和教育目的，并未经过"
"正式审核。这意味着，尽管我们努力提供准确、翔实的内容，但在实际环境中实施这些合"
"约时，仍需慎之又慎。我们鼓励用户在将这些合约部署到主网之前进行全面测试和验证。"

#: src/ch04-04-examples.md:15
#, fuzzy
msgid ""
"The goal of this chapter is not only to furnish a library of contract "
"examples but also to foster collaboration and knowledge sharing among the "
"Starknet community. We believe that the exchange of ideas and constructive "
"feedback is instrumental in advancing our collective understanding and "
"expertise."
msgstr ""
"本章的目的不仅是提供一个合约示例库，还在于促进Starknet社区之间的合作和知识共"
"享。我们相信，思想交流和建设性反馈有助于增进我们的集体理解和专业知识。"

#: src/ch04-04-examples.md:21
#, fuzzy
msgid ""
"If you’ve developed or come across an innovative contract that could serve as "
"a valuable learning resource for others, we invite you to contribute. Here "
"are a few guidelines for your contribution:"
msgstr ""
"如果您已经开发出或遇到了一份创新合约，可以为他人提供宝贵的学习资源，我们诚邀您"
"投稿。以下是一些供您投稿的指导原则："

#: src/ch04-04-examples.md:25
#, fuzzy
msgid ""
"**Open a PR:** To submit a contract example or suggest changes to existing "
"ones, simply open a Pull Request. Ensure that your PR contains a thorough "
"explanation of the contract, its use cases, and its functionality."
msgstr ""
"**打开 PR：** 要提交合约示例或对现有合约示例提出修改建议，只需打开一个拉动请"
"求。确保您的 PR 包含对合约、用例及其功能的详尽解释。"

#: src/ch04-04-examples.md:30
#, fuzzy
msgid ""
"**Code Standards:** Please ensure that the submitted code is well-documented "
"and adheres to the standard code conventions of Starknet. This will "
"facilitate the review process and enhance the readability and "
"comprehensibility of the contract."
msgstr ""
"**代码标准：** 请确保所提交的代码文档齐全，并遵守Starknet的标准代码惯例。这将"
"有助于审查过程，并提高合约的可读性和可理解性。"

#: src/ch04-04-examples.md:35
#, fuzzy
msgid ""
"**Detailed Explanation:** Accompany your code with a detailed explanation of "
"the contract logic. Wherever possible, use diagrams, flowcharts, or "
"pseudocode to illustrate complex mechanisms or workflows."
msgstr ""
"**详细解释：** 在编写代码的同时，详细解释合约逻辑。尽可能使用图表、流程图或伪"
"代码来说明复杂的机制或工作流程。"

#: src/ch04-04-examples.md:40
#, fuzzy
msgid ""
"As we expand this repertoire of contract examples, we hope to equip the "
"Starknet community with a robust toolset and inspire further exploration and "
"innovation in the realm of custom account contracts."
msgstr ""
"随着合约示例库的不断扩大，我们希望能为Starknet社区提供一个强大的工具集，并在自"
"定义账户合约领域激发进一步的探索和创新。"

#: src/ch04-04-01-multicaller.md:1
#, fuzzy
msgid "MultiCaller Account"
msgstr "多重呼叫器账户"

#: src/ch04-04-01-multicaller.md:8
#, fuzzy
msgid ""
"[Multicall](https://github.com/joshstevens19/ethereum-multicall#readme) is a "
"powerful technique that allows multiple constant smart contract function "
"calls to be aggregated into a single call, resulting in a consolidated "
"output. With Starknet’s account abstraction feature, multicalls can be "
"seamlessly integrated into account contracts."
msgstr ""
"[Multicall](https://github.com/joshstevens19/ethereum-multicall#readme)是一种"
"强大的技术，可将多个恒定的智能合约函数调用聚合为一个调用，从而实现合并输出。借"
"助Starknet的账户抽象功能，多调用可无缝集成到账户合约中。"

#: src/ch04-04-01-multicaller.md:14
#, fuzzy
msgid "Why Multicalls?"
msgstr "为什么选择 Multicalls？"

#: src/ch04-04-01-multicaller.md:16
#, fuzzy
msgid "Multicalls come handy in several scenarios. Here are some examples:"
msgstr "在多种情况下，Multicalls 都能派上用场。下面是一些例子："

#: src/ch04-04-01-multicaller.md:18
#, fuzzy
msgid ""
"**Token Swapping on Decentralized Exchanges**: In a typical token swap "
"operation on a decentralized exchange (DEX), you first need to approve the "
"spending of the tokens and then initiate the swap. Executing these operations "
"separately could be cumbersome from a user experience perspective. With "
"multicall, these calls can be combined into a single transaction, simplifying "
"the user’s task."
msgstr ""
"**去中心化交易所的代币交换**：在去中心化交易所（DEX）上进行典型的代币交换操作"
"时，首先需要批准代币的支出，然后启动交换。从用户体验的角度来看，分别执行这些操"
"作可能会很麻烦。有了多调用功能，这些调用可以合并为一个交易，从而简化了用户的任"
"务。"

#: src/ch04-04-01-multicaller.md:25
#, fuzzy
msgid ""
"**Fetching Blockchain Data**: When you want to query the prices of two "
"different tokens from the blockchain, it’s beneficial to have them both come "
"from the same block for consistency. Multicall returns the latest block "
"number along with the aggregated results, providing this consistency."
msgstr ""
"**获取区块链数据**：当您想从区块链中查询两种不同代币的价格时，为了保持一致性，"
"最好让它们都来自同一个区块。Multicall 返回最新的区块编号以及汇总结果，从而提供"
"了这种一致性。"

#: src/ch04-04-01-multicaller.md:31
#, fuzzy
msgid ""
"The benefits of multicall transactions can be realized more in the context of "
"account abstraction."
msgstr "在账户抽象化的背景下，多呼叫交易的优势可以得到更多体现。"

#: src/ch04-04-01-multicaller.md:34
#, fuzzy
msgid "Multicall Functionality in Account Contracts"
msgstr "账户合约中的多方通话功能"

#: src/ch04-04-01-multicaller.md:36
#, fuzzy
msgid ""
"To facilitate multicalls, we can introduce specific functions in the account "
"contract. Here are two core functions:"
msgstr "为了方便多账户，我们可以在账户合约中引入特定功能。以下是两个核心功能："

#: src/ch04-04-01-multicaller.md:39
#, fuzzy
msgid "`_execute_calls` Function"
msgstr "执行调用 \"函数"

#: src/ch04-04-01-multicaller.md:41
#, fuzzy
msgid ""
"The `_execute_calls` function is responsible for executing the multicalls. It "
"iterates over an array of calls, executes them, and aggregates the results."
msgstr "执行调用 \"函数负责执行多调用。它遍历调用数组，执行这些调用并汇总结果。"

#: src/ch04-04-01-multicaller.md:60
#, fuzzy
msgid ""
"Apart from the traditional **`execute`** function, adding the "
"**`_execute_calls`** function to your account contract can ensure that you "
"can make a multicall using your smart contract account."
msgstr ""
"除了传统的**`execute`**函数外，在账户合约中添加**`_execute_calls`**函数可确保"
"您使用智能合约账户进行多方调用。"

#: src/ch04-04-01-multicaller.md:64
#, fuzzy
msgid ""
"The above code is a simple example snippet where the \\*\\*\"return "
"_execute_calls(calls, res);\"_ statement makes recursive calls to the "
"**`_execute_calls`** function thereby bundling the calls together. The final "
"result will be aggregated and returned in the \\*\\*\\*res\\*\\*\\* variable."
msgstr ""
"上面的代码是一个简单的示例片段，\"return _execute_calls(calls, res);\"_语句对"
"**`_execute_calls`**函数进行递归调用，从而将调用捆绑在一起。最终结果将被汇总并"
"返回到变量中。"

#: src/ch04-04-01-multicaller.md:70
#, fuzzy
msgid "`_call_contract` Function"
msgstr "调用合约功能"

#: src/ch04-04-01-multicaller.md:72
#, fuzzy
msgid ""
"The `_call_contract` function is a helper function used to make individual "
"contract calls."
msgstr "函数 `_call_contract`是一个辅助函数，用于调用单个合约。"

#: src/ch04-04-01-multicaller.md:83
msgid "Considerations"
msgstr "注意事项"

#: src/ch04-04-01-multicaller.md:85
#, fuzzy
msgid ""
"While multicall provides significant benefits in terms of UX and data "
"consistency, it’s important to note that it may not significantly reduce gas "
"fees compared to individual calls. However, the primary advantage of using "
"multicall is that it ensures results are derived from the same block, "
"providing a much-improved user experience."
msgstr ""
"虽然多方通话在用户体验和数据一致性方面具有显著优势，但需要注意的是，与单个通话"
"相比，多方通话可能无法显著降低煤气费。不过，使用多方通话的主要优势在于它能确保"
"结果来自同一区块，从而大大改善用户体验。"

#: src/ch04-04-02-multisig.md:1
#, fuzzy
msgid "Multi-Signature Accounts"
msgstr "多重签名账户"

#: src/ch04-04-02-multisig.md:8
#, fuzzy
msgid ""
"Multisignature (multisig) technology is an integral part of the modern "
"blockchain landscape. It enhances security by requiring multiple signatures "
"to confirm a transaction, hence reducing the risk of fraudulent transactions "
"and increasing control over asset management."
msgstr ""
"多重签名（multisig）技术是现代区块链技术不可或缺的一部分。它需要多个签名来确认"
"交易，从而提高了安全性，降低了欺诈交易的风险，加强了对资产管理的控制。"

#: src/ch04-04-02-multisig.md:13
#, fuzzy
msgid ""
"In Starknet, the concept of multisig accounts is abstracted at the protocol "
"level, allowing developers to implement custom account contracts that embody "
"this concept. In this chapter, we’ll delve into the workings of a multisig "
"account and see how it’s created in Starknet using an account contract."
msgstr ""
"在Starknet中，多重签名账户的概念在协议层面上被抽象化，允许开发人员实现体现这一"
"概念的自定义账户合约。在本章中，我们将深入探讨多用户账户的工作原理，并了解如何"
"在Starknet中使用账户合约创建多用户账户。"

#: src/ch04-04-02-multisig.md:19
#, fuzzy
msgid "What is a Multisig Account?"
msgstr "什么是 Multisig 账户？"

#: src/ch04-04-02-multisig.md:21
#, fuzzy
msgid ""
"A multisig account is an account that requires more than one signature to "
"authorize transactions. This significantly enhances security, requiring "
"multiple entities' consent to transact funds or perform critical actions."
msgstr ""
"多签名账户是指需要一个以上签名才能授权交易的账户。这大大提高了安全性，因为交易"
"资金或执行关键操作需要多个实体的同意。"

#: src/ch04-04-02-multisig.md:26
#, fuzzy
msgid "Key specifications of a multisig account include:"
msgstr "多标识账户的主要规格包括"

#: src/ch04-04-02-multisig.md:28
#, fuzzy
msgid "Public keys that form the account"
msgstr "组成账户的公钥"

#: src/ch04-04-02-multisig.md:30
#, fuzzy
msgid "Threshold number of signatures required"
msgstr "所需的签名阈值数"

#: src/ch04-04-02-multisig.md:32
#, fuzzy
msgid ""
"A transaction signed by a multisig account must be individually signed by the "
"different keys specified for the account. If fewer than the threshold number "
"of signatures needed are present, the resultant multisignature is considered "
"invalid."
msgstr ""
"多签名账户签署的交易必须由该账户指定的不同密钥分别签署。如果存在的签名少于所需"
"的阈值数，所产生的多重签名将被视为无效。"

#: src/ch04-04-02-multisig.md:37
#, fuzzy
msgid ""
"In Starknet, accounts are abstractions provided at the protocol level. "
"Therefore, to create a multisig account, one needs to code the logic into an "
"account contract and deploy it."
msgstr ""
"在Starknet，账户是在协议层面提供的抽象概念。因此，要创建一个多标识账户，需要将"
"逻辑编码到账户合约中并进行部署。"

#: src/ch04-04-02-multisig.md:41
#, fuzzy
msgid ""
"The contract below serves as an example of a multisig account contract. When "
"deployed, it can create a native multisig account using the concept of "
"account abstraction. Please note that this is a simplified example and lacks "
"comprehensive checks and validations found in a production-grade multisig "
"contract."
msgstr ""
"下面的合约是多用户账户合约的一个示例。部署后，它可以使用账户抽象概念创建本地多"
"重身份验证账户。请注意，这只是一个简化示例，缺乏生产级多重身份验证合约中的全面"
"检查和验证。"

#: src/ch04-04-02-multisig.md:47
#, fuzzy
msgid "Multisig Account Contract"
msgstr "Multisig 账户合约"

#: src/ch04-04-02-multisig.md:49
#, fuzzy
msgid "This is the Rust code for a multisig account contract:"
msgstr "这是多 ID 账户合约的 Rust 代码："

#: src/ch04-04-02-multisig.md:51
#, fuzzy
msgid ""
"```rust\n"
"    #[account_contract]\n"
"    mod MultisigAccount {\n"
"        use ecdsa::check_ecdsa_signature;\n"
"        use starknet::ContractAddress;\n"
"        use zeroable::Zeroable;\n"
"        use array::ArrayTrait;\n"
"        use starknet::get_caller_address;\n"
"        use box::BoxTrait;\n"
"        use array::SpanTrait;\n"
"\n"
"        struct Storage {\n"
"            index_to_owner: LegacyMap::<u32, felt252>,\n"
"            owner_to_index: LegacyMap::<felt252, u32>,\n"
"            num_owners: usize,\n"
"            threshold: usize,\n"
"            curr_tx_index: felt252,\n"
"            //Mapping between tx_index and num of confirmations\n"
"            tx_confirms: LegacyMap<felt252, usize>,\n"
"            //Mapping between tx_index and its execution state\n"
"            tx_is_executed: LegacyMap<felt252, bool>,\n"
"            //Mapping between a transaction index and its hash\n"
"            transactions: LegacyMap<felt252, felt252>,\n"
"            has_confirmed: LegacyMap::<(ContractAddress, felt252), bool>,\n"
"        }\n"
"\n"
"        #[constructor]\n"
"        fn constructor(public_keys: Array::<felt252>, _threshold: usize) {\n"
"            assert(public_keys.len() <= 3_usize, 'public_keys.len <= 3');\n"
"            num_owners::write(public_keys.len());\n"
"            threshold::write(_threshold);\n"
"            _set_owners(public_keys.len(), public_keys);\n"
"        }\n"
"\n"
"        //GETTERS\n"
"        //Get number of confirmations for a given transaction index\n"
"        #[view]\n"
"        fn get_confirmations(tx_index : felt252) -> usize {\n"
"            tx_confirms::read(tx_index)\n"
"        }\n"
"\n"
"        //Get the number of owners of this account\n"
"        #[view]\n"
"        fn get_num_owners() -> usize {\n"
"            num_owners::read()\n"
"        }\n"
"\n"
"\n"
"        //Get the public key of the owners\n"
"        //TODO - Recursively add the owners into an array and return, maybe "
"wait for loops to be enabled\n"
"\n"
"\n"
"        //EXTERNAL FUNCTIONS\n"
"\n"
"        #[external]\n"
"        fn submit_tx(public_key: felt252) {\n"
"\n"
"            //Need to check if caller is one of the owners.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"            let caller = get_caller_address();\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"            //Updating the transaction index\n"
"            let tx_index = curr_tx_index::read();\n"
"\n"
"            //`true` if a signature is valid and `false` otherwise.\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            transactions::write(tx_index, tx_info.transaction_hash);\n"
"            curr_tx_index::write(tx_index + 1);\n"
"\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
"\n"
"            let transaction_hash = transactions::read(tx_index);\n"
"            //TBD: Assert that tx_hash is not null\n"
"\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let executed = tx_is_executed::read(tx_index);\n"
"\n"
"            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
"\n"
"            let caller = get_caller_address();\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"\n"
"             assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            let confirmed = has_confirmed::read((caller, tx_index));\n"
"\n"
"            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
"            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
"            has_confirmed::write((caller, tx_index), true);\n"
"\n"
"\n"
"        }\n"
"\n"
"        //An example function to validate that there are at least two "
"signatures\n"
"        fn validate_transaction(public_key: felt252) -> felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"            let caller = get_caller_address();\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"            //`true` if a signature is valid and `false` otherwise.\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            starknet::VALIDATED\n"
"        }\n"
"\n"
"        //INTERNAL FUNCTION\n"
"        //Function to add the public keys of the multisig in permanent "
"storage\n"
"        fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
"            if owners_len == 0_usize {\n"
"            }\n"
"\n"
"            index_to_owner::write(owners_len, *public_keys.at(owners_len - "
"1_usize));\n"
"            owner_to_index::write(*public_keys.at(owners_len - 1_usize), "
"owners_len);\n"
"            _set_owners(owners_len - 1_u32, public_keys);\n"
"        }\n"
"\n"
"\n"
"        #[external]\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, public_key_: "
"felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn __validate_declare__(class_hash: felt252, public_key_: felt252) -> "
"felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        fn __validate__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, "
"calldata: Array::<felt252>, public_key_: felt252\n"
"        ) -> felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, "
"calldata: Array::<felt252>,\n"
"            tx_index: felt252\n"
"        ) -> Span::<felt252> {\n"
"            // Validate caller.\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER');\n"
"\n"
"            // Check the tx version here, since version 0 transaction skip "
"the __validate__ function.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            //Multisig check here\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let owners_len = num_owners::read();\n"
"            //Subtracting one for the submitter\n"
"            let required_confirmations = threshold::read() - 1_usize;\n"
"            assert(num_confirmations >= required_confirmations, "
"'MINIMUM_50%_CONFIRMATIONS');\n"
"\n"
"            tx_is_executed::write(tx_index, true);\n"
"\n"
"            starknet::call_contract_syscall(\n"
"                contract_address, entry_point_selector, calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"```"
msgstr ""
"```信任\n"
"    #[account_contract]\n"
"    mod MultisigAccount {\n"
"        使用 ecdsa::check_ecdsa_signature；\n"
"        使用 starknet::ContractAddress；\n"
"        使用 zeroable::Zeroable；\n"
"        使用 array::ArrayTrait；\n"
"        使用 starknet::get_caller_address；\n"
"        使用 box::BoxTrait；\n"
"        使用 array::SpanTrait；\n"
"\n"
"        struct Storage {\n"
"            index_too_owner: LegacyMap::<u32, felt252> 、\n"
"            owner_too_index：legacyMap::<felt252, u32> 、\n"
"            num_owners: usize、\n"
"            threshold: usize、\n"
"            curr_tx_index: felt252、\n"
"            //tx_index 与确认数之间的映射\n"
"            tx_confirms：LegacyMap<felt252, usize> 、\n"
"            //tx_index 与执行状态之间的映射\n"
"            tx_is_executed：LegacyMap<felt252, bool> 、\n"
"            //事务索引与其哈希值之间的映射\n"
"            事务：LegacyMap<felt252, felt252> 、\n"
"            has_confirmed：LegacyMap::<(ContractAddress, felt252), bool> 、\n"
"        }\n"
"\n"
"        #[构造函数］\n"
"        fn constructor(public_keys: Array::<felt252>, _threshold: usize) {\n"
"            assert(public_keys.len() &lt;= 3_usize, 'public_keys.len &lt;= "
"3')；\n"
"            num_owners::write(public_keys.len())；\n"
"            阈值::write(_threshold)；\n"
"            _set_owners(public_keys.len(),public_keys)；\n"
"        }\n"
"\n"
"        //GETTERS\n"
"        //获取给定交易索引的确认次数\n"
"        #[view］\n"
"        fn get_confirmations(tx_index : felt252) -&gt; usize {\n"
"            tx_confirms::read(tx_index)\n"
"        }\n"
"\n"
"        //获取此账户的所有者人数\n"
"        #[view］\n"
"        fn get_num_owners() -&gt; usize {\n"
"            num_owners::read()\n"
"        }\n"
"\n"
"\n"
"        //获取所有者的公钥\n"
"        //TODO - 将所有者递归添加到数组中并返回，也许需要等待循环启用\n"
"\n"
"\n"
"        //外部函数\n"
"\n"
"        #外部函数\n"
"        fn submit_tx(public_key: felt252) {\n"
"\n"
"            //需要检查调用者是否是所有者之一。\n"
"            let tx_info = starknet::get_tx_info().unbox()；\n"
"            让签名：Span<felt252> = tx_info.signature；\n"
"            let caller = get_caller_address()；\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH')；\n"
"\n"
"            // 更新事务索引\n"
"            让 tx_index = curr_tx_index::read()；\n"
"\n"
"            //`true` 如果签名有效，否则为`false`。\n"
"            断言\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash、\n"
"                    public_key: 公钥、\n"
"                    signature_r： *signature.at(0_u32)、\n"
"                    signature_s： *signature.at(1_u32)、\n"
"                ),\n"
"                无效签名\n"
"            );\n"
"\n"
"            transactions::write(tx_index, tx_info.transaction_hash)；\n"
"            curr_tx_index::write(tx_index + 1)；\n"
"\n"
"        }\n"
"\n"
"        #[外部］\n"
"        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
"\n"
"            let transaction_hash = transactions::read(tx_index)；\n"
"            //TBD：断言 tx_hash 不为空\n"
"\n"
"            let num_confirmations = tx_confirms::read(tx_index)；\n"
"            let executed = tx_is_executed::read(tx_index)；\n"
"\n"
"            assert(executed == false, 'TX_ALREADY_EXECUTED')；\n"
"\n"
"            let caller = get_caller_address()；\n"
"            let tx_info = starknet::get_tx_info().unbox()；\n"
"            让签名：span<felt252> = tx_info.signature；\n"
"\n"
"             断言\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash、\n"
"                    public_key: 公钥、\n"
"                    signature_r： *signature.at(0_u32)、\n"
"                    signature_s： *signature.at(1_u32)、\n"
"                ),\n"
"                无效签名\n"
"            );\n"
"\n"
"            let confirmed = has_confirmed::read((caller, tx_index))；\n"
"\n"
"            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED')；\n"
"            tx_confirms::write((tx_index, num_confirmations+1_usize)；\n"
"            has_confirmed::write((caller, tx_index), true)；\n"
"\n"
"\n"
"        }\n"
"\n"
"        //验证至少有两个签名的示例函数\n"
"        fn validate_transaction(public_key: felt252) -&gt; felt252 {\n"
"            let tx_info = starknet::get_tx_info().unbox()；\n"
"            让签名：Span<felt252> = tx_info.signature；\n"
"            let caller = get_caller_address()；\n"
"            assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH')；\n"
"\n"
"            //`true` 如果签名有效，否则为`false`。\n"
"            assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash、\n"
"                    public_key: 公钥、\n"
"                    signature_r： *signature.at(0_u32)、\n"
"                    signature_s： *signature.at(1_u32)、\n"
"                ),\n"
"                无效签名\n"
"            );\n"
"\n"
"            Starknet::验证\n"
"        }\n"
"\n"
"        //内部函数\n"
"        //将多重标识符的公钥添加到永久存储中的函数\n"
"        fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
"            if owners_len == 0_usize {\n"
"            }\n"
"\n"
"            index_too_owner::write(owners_len, *public_keys.at(owners_len - "
"1_usize))；\n"
"            owner_to_index::write(*public_keys.at(owners_len - 1_usize), "
"owners_len)；\n"
"            _set_owners(owners_len - 1_u32, public_keys)；\n"
"        }\n"
"\n"
"\n"
"        #[外部］\n"
"        fn __validate_deploy__(\n"
"            class_hash: felt252, contract_address_salt: felt252, public_key_: "
"felt252\n"
"        ) -&gt; felt252 {\n"
"            验证交易(public_key_)\n"
"        }\n"
"\n"
"        #[外部］\n"
"        fn __validate_declare__(class_hash: felt252, public_key_: felt252) -"
"&gt; felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[外部］\n"
"        fn __validate__(\n"
"            contract_address：contract_address: ContractAddress, "
"entry_point_selector: felt252, calldata：Array::<felt252>, public_key_: "
"felt252\n"
"        ) -&gt; felt252 {\n"
"            validate_transaction(public_key_)\n"
"        }\n"
"\n"
"        #[外部］\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address：contract_address: ContractAddress, "
"entry_point_selector: felt252, calldata：Array::<felt252> 、\n"
"            tx_index: felt252\n"
"        ) -&gt; Span:：<felt252> {\n"
"            // 验证调用者。\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER')；\n"
"\n"
"            // 在此检查 tx 版本，因为版本 0 的事务会跳过 __validate__ 函数。\n"
"            let tx_info = starknet::get_tx_info().unbox()；\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION')；\n"
"\n"
"            //在此进行多重配码检查\n"
"            let num_confirmations = tx_confirms::read(tx_index)；\n"
"            let owners_len = num_owners::read()；\n"
"            //为提交者减去一个\n"
"            let required_confirmations = threshold::read() - 1_usize；\n"
"            assert(num_confirmations &gt;= required_confirmations, "
"'MINIMUM_50%_CONFIRMATIONS')；\n"
"\n"
"            tx_is_executed::write(tx_index, true)；\n"
"\n"
"            starknet::call_contract_syscall(\n"
"                contract_address, entry_point_selector, calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"    }\n"
"```"

#: src/ch04-04-02-multisig.md:248
#, fuzzy
msgid "Multisig Transaction Flow"
msgstr "多位密码交易流程"

#: src/ch04-04-02-multisig.md:250
#, fuzzy
msgid "The flow of a multisig transaction includes the following steps:"
msgstr "多重签名交易的流程包括以下步骤："

#: src/ch04-04-02-multisig.md:252
#, fuzzy
msgid ""
"Submitting a transaction: Any of the owners can submit a transaction from the "
"account."
msgstr "提交交易：任何所有者都可以提交账户交易。"

#: src/ch04-04-02-multisig.md:255
#, fuzzy
msgid ""
"Confirming the transaction: The owner who hasn’t submitted a transaction can "
"confirm the transaction."
msgstr "确认交易：未提交交易的所有者可以确认交易。"

#: src/ch04-04-02-multisig.md:258
#, fuzzy
msgid ""
"The transaction will be successfully executed if the number of confirmations "
"(including the submitter’s signature) is greater than or equal to the "
"threshold number of signatures, else it fails. This mechanism of confirmation "
"ensures that no single party can unilaterally perform critical actions, "
"thereby enhancing the security of the account."
msgstr ""
"如果确认数（包括提交者的签名）大于或等于阈值签名数，则交易成功执行，否则交易失"
"败。这种确认机制可确保任何一方都无法单方面执行关键操作，从而提高账户的安全性。"

#: src/ch04-04-02-multisig.md:264
#, fuzzy
msgid "Exploring Multisig Functions"
msgstr "探索多重标识符功能"

#: src/ch04-04-02-multisig.md:266
#, fuzzy
msgid ""
"Let’s take a closer look at the various functions associated with multisig "
"functionality in the provided contract."
msgstr "让我们来仔细看看所提供合约中与多重签名功能相关的各种功能。"

#: src/ch04-04-02-multisig.md:269
#, fuzzy
msgid "`_set_owners` Function"
msgstr "`_set_owners` 功能"

#: src/ch04-04-02-multisig.md:271
#, fuzzy
msgid ""
"This is an internal function designed to add the public keys of the account "
"owners to a permanent storage. Ideally, a multisig account structure should "
"permit adding and deleting owners as per the agreement of the account owners. "
"However, each change should be a transaction requiring the threshold number "
"of signatures."
msgstr ""
"这是一项内部功能，旨在将账户所有者的公开密钥添加到永久存储器中。理想情况下，多"
"签名账户结构应允许根据账户所有者的协议添加和删除所有者。不过，每次更改都应是一"
"个需要一定数量签名的交易。"

#: src/ch04-04-02-multisig.md:277
#, fuzzy
msgid ""
"```rust\n"
"    //INTERNAL FUNCTION\n"
"    //Function to add the public keys of the multisig in permanent storage\n"
"    fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
"        if owners_len == 0_usize {\n"
"        }\n"
"\n"
"        index_to_owner::write(owners_len, *public_keys.at(owners_len - "
"1_usize));\n"
"        owner_to_index::write(*public_keys.at(owners_len - 1_usize), "
"owners_len);\n"
"        _set_owners(owners_len - 1_u32, public_keys);\n"
"    }\n"
"```"
msgstr ""
"```rust\n"
"    //内部函数\n"
"    //将多重标识符的公钥添加到永久存储中的函数\n"
"    fn _set_owners(owners_len: usize, public_keys: Array::<felt252>) {\n"
"        if owners_len == 0_usize {\n"
"        }\n"
"\n"
"        index_too_owner::write(owners_len, *public_keys.at(owners_len - "
"1_usize))；\n"
"        owner_to_index::write(*public_keys.at(owners_len - 1_usize), "
"owners_len)；\n"
"        _set_owners(owners_len - 1_u32, public_keys)；\n"
"    }\n"
"```"

#: src/ch04-04-02-multisig.md:290
#, fuzzy
msgid "`submit_tx` Function"
msgstr "`submit_tx` 功能"

#: src/ch04-04-02-multisig.md:292
#, fuzzy
msgid ""
"This external function allows the owners of the account to submit "
"transactions. Upon submission, the function checks the validity of the "
"transaction, ensures the caller is one of the account owners, and adds the "
"transaction to the transactions map. It also increments the current "
"transaction index."
msgstr ""
"该外部函数允许账户所有者提交交易。提交后，该函数会检查事务的有效性，确保调用者"
"是账户所有者之一，并将事务添加到事务映射中。它还会递增当前的交易索引。"

#: src/ch04-04-02-multisig.md:298
#, fuzzy
msgid ""
"```rust\n"
"    #[external]\n"
"    fn submit_tx(public_key: felt252) {\n"
"\n"
"        //Need to check if caller is one of the owners.\n"
"        let tx_info = starknet::get_tx_info().unbox();\n"
"        let signature: Span<felt252> = tx_info.signature;\n"
"        let caller = get_caller_address();\n"
"        assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH');\n"
"\n"
"        //Updating the transaction index\n"
"        let tx_index = curr_tx_index::read();\n"
"\n"
"        //`true` if a signature is valid and `false` otherwise.\n"
"        assert(\n"
"            check_ecdsa_signature(\n"
"                message_hash: tx_info.transaction_hash,\n"
"                public_key: public_key,\n"
"                signature_r: *signature.at(0_u32),\n"
"                signature_s: *signature.at(1_u32),\n"
"            ),\n"
"            'INVALID_SIGNATURE',\n"
"        );\n"
"\n"
"        transactions::write(tx_index, tx_info.transaction_hash);\n"
"        curr_tx_index::write(tx_index + 1);\n"
"\n"
"    }\n"
"```"
msgstr ""
"```信任\n"
"    #[外部］\n"
"    fn submit_tx(public_key: felt252) {\n"
"\n"
"        //需要检查调用者是否是所有者之一。\n"
"        let tx_info = starknet::get_tx_info().unbox()；\n"
"        让签名：Span<felt252> = tx_info.signature；\n"
"        let caller = get_caller_address()；\n"
"        assert(signature.len() == 2_u32, 'INVALID_SIGNATURE_LENGTH')；\n"
"\n"
"        // 更新事务索引\n"
"        让 tx_index = curr_tx_index::read()；\n"
"\n"
"        //`true` 如果签名有效，否则为`false`。\n"
"        断言\n"
"            check_ecdsa_signature(\n"
"                message_hash: tx_info.transaction_hash、\n"
"                public_key: 公钥、\n"
"                signature_r： *signature.at(0_u32)、\n"
"                signature_s： *signature.at(1_u32)、\n"
"            ),\n"
"            无效签名\n"
"        );\n"
"\n"
"        transactions::write(tx_index, tx_info.transaction_hash)；\n"
"        curr_tx_index::write(tx_index + 1)；\n"
"\n"
"    }\n"
"```"

#: src/ch04-04-02-multisig.md:328
#, fuzzy
msgid "`confirm_tx` Function"
msgstr "`confirm_tx` 功能"

#: src/ch04-04-02-multisig.md:330
#, fuzzy
msgid ""
"Similarly, the **_`confirm_tx`_** function provides a way to record "
"confirmations for each transaction. An account owner, who did not submit the "
"transaction, can confirm it, increasing its confirmation count."
msgstr ""
"同样，**_`confirm_tx`_** 函数提供了一种记录每笔交易确认情况的方法。没有提交交"
"易的账户所有者可以确认交易，从而增加确认次数。"

#: src/ch04-04-02-multisig.md:334
#, fuzzy
msgid ""
"```rust\n"
"        #[external]\n"
"        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
"\n"
"            let transaction_hash = transactions::read(tx_index);\n"
"            //TBD: Assert that tx_hash is not null\n"
"\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let executed = tx_is_executed::read(tx_index);\n"
"\n"
"            assert(executed == false, 'TX_ALREADY_EXECUTED');\n"
"\n"
"            let caller = get_caller_address();\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            let signature: Span<felt252> = tx_info.signature;\n"
"\n"
"             assert(\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash,\n"
"                    public_key: public_key,\n"
"                    signature_r: *signature.at(0_u32),\n"
"                    signature_s: *signature.at(1_u32),\n"
"                ),\n"
"                'INVALID_SIGNATURE',\n"
"            );\n"
"\n"
"            let confirmed = has_confirmed::read((caller, tx_index));\n"
"\n"
"            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED');\n"
"            tx_confirms::write(tx_index, num_confirmations+1_usize);\n"
"            has_confirmed::write((caller, tx_index), true);\n"
"        }\n"
"```"
msgstr ""
"```信任\n"
"        #[外部］\n"
"        fn confirm_tx(tx_index: felt252, public_key: felt252) {\n"
"\n"
"            let transaction_hash = transactions::read(tx_index)；\n"
"            //TBD：断言 tx_hash 不为空\n"
"\n"
"            let num_confirmations = tx_confirms::read(tx_index)；\n"
"            let executed = tx_is_executed::read(tx_index)；\n"
"\n"
"            assert(executed == false, 'TX_ALREADY_EXECUTED')；\n"
"\n"
"            let caller = get_caller_address()；\n"
"            let tx_info = starknet::get_tx_info().unbox()；\n"
"            让签名：span<felt252> = tx_info.signature；\n"
"\n"
"             断言\n"
"                check_ecdsa_signature(\n"
"                    message_hash: tx_info.transaction_hash、\n"
"                    public_key: 公钥、\n"
"                    signature_r： *signature.at(0_u32)、\n"
"                    signature_s： *signature.at(1_u32)、\n"
"                ),\n"
"                无效签名\n"
"            );\n"
"\n"
"            let confirmed = has_confirmed::read((caller, tx_index))；\n"
"\n"
"            assert (confirmed == false, 'CALLER_ALREADY_CONFIRMED')；\n"
"            tx_confirms::write((tx_index, num_confirmations+1_usize)；\n"
"            has_confirmed::write((caller, tx_index), true)；\n"
"        }\n"
"```"

#: src/ch04-04-02-multisig.md:368
#, fuzzy
msgid "_`execute`_ Function"
msgstr "#### 执行函数"

#: src/ch04-04-02-multisig.md:370
#, fuzzy
msgid ""
"The _execute_ function serves as the final step in the transaction process. "
"It checks the validity of the transaction, whether it has been previously "
"executed, and if the threshold number of signatures has been reached. The "
"transaction is executed if all the checks pass."
msgstr ""
"_execute_函数是事务处理流程的最后一步。它会检查事务的有效性、是否已被执行过，"
"以及是否已达到签名数阈值。如果所有检查都通过，事务就会被执行。"

#: src/ch04-04-02-multisig.md:375
#, fuzzy
msgid ""
"```rust\n"
"    #[external]\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address: ContractAddress, entry_point_selector: felt252, "
"calldata: Array::<felt252>,\n"
"            tx_index: felt252\n"
"        ) -> Span::<felt252> {\n"
"            // Validate caller.\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER');\n"
"\n"
"            // Check the tx version here, since version 0 transaction skip "
"the __validate__ function.\n"
"            let tx_info = starknet::get_tx_info().unbox();\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION');\n"
"\n"
"            //Multisig check here\n"
"            let num_confirmations = tx_confirms::read(tx_index);\n"
"            let owners_len = num_owners::read();\n"
"            //Subtracting one for the submitter\n"
"            let required_confirmations = threshold::read() - 1_usize;\n"
"            assert(num_confirmations >= required_confirmations, "
"'MINIMUM_50%_CONFIRMATIONS');\n"
"\n"
"            tx_is_executed::write(tx_index, true);\n"
"\n"
"            starknet::call_contract_syscall(\n"
"                contract_address, entry_point_selector, calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"```"
msgstr ""
"```信任\n"
"    #[外部]\n"
"        #[raw_output]\n"
"        fn __execute__(\n"
"            contract_address：ContractAddress, entry_point_selector: felt252, "
"calldata：Array::<felt252> 、\n"
"            tx_index: felt252\n"
"        ) -&gt; Span:：<felt252> {\n"
"            // 验证调用者。\n"
"            assert(starknet::get_caller_address().is_zero(), "
"'INVALID_CALLER')；\n"
"\n"
"            // 在此检查 tx 版本，因为版本 0 的事务会跳过 __validate__ 函数。\n"
"            let tx_info = starknet::get_tx_info().unbox()；\n"
"            assert(tx_info.version != 0, 'INVALID_TX_VERSION')；\n"
"\n"
"            //在此进行多重配码检查\n"
"            let num_confirmations = tx_confirms::read(tx_index)；\n"
"            let owners_len = num_owners::read()；\n"
"            //为提交者减去一个\n"
"            let required_confirmations = threshold::read() - 1_usize；\n"
"            assert(num_confirmations &gt;= required_confirmations, "
"'MINIMUM_50%_CONFIRMATIONS')；\n"
"\n"
"            tx_is_executed::write(tx_index, true)；\n"
"\n"
"            starknet::call_contract_syscall(\n"
"                contract_address, entry_point_selector, calldata.span()\n"
"            ).unwrap_syscall()\n"
"        }\n"
"```"

#: src/ch04-04-02-multisig.md:404
#, fuzzy
msgid "Closing Thoughts"
msgstr "结束语"

#: src/ch04-04-02-multisig.md:406
#, fuzzy
msgid ""
"This chapter has introduced you to the concept of multisig accounts in "
"Starknet and illustrated how they can be implemented using an account "
"contract. However, it’s important to note that this is a simplified example, "
"and a production-grade multisig contract should contain additional checks and "
"validations for robustness and security."
msgstr ""
"本章向您介绍了 Starknet 中多标识账户的概念，并说明了如何使用账户合约实施多标识"
"账户。不过，需要注意的是，这只是一个简化的示例，生产级多重身份验证合约应包含额"
"外的检查和验证，以确保稳健性和安全性。"

#, fuzzy
#~ msgid ""
#~ "A transaction's journey in Starknet, from its inception to finality, "
#~ "comprises a series of carefully orchestrated steps. Each stage plays a "
#~ "crucial role in ensuring data is accurately transmitted, processed, and "
#~ "stored within the network. In this chapter, we explore the lifecycle of a "
#~ "Starknet transaction."
#~ msgstr ""
#~ "在Starknet，一笔交易从开始到结束，包含一系列精心安排的步骤。每个阶段在确保"
#~ "数据在网络中准确传输、处理和存储方面都起着至关重要的作用。在本章中，我们将"
#~ "探讨Starknet交易的生命周期。"

#, fuzzy
#~ msgid "Preparing the Groundwork: Transaction Creation"
#~ msgstr "准备基础工作：创建交易"

#, fuzzy
#~ msgid ""
#~ "Every transaction's journey commences with its preparation. The sender "
#~ "queries the nonce of their account, serving as a unique identifier for "
#~ "each transaction, signs the transaction, and dispatches it to their Node. "
#~ "It's critical to understand the sender must be online during this process "
#~ "to access real-time data."
#~ msgstr ""
#~ "每笔交易都从准备交易开始。发送方查询其账户的 nonce（作为每笔交易的唯一标识"
#~ "符）、签署交易并将其发送到节点。在此过程中，发送方必须在线才能访问实时数"
#~ "据，这一点至关重要。"

#, fuzzy
#~ msgid ""
#~ "The Node, analogous to a post office, receives the transaction and "
#~ "broadcasts it on the Starknet network, primarily to the Sequencer. As the "
#~ "network evolves, the transaction will be broadcasted to multiple "
#~ "Sequencers."
#~ msgstr ""
#~ "节点（类似于邮局）接收交易，并在Starknet网络上广播，主要是向序列器广播。随"
#~ "着网络的发展，交易将被广播到多个序列器。"

#, fuzzy
#~ msgid ""
#~ "It is worth mentioning that before broadcasting the transaction to the "
#~ "Sequencer, the gateways perform some validations, such as checking that "
#~ "the max fee exceeds a minimum fee and the account's balance is greater "
#~ "than the max fee. The transaction will be saved in the storage if the "
#~ "validation function passes."
#~ msgstr ""
#~ "值得一提的是，在向序列器广播交易之前，网关会进行一些验证，例如检查最大费用"
#~ "是否超过最低费用，以及账户余额是否大于最大费用。如果验证功能通过，交易将被"
#~ "保存到存储区。"

#, fuzzy
#~ msgid "Reception and Processing: The Sequencer's Role"
#~ msgstr "接收和处理：编曲人的作用"

#, fuzzy
#~ msgid ""
#~ "On receiving the transaction, the Sequencer acknowledges its receipt but "
#~ "hasn't processed it yet—similar to Ethereum's mempool state."
#~ msgstr ""
#~ "在收到交易时，序列器会确认收到，但尚未处理--类似于以太坊的 mempool 状态。"

#, fuzzy
#~ msgid ""
#~ "It's crucial to remember the sequentiality of transaction processing in "
#~ "Starknet: the nonce won't update until the Sequencer processes your "
#~ "transaction. This aspect could become a hurdle when building backend "
#~ "applications, as sending multiple transactions consecutively may result in "
#~ "confusion or errors."
#~ msgstr ""
#~ "记住 Starknet 中事务处理的顺序性至关重要：在序列器处理您的事务之前，nonce "
#~ "不会更新。在构建后端应用程序时，这一点可能会成为一个障碍，因为连续发送多个"
#~ "事务可能会导致混乱或错误。"

#, fuzzy
#~ msgid "Acceptance on Layer-2 (L2)"
#~ msgstr "第 2 层（L2）上的验收"

#, fuzzy
#~ msgid ""
#~ "When the Sequencer validates and executes a transaction, it immediately "
#~ "updates the state without waiting for the block emission. The transaction "
#~ "status changes from 'received' to 'accepted on L2' at this stage."
#~ msgstr ""
#~ "当序列器验证并执行一个事务时，它会立即更新状态，而无需等待块发射。在此阶"
#~ "段，事务状态会从 \"收到 \"变为 \"L2 已接受\"。"

#, fuzzy
#~ msgid ""
#~ "Following the state update, the transaction is included in a block. "
#~ "However, the block isn't emitted immediately. The Sequencer decides the "
#~ "opportune moment to emit the block, either when there are enough "
#~ "transactions to form a block or after a certain time has passed. When the "
#~ "block is emitted, the block becomes available for other Nodes to query."
#~ msgstr ""
#~ "状态更新后，事务将被包含在一个块中。不过，区块不会立即发布。序列器会在有足"
#~ "够多的事务形成区块时，或在一定时间过去后，决定发出区块的时机。区块发布后，"
#~ "其他节点就可以查询该区块。"

#, fuzzy
#~ msgid ""
#~ "If a transaction fails during execution, it will be included in the block "
#~ "with the status 'reverted'."
#~ msgstr "如果事务在执行过程中失败，它将以 \"已恢复 \"的状态被包含在区块中。"

#, fuzzy
#~ msgid ""
#~ "It's essential to remember that at this stage, no proof has been "
#~ "generated, and the transaction relies on L2 consensus for security against "
#~ "censorship. There remains a slim possibility of transaction reversal if "
#~ "all Sequencers collude. Therefore, these stages should be seen as "
#~ "different layers of transaction finality."
#~ msgstr ""
#~ "必须记住的是，在这个阶段，还没有生成任何证明，交易的安全性依赖于二级共识，"
#~ "以防止审查。如果所有序列员都串通一气，交易逆转的可能性仍然微乎其微。因此，"
#~ "这些阶段应被视为交易最终性的不同层次。"

#, fuzzy
#~ msgid "Acceptance on Layer-1 (L1)"
#~ msgstr "第 1 层 (L1) 验收"

#, fuzzy
#~ msgid ""
#~ "The final step in the transaction's lifecycle is its acceptance on Layer-1 "
#~ "(L1). A Prover receives the block containing the transaction, re-executes "
#~ "the block, generates a proof, and sends it to Ethereum. Specifically, the "
#~ "proof is sent to a smart contract on Ethereum called the Verifier smart "
#~ "contract, which checks the proof's validity. If valid, the transaction's "
#~ "status changes to 'accepted on L1', signifying the transaction's security "
#~ "by Ethereum consensus."
#~ msgstr ""
#~ "交易生命周期的最后一步是在第一层（L1）接受交易。验证者接收包含交易的区块，"
#~ "重新执行区块，生成证明，并将其发送给以太坊。具体来说，该证明会被发送到以太"
#~ "坊上一个名为 \"验证者\"（Verifier）的智能合约，该合约会检查证明的有效性。如"
#~ "果有效，交易的状态就会变为 \"已接受 L1\"，这表示以太坊共识保证了交易的安全"
#~ "性。"

#, fuzzy
#~ msgid "\\[Optional\\] Transaction Finality in Starknet"
#~ msgstr "Optional\\[Optional\\] Starknet的交易终结性"

#, fuzzy
#~ msgid ""
#~ "Transaction finality refers to the point at which a transaction is "
#~ "considered irreversible and is no longer susceptible to being reversed or "
#~ "undone. It's the assurance that once a transaction is committed, it can't "
#~ "be altered or rolled back, hence securing the integrity of the transaction "
#~ "and the system as a whole."
#~ msgstr ""
#~ "事务终结性是指事务被视为不可逆转、不再可能被逆转或撤销的时间点。它保证了事"
#~ "务一旦提交，就无法更改或回滚，从而确保了事务和整个系统的完整性。"

#, fuzzy
#~ msgid ""
#~ "Let's dive into the transaction finality in both Starknet and Ethereum, "
#~ "and how they compare."
#~ msgstr "让我们深入了解一下Starknet和以太坊的交易终结性，以及它们之间的比较。"

#, fuzzy
#~ msgid "Ethereum Transaction Finality"
#~ msgstr "以太坊交易终结性"

#, fuzzy
#~ msgid ""
#~ "Ethereum operates on a Proof of Stake (PoS) consensus mechanism. A "
#~ "transaction has the finality status when it is part of a block that can't "
#~ "change without a significant amount of ETH getting burned. The number of "
#~ "blocks required to ensure that a transaction won't be rolled back is "
#~ "called 'blocks to finality', and the time to create those blocks is called "
#~ "'time to finality'."
#~ msgstr ""
#~ "以太坊采用权益证明（PoS）共识机制。当一个交易属于一个区块的一部分时，该交易"
#~ "就具有终结性。确保交易不会回滚所需的区块数量称为 \"最终区块\"，创建这些区块"
#~ "所需的时间称为 \"最终时间\"。"

#, fuzzy
#~ msgid ""
#~ "It is considered to be an average of 6 blocks to reach the finality "
#~ "status; given that a new block is validated each 12 seconds, the average "
#~ "time to finality for a transaction is 75 seconds."
#~ msgstr ""
#~ "平均需要 6 个区块才能达到最终状态；考虑到每 12 秒验证一个新区块，一笔交易达"
#~ "到最终状态的平均时间为 75 秒。"

#, fuzzy
#~ msgid "Starknet Transaction Finality"
#~ msgstr "Starknet交易终结"

#, fuzzy
#~ msgid ""
#~ "Starknet, a Layer-2 (L2) solution on Ethereum, has a two-step transaction "
#~ "finality process. The first step is when the transaction gets accepted on "
#~ "Layer-2 (Starknet), and the second step is when the transaction gets "
#~ "accepted on Layer-1 (Ethereum)."
#~ msgstr ""
#~ "Starknet是以太坊上的第二层（L2）解决方案，其交易终结流程分为两步。第一步是"
#~ "交易在第二层（Starknet）被接受，第二步是交易在第一层（以太坊）被接受。"

#, fuzzy
#~ msgid ""
#~ "Accepted on L2: When a transaction is processed by the Sequencer and "
#~ "included in a block on Starknet, it reaches L2 finality. However, this "
#~ "finality relies on the L2 consensus and comes with a slight risk of "
#~ "collusion among Sequencers leading to transaction reversal."
#~ msgstr ""
#~ "在 L2 上被接受：当一个交易被序列器处理并包含在Starknet的一个区块中时，它就"
#~ "达到了 L2 最终性。然而，这种最终性依赖于 L2 共识，并伴随着序列器之间串通导"
#~ "致交易逆转的轻微风险。"

#, fuzzy
#~ msgid ""
#~ "Accepted on L1: The absolute finality comes when the block containing the "
#~ "transaction gets a proof generated, the proof is validated by the Verifier "
#~ "contract on Ethereum, and the state is updated on Ethereum. At this point, "
#~ "the transaction is as secure as the Ethereum's PoW consensus can provide, "
#~ "meaning it becomes computationally infeasible to alter or reverse."
#~ msgstr ""
#~ "在 L1 上被接受：当包含交易的区块生成证明，证明由以太坊上的验证者合约验证，"
#~ "并在以太坊上更新状态时，交易绝对完成。此时，交易的安全性已达到以太坊 PoW 共"
#~ "识所能提供的程度，这意味着更改或逆转交易在计算上变得不可行。"

#~ msgid "Comparison"
#~ msgstr "比较"

#, fuzzy
#~ msgid ""
#~ "The main difference between Ethereum and Starknet's transaction finality "
#~ "lies in the stages of finality and their reliance on consensus mechanisms."
#~ msgstr ""
#~ "以太坊和Starknet交易最终性的主要区别在于最终性的阶段以及它们对共识机制的依"
#~ "赖。"

#, fuzzy
#~ msgid ""
#~ "Ethereum's transaction finality becomes increasingly unlikely to be "
#~ "reversed as more blocks are added."
#~ msgstr "随着区块数量的增加，以太坊的交易终结性越来越不可能被逆转。"

#, fuzzy
#~ msgid ""
#~ "Starknet's finality process is two-fold. The initial finality (L2) is "
#~ "quicker but relies on L2 consensus"
#~ msgstr "Starknet的终审程序分为两个阶段。初始终局（L2）更快，但依赖于 L2 共识"
